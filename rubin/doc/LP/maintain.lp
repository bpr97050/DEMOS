












           000000   0     0  0000000  0     0  0     0
           0     0  0     0  0        0     0  0     0
           0     0  0     0  0        0   0 0  0     0
           000000    000000  000000   0  0  0  0000000
           0              0  0     0  0 0   0  0     0
           0              0  0     0  0     0  0     0
           0        000000   000000   0     0  0     0






         СС ИИ СС ТТ ЕЕ ММ АА   УУ ПП РР АА ВВ ЛЛ ЕЕ НН ИИ ЯЯ   ББ АА ЗЗ ОО ЙЙ
                     ДД АА НН НН ЫЫ ХХ   РР УУ ББ ИИ НН


                            ВЕРСИЯ 2
        С О П Р О В О Ж Д Е Н И Е    Б А З   Д А Н Н Ы Х
                    В    С У Б Д   Р У Б И Н

















                         ММоосскквваа 77//2244//8899





















1.  ВВЕДЕНИЕ

    В этой статье мы описываем как создавать,  структурировать  и
    поддерживать отношения в РУБИН.  Мы предполагаем, что пользо-
    ватель знаком с РУБИН, понимает QUEL - язык  запросов  РУБИН.
    Настоятельно  вам советуем для начала прочитать и попробовать
    на практике документ "Учебное введение в РУБИН", и иметь  при
    себе "Справочное руководство по СУБД РУБИН".

    Настоящий документ разделен на шесть разделов.

         1.  Введение

         2.  Создание отношения

         3.  Использование команды copy

         4.  Структуры памяти

         5.  Вторичная индексация

         6.  Восстановление и изменение данных

    Для создания новых данных вы должны быть пользователем  РУБИН
    и  иметь  разрешение на создание базы данных.  Это разрешение
    дает вам ingres-суперпользователь.  При выполнении этих  двух
    требований  вы  можете создавать базу данных с использованием
    команды командного языка SHELL операционной системы ДЕМОС:

    % creatdb mydata

    где "mydata" - это имя создаваемой базы данных (если  вы  хо-
    тите  разместить  новую базу в своем справочнике, отличном от
    стандартного справочника РУБИН, в команде  creatdb  добавится
    еще параметр "-dполное_имя_справочника", подробнее см. раздел
    "creatdb(демос)" в справочном руководстве по РУБИН).  Вы ста-
    новитесь  т.н.  "администратором базы данных" ("data base ad-
    ministrator" - DBA) для базы данных mydata.  И уже  как  DBA,
    вы имеете некоторые специальные полномочия.

   1.  Доступ ко всем отношениям базы данных "mydata" может  осу-
        ществляться  другими  пользователями не иначе, как из нее
        самой.  Если какой-либо пользователь  создает  отношение,
        оно принадлежит только ему, и доступ к отношению не имеет
        права менять ни DBA, ни любой другой пользователь.

   2.  В РУБИН и при печати вы  можете  использовать  ключ  "-u".
        При  этом  обеспечивается  возможность одновременного ис-
        пользования базы  данных  "mydata"  совместно  с  другими
        пользователями.   Отсылаем вас к руководству пользователя
        РУБИН к разделам rubin(демос) и  users(files)  для  более
        детального изучения.

   3.  Вы имеете право запускать команды sysmod, restore и  purge



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                      Стр. 2








        на базе данных  "mydata".

   4.  По умолчанию база данных создается с возможностью  исполь-
        зования ее в многопользовательском режиме.  Если в каждый
        момент времени с ней хочет работать только один пользова-
        тель, администратор базы данных должен отключить управле-
        ние одновременной работой пользователей.  Смотрите статью
        creatdb(демос) в руководстве пользователя РУБИН.

    Если база данных была создана, вы можете сразу  же  запустить
    команду

    % sysmod mydata

    Эта программа преобразовывает системные  отношения  в  струк-
    туру,  которая  обеспечивает  наилучшее  использование РУБИН.
    sysmod будет рассматриваться подробнее в разделе 4.

    Будучи как DBA, так и обычным пользователем, вы можете созда-
    вать  и структурировать новые отношения в тех базах данных, в
    которых вам это разрешено.  В оставшейся  части  этого  доку-
    мента мы опишем как это делается.



































СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                      Стр. 3









2.  СОЗДАНИЕ НОВЫХ ОТНОШЕНИЙ В РУБИН




    Существует два пути для создания отношений в РУБИН.

         create
         retrieve into

    "Retrieve into" испольуется для формирования нового отношения
    из одного или более существующих отношений.  "Create" исполь-
    зуется для создания нового отношения, в котором нет кортежей.

    пример 1:

         range of p is parts
         range of s is supply
         retrieve into newsupply(
                       number = s.snum,
                       p.pname,
                       s.shipdate)
         where s.pnum = p.pnum

    пример 2:

         create newsupply(
                number = i2,
                pname = c20,
                shipdate = c8)

    В примере 1 РУБИН создает новое отношение, которое называется
    "newsupply",  считая,  что  формат  каждого  домена известен.
    Запрос на создание будет выполнен и отношение будет модифици-
    ровано в структуру "cheapsort".  (Это будет описано более де-
    тально в разделе 4).

    В примере 2 создается отношение "newsupply", когда дается имя
    и формат каждого домена.  Разрешенные форматы это:

    i1             1  байтовое целое
    i2             2   "      "
    i4     один блок.

    Отношения делятся на страницы по 512 байт.  РУБИН никогда  не
    размещает  кортеж между двумя страницами.  Поэтому всегда ос-
    тается свободное место.  На странице размещаются заголовок  в
    12  байт  плюс  2  байта вспомогательной информации на каждый
    кортеж на странице.  Формула:

    number tuples per page = 500/(tuple width + 2)

    wasted space = 500 - number of tuples per page



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                      Стр. 4








     *(tuple width +2)

    В нашем примере это будет так:

    22 = 500/(20 + 2)

    16 = 500 - 22 * (20 + 2)

    22 кортежа на страницу и 16 байт остается  незаполненными  на
    каждой странице.  Такой подсчет верен только для несжатых от-
    ношений.  Мы еще вернемся к этому предмету в разделе 4, когда
    будем обсуждать сжатие.

    Если вы забыли имя домена или его формат, используйте команду
    "help".  Например, если вы дадите команду РУБИН:

         help newsupply

    будет напечатано следующее:

    Отношение:              newsupply
    Владелец:               bob
    Ширина кортежа:         30
    Сохранять до:           Thu Nov 10 16:17:06 1977
    Число кортежей:         0
    структура пмяти:        paged heap
    Тип отношения:          user relation

     имя атрибута      тип   длина    ключ.

     number             i       2
     pname              c      20
     shipdate           c       8

    Отметим, что каждое отношение имеет  свое  время  хранения  в
    системе.   По  умолчанию оно устанавливается равным одной не-
    деле с момента создания.  Команда "save" может быть использо-
    вана  для  увеличения  времени  хранения.  См. "save(quel)" и
    "purge(демос)" в руководстве пользователя РУБИН.


















СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                      Стр. 5









3.  КОПИРОВАНИЕ ДАННЫХ ИЗ/В РУБИН




    Если отношение создано, существует два механизма для  занесе-
    ния новых данных:

         команда append
         команда copy

    append  используется для занесения одного кортежа за одно об-
    ращение,  или для заполнения одного отношения из других отно-
    шений.

    copy используется для копирования данных из файла ДЕМОС в от-
    ношение.   Она  используется для копирования данных из каких-
    либо программ, или для копирования данных из  других  систем.
    А  также  является  наилучшим путем для копирования некоторых
    данных, содержащих более одного кортежа.

    давайте начнем с создания простого  отношения  и  поместим  в
    него данные.

    Пример:

    create donation (name = c10, amount = f4, ext = i2)

    Теперь предположим, что мы  хотим занести в отношение  записи
    о  двух людях.  Простейшей процедурой, вероятно, является за-
    пуск двух запросов в РУБИН с использованием команды append.

    append to donation (name="frank",amount = 5,
                        ext = 204)

    append to donation (name="harry",ext = 209,
                        amount = 4.50)

    Заметим, что порядок укзания  имен  доменов  не  существенен.
    РУБИН  находит указанные имена атрибутов и не обращает внима-
    ния на порядок их следования в списке.  Теперь отношение "do-
    nation" выглядит следующим образом:

    donation relation

    |name      |amount    |ext   |
    |----------------------------|
    |frank     |5.000     |204   |
    |harry     |4.500     |209   |
    |----------------------------|

    Теперь у нас  в  отношении  donation  введены  два  человека.
    Предположим,  мы должны ввести еще 50 человек.  Используя ко-



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                      Стр. 6








    манду append, такая задача становится  слишком  утомительной,
    т.к.   для каждого кортежа приходится слишком много печатать.
    Команда copy в данном случае больше подходит для решения  на-
    шей задачи.

    Copy способна взять данные из обычного файла ДЕМОС в  различ-
    ных  форматах  и  добавить их к отношению.  Для использования
    команды copy сначала создается файл ДЕМОС (например с исполь-
    зованием редактора "ed"), содержащий нужные данные.

    Например, давайте поместим пять новых имен в файл,  используя
    редактор.

    % ed
    a
    bill,3.50,302
    sam,10.00,410
    susan,,100
    sally,.5,305
    george,4.00,302
    .
    w newdom
    68
    q
    %

    Формат вышеуказанного файла следующий: сначала имя, за  кото-
    рым  следует  запятая, за ним следует размер вклада, запятая,
    затем расширение и в конце символ новой строки.  Пустое  зна-
    чение  заносится,  например  размер  вклада (amount) у susan,
    указанием нуля для домена числового типа и указанием  пробела
    для домена символьного типа.

    Для использования copy мы входим в РУБИН и подаем команду:

         copy donation (name = c0, amount = c0, ext = c0)
                 from "/mnt/bob/newdom"

    Таким образом, как работает команда copy:

         copy relname (list of what to copy) from "full pathname"

    Для вышеприведенного случая мы запишем:

         copy donation (. . .) from "/mnt/bob/newdom"

    Домены amount и ext хранятся в отношении как f4 (вещественное
    с  плавающей  точкой)  и  и  i2  (целое), а в файле ДЕМОС они
    представлены, как символьные данные.  В указанном формате до-
    мена copy  получает:

         домен = формат

    где домен - это имя домена и формат - это формат в файле  ДЕ-



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                      Стр. 7








    МОС один из:

    i1, i2, i4         (целое, размером 1, 2, или 4)
    f4, f8             (вещественное с плавающей точкой,
                        размером 4 или 8)
    c1, c2, c3,...c255 (символьная строка
                        фиксированной длины)
    c0                 (символьная строка переменования
                        данных из каких-либо программ
                        или для копирования данных из
                        других систем.  Это также
                        является наилучшим путем для
                        копирования некоторых данных,
                        содержащих более одного кортежа.

    Давайте начнем с создания простого  отношения  и  поместим  в
    него данные.

    Пример:

    create donation (name = c10, amount = f4,
                     ext = i2)

    В примере мы используем

         name = c0, amount = c0, extension = c0

    Значения каждого домена нашего отношения  хранились  в  файле
    ДЕМОС  как символьные строки переменной длины.  Copy рассмат-
    ривает первую запятую, символ табуляции или новой строки, как
    конец  строки  данных.  copy преимущественно используется при
    первоначальном занесении данных в отношение.

    copy также может быть использована для копирования данных  из
    отношения в файл ДЕМОС.  Например:

    copy donation (name = c10, amount = c10,
         ext = c5) into "/mnt/bob/data"

    В этом случае будет происходить следующее:

   1.  Если файл /mnt/bob/data уже существовал, он будет  уничто-
        жен.

   2.  файл создается с кодами доступа 600 (чтение/запись  только
        владельцу)

   3.  Имя будет копироваться как 10-символьное поле, за  которым
        сразу  же  следует поле атрибута amount, за которой сразу
        же следует поле атрибута ext.  Значение  атрибута  amount
        будет преобразовываться в символьное поле шириной 10 сим-
        волов.  Значение атрибута ext будет  преобразовываться  в
        символьное поле шириной 5 символов.




СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                      Стр. 8








    Файл "/mnt/bob/data" будет набором символов, выглядящим приб-
    лизительно так:

    frank       5.000  204harry      4.500  209
    bill        3.500  302sam       10.000  410
    susan       0.000  100sally      0.500  305
    george      4.000  302


    Вывод будет разбит на четыре строки для  удобного  размещения
    на  этой странице.  В настоящее время файл это просто строка.
    Другой пример:

    copy (name = c0, colon = d1, ext = c0,
          comma = d1, amt = c0, nl = d1)
    into "/mnt/bob/data"

    В этом примере "c0" интерпретируется как "используется подхо-
    дящий  символьный  формат".   Для символьных доменов это есть
    ширина поля домена.  Домены численного типа  преобразуются  в
    символьные в соответствии с принятыми умолчаниями РУБИН.

    Операторы:

         двоеточие = d1
         запятая = d1
         символ новой строки = d1

    используются для вставки одного двоеточия,  одной  запятой  и
    одного  символа перевода каретки в файл.  Формат "d1" интерп-
    ретируется как один фиктивный символ.  При копировании в файл
    ДЕМОС, выбираемое множество символов может быть подставлено в
    файл с использованием спецификации "фиктивный домен".   Таким
    образом, файл "/mnt/bob/data" будет выглядеть:

    frank     :   204,     5.000
    harry     :   209,     4.500
    bill      :   302,     3.500
    sam       :   410,    10.000
    susan     :   100,     0.000
    sally     :   305,     0.500
    george    :   302,     4.000


    Если вы хотите получить файла с двоичным  представлением  чи-
    сел, вы должны использовать:

         copy (name = c10, amount = f4, ext = i2)

    При этом будет создаваться файл с точной копией каждого  кор-
    тежа,  следующей  одна  за другой.  Это очень часто нужно для
    целей временного хранения, при этом гарантируется точное зна-
    чение доменов типа вещественных с плавающей точкой.




СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                      Стр. 9








    ТИПИЧНЫЕ ОШИБКИ

    Имеется 17 различных ошибок, которые возникают при  использо-
    вании команды copy.  Сейчас мы обсудим наиболее общие из них.

    Предположим, что у нас есть файл:

    bill,3.5,302
    sam,10,410,
    susan,3,100

    и мы запускаем команду copy

    copy donation (name = c0, amount = c0,
                   ext = c0)
         from "/mnt/bob/data"

    Вы получите сообщение об ошибке

    5809: COPY: плохая строка на вводе.
    Ввод был "susan". Только 2 кортежа
    нормально скопировались из
    /mnt/bob/data в отношение donation.

    Произошло это из-за того, чо во второй строке была лишняя за-
    пятая.  Первые два кортежа скопировались правильно.  Для сле-
    дующего кортежа получили: name = "" (пробел), amount  =  "su-
    san", and ext = "3".  Однако, "susan" не вещественное  с пла-
    вающей точкой, произошла  ошибка  и  выполнение  прекратилось
    после копирования двух кортежей.

    Если вы пытаетесь скопировать файл, такой как

    nancy,5.0,35000

    вы также получите диагностическое сообщение

    5809: COPY: плохая строка на вводе для домена ext.
    Было введено "35000". При этом ни одного кортежа
    не будет скопировано в отношение donation из
    /mnt/bob/data.

    Таким образом, т.к. ext является целым доменом i2, он не  мо-
    жет принимать значение больше чем 32767.

    Существуют также еще другие диагностические сообщения,  боль-
    шинство из них самоочевидны.

    Кроме того, существуют три необязательных замечания,  которые
    могут возникать при копировании "из".

    Если вы производите копирование из файла в отношение, которое
    имеет  структуру  ISAM или хэшировано, появится счетчик числа
    повторяющихся кортежей (если таковые имеются).  Такая  ситуа-



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 10








    ция  не  возникает  при  структуре "куча" т.к. не применяется
    проверка на повторяющиеся кортежи.

    В РУБИН не разрешено хранить управляющие символы (такие,  как
    например  звонок "CTRL/G", и т.п.) Если copy читает управляю-
    щие символы, он преобразовывает их в пробелы и сообщает число
    доменов в которых они встретились.

    Если вы при копировании используете опцию c0, copy будет  вы-
    давать  сообщение,  если  некоторая  строка символов окажется
    длиннее, чем длина домена, и усекать длину вводимой строки.


    СПЕЦИАЛЬНЫЕ ОСОБЕННОСТИ

       Существует несколько специальных функций,  которые  позво-
    ляют осуществлять копирование немного более простым способом

1.  Оптовое копирование

    Если вы спросите:

        copy relname () from "file"
            или
        copy relname () into "file"

    copy будет рассматривать этот оператор следующим образом:

         копировать каждый домен в их естественном порядке в  со-
         отвветствии с их правильным форматом.

    Так же, если вы скажете

        copy donation () into "/mnt/bob/donation"

    это будет то же самое, как если бы вы спросили:

    copy donation (name = c10, amount = f4,
                    ext = i2)
         into "/mnt/bob/donation"

    Это обеспечивает более удобный путь для копирования отношения
    целиком и полностью из РУБИН.

2.  Фиктивные домены

    Если вы копируете данные с другой машины  или  из  программы,
    часто  бывает так, что нужно некторые данные пропустить.  Это
    можно сделать, используя  фиктивный  домен,  определенный  по
    форматам: d0, d1, d2 ... d511.  Например:

        copy rel (dom1 = c5, dummy = d2, dom2 = i4,
            dumb = d0) from "/mnt/me/data"




СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 11








    Первые 5 символов помещаются в dom1, следующие 2 символа  иг-
    норируются.  Следующие 4 байта являются целым типа i4 и поме-
    щаются в dom2,  оставшийся  раделитель  строки  игнорируется.
    Имя, данное фиктивному спецификатору, игнорируется.

    Как упоминалось выше, фиктивные домены  могут  использоваться
    при  копировании  в файл ДЕМОС для вставки специальных симво-
    лов.  Список зарезервированных имен включает:

         nl        символ новой строки
         tab       символ табуляции
         sp        свободное место
         nul       нулевой байт
         null      нулевой байт
         comma     ,
         dash      -
         colon     :
         lparen    (
         rparen    )

3.  Усечение

    Не совсе ясно, что  делать  в  случаях  возниконовения  такой
    ошибки,   и   как   правило,   приходится  начинать  сначала.
    Простейшиj путь решить это, "усекать" отношение.   Это  дела-
    ется командой:

        modify relname to truncated

    Происходит эффект удаления всех кортежей в отношении relname,
    освобождения дискового пространства, и создания вновь отноше-
    ния relname со структурой хранения "куча".   Т.е.  логический
    эквивалент  разрушения  с последующим созданием (но с немного
    меньшими ограничениями на типы).

    Однако и при таких действиях возможны  форматные  ошибки  при
    копировании,  т.е.  это  не является основным удачным приемом
    для копирования данных в отношение, которое уже содержит пра-
    вильный  набор  данных.  Наилучшим способом является создание
    временного отношения с такими же доменами, как и в существую-
    щем  отношении.   Данные  копируются во временное отношение и
    добавляются в реальное отношение.  Например:

    create tempdom(name=c10,amount=f4,ext=i2)

    copy tempdom(name=c0,amount=c0,ext=c0)
    from "/mnt/bob/data"

    range of td is tempdom
    append to donation(td.all)

    4.  Определяемые разделители

    Иногда желательно определить разделительные символы,  исполь-



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 12








    зуемые  при копировании из файла.  Это может быть сделано оп-
    ределением:

            домен = c0delim

    где "delim" это разрешенный разделитель, взятый из списка ре-
    зервированных  имен.   Этот  список был полностью приведен на
    предыдущей странице.

















































СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 13









4.  СТРУКТУРЫ ПАМЯТИ




    Займемся обсуждением эффективности.  Если вы уже создали  от-
    ношение  и поместили в него данные с помощью copy или append,
    РУБИН может выполнить некоторый запрос на отношении.  Сущест-
    вует  много  способов  с помощью которых вы можете достигнуть
    ускорения выполнения запроса.

    РУБИН может хранить отношение  в  трех  различных  внутренних
    структурах.   Они  называются  "heap"(куча), "isam"(индексно-
    последовательная), "hash"(хэшированная).  Для начала, мы  ко-
    ротко  опишем  каждую структуру, а позднее расширим нашу дис-
    куссию.

    HEAP(КУЧА)

    При первоначальном  создании  отношения,  оно  создается  как
    "куча".   Существуют две важных особенности структуры "heap":
    дублирующиеся кортежи не уничтожаются, ничего не  известно  о
    расположении кортежей.  если вы запустили запрос:

         range of d is donation
         retrieve (d.amount) where d.name = "bill"

    РУБИН будет читать каждый кортеж  в  отношении,  просматривая
    его на предмет поиска имени "bill".  Если отношение небольшое
    - это не имеет серьезного значения.  Но если отношение  очень
    большое, это займет минуты (или даже часы!).

    HASH(ХЭШИРОВАННАЯ)

    Хэш-структура отношения дает возможность ускорения поиска  по
    указанным  доменам.   (Такие домены обычно называются "ключе-
    выми").  Кроме того, хэшированное отношение не содержит  дуб-
    лирующихся кортежей.  Наример, предположим, что отношение do-
    nation хранится хэшированным по домену "name".  Тогда запрос:

         retrieve (d.amount) where d.name = "bill"

    будет выполняться быстро, т.к.  РУБИН  приблизительно  знает,
    где на диске хранятся нужный кортеж.  На отношении, в котором
    только несколько  кортежей,  вы  не  заметите  разницы  между
    структурами  "heap" и "hash".  Но как только отношение увели-
    чивается, разница становится все более и более заметна.

    ISAM(индексно-последовательная)

    Структура isam единственная, при которой  отношение  сортиру-
    ется  по  одному или более доменам, (также называемым "ключе-
    выми").  В "isam отношениях" тоже нет дублирующихся кортежей.



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 14








    Когда  добавляются  новые  кортежи, они помещаются "приблизи-
    тельно" в свою отсортированную позицию в отношении.   ("Приб-
    лизительность" будет объяснена чуть-чуть позднее).

    Предположим, что отношение donation имеет структуру  isam  по
    домену name.  Выполним запрос

         retrieve (d.amount) where d.name = "bill"

    РУБИН будет определять, где в отсортированном порядке  должно
    быть имя "bill", и читает только только ту часть отношения.

    Т.к. отношение приблизительно отсортировано,  структура  isam
    будет эффективна и для выполнения такого запроса:

         retrieve (d.amount) where d.name >= "b" and d.name < "g"

    Такой запрос будет выбирать все имена, начинающиеся с букв от
    "b"  до  "f".   Отношение не будет просматриваться полностью,
    т.к.  оно упорядочено по именам.


    ВЫБОР СТРУКТУР ПАМЯТИ

    Некоторые пользователи, создавшие отношение,  могут  изменить
    его структуру, используя команду "modify".  Например

     modify donation to hash on name
    или
     modify donation to isam on name

    или еще

     modify donation to heap


    ПЕРВИЧНЫЕ СТРАНИЦЫ И СТРАНИЦЫ ПЕРЕПОЛНЕНИЯ

    На этом этапе необходимо ввести понятие первичных  страниц  и
    страниц  переполнения  в структурах "hash" и "isam".  Обе эти
    структуры пользуются соответствием указанного кортежа указан-
    ной  странице  отношения, основанном на ключевых доменах кор-
    тежа.  Так,  каждая  страница  содержит  только  определенное
    подмножество кортежей отношения.

    Когда добавляется новый кортеж в отношение  структуры  "hash"
    или "isam", РУБИН сначала определяет, какой странице он пред-
    назначен, затем просматривает место на этой  странице.   Если
    там  есть  место, то кортеж помещается на эту страницу.  Если
    места нет, то создается "страница переполнения" и кортеж  по-
    мещается на нее.

    Страница переполнения связывается с исходной страницей.   Ис-
    ходная  страница  называется  "первичной".   Если заполняется



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 15








    страница переполнения, то  РУБИН  будет  связывать  следующую
    страницу  уже  с  ней.   Тем самым, мы получим одну первичную
    страницу, связанную со страницей переполнения,  связанную,  в
    свою  очередь, с другой страницей переполнения.  Страницы пе-
    реполнения при необходимости динамически создаются.


    ОПРЕДЕЛЕНИЕ СВОБОДНОГО МЕСТА

    Команда modify также  позволяет  вам  определить,  как  много
    места будет необходимо отношению по мере его роста.  Как было
    упомянуто в описании команды "create", отношение  делится  на
    страницы.   "fillfactor"  может быть использован для указания
    как заполнять каждую первичную страницу.  Это  решение  будет
    основываться  только на том, будут ли добавляться еще кортежи
    к отношению.  Например:

    modify donation to isam on name where
           fillfactor = 100

    Этим мы сообщаем команде modify, что  каждую  страницу  нужно
    заполнять полностью, насколько это возможно.

    modify donation to isam on name where
           fillfactor = 25

    Этот запрос обеспечит заполнение каждой  страницы  только  на
    25%,  другими словами, оставит 75% пустого места.  Это мы бу-
    дем делать, если мы имеем грубо говоря 1/4 заполненных данных
    и хотим по мере возможности распределять данные по алфавиту и
    в дальнейшем.

    Запомните, что если вы не определите fillfactor, то РУБИН бу-
    дет осуществлять самый подходящий выбор по умолчанию.  Также,
    когда страница  переполняется,  РУБИН  автоматически  создает
    "страницу  переполнения",  т.к. не бывает случая, при котором
    отношение не способно бы было расширяться.

    Когда отношение модифицируется в хэш-структуру,  должен  быть
    указан добавочный параметр "minpages" (минимальное количество
    страниц).  мodify будет гарантировать, что  для отношения бу-
    дет выделено "minpage" следующих первичных страниц.

    modify подсчитывает сколько первичных страниц  будет  необхо-
    димо  для  хранения существующих кортежей по указанному пара-
    метру fillfactor, предполагая, что не возникнет необходимости
    выделять  страницы  переполнения.  Если это число меньше, чем
    minpages, то вместо него используется minpages.

    Например:

    modify donation to hash on name where
           fillfactor = 50, minpages = 1




СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 16








    modify donation to hash on name where
           minpages = 150

    В первом случае мы гарантируем, что не будет больше  страниц,
    чем  необходимо для 50% заполнения.  Второй случай это типич-
    ный пример модификации пустых  или  почти  пустых  отношений.
    Если  заранее  известен  приблизительный максимальный размер,
    minpages может быть использован для гарантии,  что  отношение
    будет иметь свой предполагаемый максимальный размер.

    Есть еще одна опция, употребляемая в хэшированном  отношении,
    называемая  "maxpages".   Ее  синтаксис  аналогичен minpages.
    Она может быть использована для определения  максимально  ис-
    пользуемого числа первичных страниц.

    СЖАТИЕ

    Три структуры памяти (heap, hash, isam) также могут использо-
    ваться  в  свей "сжатой" модификации.  Для этого обратитесь к
    структурам памяти cheap("сжатая куча"), chash("сжатая хэш") и
    cisam("сжатая  индексно-последовательная").  Сжатие уменьшает
    размер области,  необходимой  для  внутреннего  представления
    каждого кортежа.  Существующий алгоритм сжатия - это подавле-
    ние хвостовых пробелов в символьных  доменах.   Использование
    сжатия не требует дополнительного пространства, экономит дис-
    ковое пространство и улучшает применение.  Приведем пример:

    modify donation to cisam on name where
           fillfactor = 100

    С помощью этого запроса отношение donation  модифицируется  в
    структуру "сжатая isam" с требованием заполнения страниц нас-
    только, насколько это возможно.  При сжатии каждый кортеж мо-
    жет иметь различную длину.  Так число кортежей, которые могут
    быть расположены на одной странице будет  зависеть  от  того,
    насколько  успешно они были сжаты.  Для обновления сжатых от-
    ношений могут потребоваться большие  расходы.   В  частности,
    если  происходит замена содержимого одного или более доменов,
    и сжатый кортеж не длиннее прежней длины, то РУБИН должен ис-
    кать новое  место для размещения кортежа.


    ДВЕ ВАРИАЦИИ НА ТЕМУ

    Как было замечено, дублирующиеся кортежи  не  уничтожаются  в
    отношениях,  у  которых  структура  - куча.  Часто желательно
    удалять повторения  и  сортировать  отношение,  хранимое  как
    куча.   Один  путь, реализующий это - модификация отношения в
    структуру isam, с определением желаемого порядка  сортировки.
    Альтернативой  этому  является  использование  "heapsort" или
    "cheapsort".  Например:

    modify donation to heapsort on name, ext




СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 17








    Такая команда обеспечивает сортировку  отношения  сначала  по
    домену name, затем по домену ext.  Дальнейшая сортировка кор-
    тежей происходит по оставшимся доменам, в порядке их указания
    в  операторе  create.   Так, в данном случае, отношение будет
    сортироваться по значению домена  name,  затем  ext  и  затем
    amount.   Дублирующиеся  кортежи всегда удаляются.  Отношение
    было получено из структуры куча.  Heapsort и cheapsort  полу-
    чаются  сортировкой  временного отношения перед его печатью и
    уничтожением.  Это еще более эффективно, чем  структура  isam
    потому,  что  вместе  с такой структурой РУБИН создает "ката-
    лог", содержащий ключевую информацию о каждой странице.   От-
    ношение  НЕ сохраняет порядок сортировки при дальнейших изме-
    нениях.

    Пример:

    Здесь приводится набор примеров и пояснений,  как  эффективно
    использовать  каждый запрос.  Запросы основываются на отноше-
    ниях: parts(pnum, pname, color, weight, qoh)
    supply(snum, pnum, jnum, shipdate, quan)

    range of p is parts
    range of s is supply

    modify parts to hash on pnum
    modify supply to hash on snum,jnum

         retrieve (p.all) where p.pnum = 10

    РУБИН будет распознавать, что отношение parts является  хэши-
    рованным  по  домену pnum, и обращаться точно к той странице,
    где хранится часть с номером 10.

         retrieve (p.all) where p.pname = "tape drive"

    РУБИН будет читать все отношение, разыскивая подходящие имена
    pnames.

         retrieve (p.all) where p.pnum < 10  and p.pnum > 5

    РУБИН будет читать все отношение, потому что не задано точное
    значение pnum.

         retrieve (s.shipdate) where s.snum = 471  and  s.jnum  =
    1008

    РУБИН будет распознавать, что отношение  supply  хэшированное
    по  комбинации  доменов  snum  и jnum, и переходить на верную
    страницу.

         retrieve (s.shipdate) where s.snum = 471

    РУБИН будет читать все отношение.  supply хэшировано по доме-
    нам snum и jnum.  Бесполезно задавать РУБИН уникальные значе-



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 18








    ния обоих доменов, это не имеет преимуществ при  использован-
    ной структуре памяти.  , что не задано точное значение pnum.

         retrieve (s.shipdate) where s.snum = 471  and  s.jnum  =
    1008

    РУБИН будет распознавать, что отношение  supply  хэшированное
    по  комбинации  доменов  snum  и jnum, и переходить на верную
    страницу.

         retrieve (s.shipdate) where s.snum = 471

    РУБИН будет читать указанное отношение.  supply хэшировано по
    доменам  snum и jnum.  Если не задано уникальное значение од-
    ного из  ключевых  доменов,  то  невозмаожно  воспользоваться
    преимуществами использованной структуры памяти.

         retrieve (s.shipdate) where s.snum = 471  and  s.jnum  =
    1008

    РУБИН будет распознавать, что отношение  supply  хэшированное
    по  комбинации  доменов  snum  и jnum, и переходить на верную
    страницу.

         retrieve (p.pname, s.shipdate) where
         p.pnum = s.pnum and s.snum = 471 and s.jnum = 1008

    РУБИН будет использовать преимущества обеих структур  памяти.
    Сначала она найдет все домены s.pnum и s.shipdate, где s.snum
    = 471 и s.jnum = 1008.  Потом будет просматривать все  домены
    p.pname,  такие где p.pnum принимает значения, заданные усло-
    вием.

    Этот пример иллюстрирует ту идею, что часто мысль  хэшировать
    отношение  по  доменам является удачной, когда нужно "объеди-
    нять" его с другим  отношением.   Например,  в  таком  случае
    обычно спрашивают: for p.pnum = s.pnum

    Подведем итог:

    Для использования  преимущества  хэш-структуры  РУБИН  должен
    иметь  точное  значение для каждого ключевого домена.  Точное
    значение всегда подобно:

         s.snum = 471
         s.pnum = p.pnum

    А не:

         s.snum >= 471
         (s.snum = 10 or s.snum = 20)

    Теперь  давайте  рассмотрим  некоторые  случаи  использования
    структуры isam



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 19








         modify supply to isam on snum,shipdate
         retrieve (s.all) where s.snum = 471
         and s.shipdate > "75-12-31"
         and s.shipdate < "77-01-01"

    Если supply сначала отсортировывается по домену snum, а затем
    по домену shipdate, РУБИН может воспользоваться всеми преиму-
    ществами структуры isam для размещения частей отношения  sup-
    ply, которые удовлетворяют запросу.

         retrieve (s.all) where s.snum = 47l

    в отличие от хэш-структуры, структура isam  остается  удобной
    для использования тогда, когда задан только один ключ.

         retrieve (s.all) where s.snum > 400 and s.snum < 500

    Снова РУБИН будет использовать преимущества структуры.

         retrieve (s.all) where s.shipdate >= "75-12-31" and
         s.shipdate <= "77-01-01"

    Здесь РУБИН будет читать полностью заданное  отношение.   Это
    потому, что первый ключ (snum) не задан в запросе.

    Подведем итог:

    isam может обеспечивать улучшение доступа как при точных зна-
    чениях,  так и на значениях, заданных неравенствами.  Это по-
    лезно, по крайней мере, до тех пор, пока указан первый ключ.

    Для распределения кортежей в отношении структуры  isam  РУБИН
    ищет  справочник isam для отношения.  Когда отношение модифи-
    цируется в структуру isam,  кортежи  сначала  сортируются,  и
    дублирующиеся кортежи удаляются.  Затем отношение заполняется
    (в соответствии со значением fillfactor), начиная со страниц
     0, 1, 2... и т.д. пока есть в них необходимость.

    Сейчас такой справочник построен.  Ключевой домен от  первого
    кортежа  на  каждой  странице  выбран  и помещен в справочник
    (хранится в отношении на диске).  Справочник не меняется пока
    не произойдет следующая модификация.

    Всякий раз, когда кортеж добавляется к отношению,  справочник
    просматривается для поиска страницы, которой предназначен но-
    вый кортеж.  На этой странице кортежи перестают сохранять по-
    рядок  сортировки.  Остается что-то "приблизительно" отсорти-
    рованное.


    HEAP v. HASH v. ISAM

    Давайте сравним относительные преимущества и недостатки  каж-
    дой  структуры.   Отношение всегда создается как куча (heap).



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 20








    Куча является наиболее эффективной  структурой  для  первона-
    чального  заполнения  отношения, с использованием команд copy
    или append.

    Свободное место от удаленных кортежей в куче будет заново ис-
    пользоваться  только на следующей странице.  Проверка наличия
    дублирующихся кортежей не происходит  в  отношении  структуры
    heap.

    Хэш-структура наиболее удобна для размещения кортежей выбира-
    емых  по точным значениям квалификаторов.  Первичные страницы
    для кортежей с указанным значением могут быть  легко  подсчи-
    таны.

    Структура isam удобна и для точных значений и  для  диапазона
    значений.   Но  при  такой  структуре  должен просматриваться
    справочник, что не так эффективно, как при хэш-структуре.


    СТРАНИЦЫ ПЕРЕПОЛНЕНИЯ

    Когда вставляется новый кортеж в отношение,  а  на  первичной
    странице нет для него места, то создается страница переполне-
    ния.  Если больше кортежей подлежит втавке  в  отношение,  то
    страницы  переполнения  добавляются  по  мере  необходимости.
    Страницы переполнения, если необходимо,  ускоряют  выполнения
    выборок и измения отношений.

    Например, давайте предположим, что supply хэшировано  по  до-
    мену  snum  и  имеет  10 первичных страниц.  Предположим, что
    значение snum = 3 расположено на странице 7.  Для поиска всех
    snum  = 3 требуется, чтобы РУБИН просмотрел 7 первичную стра-
    ницу и все ее страницы переполнения (если  они  есть).   Если
    добавлено  много  страниц переполнения, то время, необходимое
    для поиска snum = 3 возрастает.  Так как удаляются  дублирую-
    щиеся  кортежи  в  структурах  isam и hash, этот поиск должен
    применяться и при добавлении, и при замене кортежей.

    Когда у отношения, структурированного как hash или isam, есть
    много  страниц  переполнения,  оно должно быть модифицировано
    заново в hash или isam.  Это будет очищать отношение и ликви-
    дировать как можно большее число страниц переполнения.


    УНИКАЛЬНЫЕ КЛЮЧИ

    Когда выбираются ключевые домены  для  отношения,  желательно
    иметь каждое множество ключевых доменов уникальным, насколько
    это возможно.  Например,  служащий  характеризуется  несколь-
    кими,  обычно неповторяющимися значениями, т.к. что-то, похо-
    жее на цвет, имеет только  несколько  различных  значений,  а
    что-то,  похожее на пол, имеет, как мы знаем, только два зна-
    чения.




СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 21








    Если отношение хэшировано по домену sex, то  вы  можете  ожи-
    дать,  что  все  мужчины  будут  размещены на одной первичной
    странице и всех ее страницах переполнения, и аналогичная  си-
    туация произойдет для всех женщин.  Для хэшированного отноше-
    ния нет решения этой проблемы.   Обмен  должен  производиться
    между  наиболее желательными ключевыми доменами для использо-
    вания в квалификации, противоположной  уникальности  ключевых
    значений.

    Однако, структура isam может быть использована, если  пропус-
    кается  первый  указанный  ключ,  а выбранные ключевые домены
    иногда добавляются для  увеличения  уникальности.   Например,
    предположим,  что отношение supply имеет только 10 уникальных
    номеров поставщиков, но в тысячах кортежей.  Выбор  структуры
    isam  с  ключами  snum  и  jnum будет, вероятно, давать много
    больше уникальных ключей.  Однако, размер  справочника  будет
    больше  и,  следовательно,  будет  возрастать время его прос-
    мотра.  Когда указываются дополнительные  ключи  только  ради
    увеличения  уникальности,  пытайтесь  использовать по возмож-
    ности наименьшее число доменов.


    СИСТЕМНЫЕ ОТНОШЕНИЯ

    РУБИН использует три  отношения  ("relation",  "attribute"  и
    "indexes")  для поддержки организации базы данных.  Отношение
    "relation" содержит один кортеж для каждого отношения в  базе
    данных.   Отношение "attribute" содержит один кортеж для каж-
    дого атрибута в каждом отношении.  Отношение "indexes" содер-
    жит один кортеж для каждого вторичного индекса.

    Доступ РУБИН к этим отношениям осуществляется в очень удобной
    форме.   Программа, называемая "sysmod", будет использоваться
    для модификации этих отношений в хэш-структуру по  соответст-
    вующим  доменам.  Для использования sysmod администратор базы
    данных должен печатать:

    % sysmod data-base-name

    sysmod первоначально запускается после того, как база  данных
    создана,  и затем, когда созданы отношения и база данных рас-
    тет.  Недостаточно запустить sysmod один раз и забыть о  нем.
    Перезапуск  sysmod  должен  происходить тогда,когда системные
    отношения будут модифицироваться заново.  Это обычно происхо-
    дит  для удаления большинства страниц переполнения и уменьше-
    ния времени ответа системы.











СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 22









5.  ВТОРИЧНАЯ ИНДЕКСАЦИЯ




    При использовании структур hash и isam обеспечивается быстрый
    путь для поиска кортежей в отношении по данным значениям клю-
    чевых доменов.  Иногда этого недостаточно.  Например, предпо-
    ложим, что у нас есть отношение donation

         donation(name, amount, ext)

    хэшированное по домену name.  Это будет обеспечивать  ускоре-
    ние  доступа  при  запросе,  когда квалификация не определяет
    точного значения домена name.  Что, если мы также будем пода-
    вать запросы с заданными точными значениями домена ext?

    donation может быть хэшировано как по name, так и по ext, так
    что мы будем иметь выбор, который из них более общий, и хэши-
    ровать отношение по этому домену.  Другой домен (скажем  ext)
    будет иметь вторичный индекс.  Вторичный индекс - это отноше-
    ние, которое содержит каждый домен "ext" вместе с точным мес-
    тоположением кортежа в отношении donation.

    Вот как выглядит команда создания вторичного индекса:

         index on donation is donext (ext)

    Общим форматом будет:

         index on relation_name is secondary_index_name (domains)

    Здесь мы запрашиваем РУБИН на создание вторичного индекса  на
    отношении  donation.   Домен, который будет индексироваться -
    это "ext".  Индексы формируются за три шага:

   1.  "Donext" создается как структура куча.
   2.  Для каждого кортежа  в  donation,  кортеж,  вставляется  в
        "donext",  со  значением ext и точным расположением соот-
        ветствующего кортежа в отношении donation.
   3. По умолчанию, "donext" модифицируется в isam.

    Сейчас, если вы запустите запрос:

         range of d is donation
         retrieve(d.amount) where d.ext = 207

    РУБИН сначала будет автоматически искать  в  "donext"  первое
    вхождение ext = 207.  Когда он его найдет, он обратится прямо
    к кортежу в отношении donation.  Т.к. "donext"  имеет  струк-
    туру  isam  по  домену ext, поиск ext = 207 будет происходить
    быстро.




СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 23








    Если вы запустите запрос

     retrieve(d.amount) where d.name = "frank"

    то РУБИН будет продолжать использовать хэш-структуру  отноше-
    ния "donation" для размещения указанных кортежей.

    Т.к. вторичные индексы представляют собой отношения, они тоже
    могут  иметь  структуры  как  hash,  isam, chash так и cisam.
    Нельзя  почуствовать  наличие  вторичного  индекса,  имеющего
    структуру куча.

    Решение, как какую структуру для них выбирать  для  включения
    тех же предложений, которые обсуждались выше:

    Можно ли будет ссылаться на домены указанием его точного зна-
    чения?
    Можно ли будет ссылаться на них указанием диапазона значений?
    и т.д.

    В этом случае на домен "ext" можно будет ссылаться  указанием
    его  точного  значения,  и т.к. отношение почти заполнено, мы
    будем делать:

         modify donext to hash on ext where fillfactor = 100
         and minpages = 1

    Вторичные индексы обеспечивают возможность РУБИН для  доступа
    к  кортежам, основанного на доменах, не являющихся ключевыми.
    Отношение может иметь все номера вторичных индексов и  вдоба-
    вок каждый вторичный индекс может быть индексом на свыше, чем
    6 доменах первичного отношения.

    Когда кортеж заменяется, удаляется или добавляется к  первич-
    ному отношению, вторичный индекс также соответственно изменя-
    ется.  Таким образом, вторичный индекс не  является  "свобод-
    ным".   Это увеличивает затраты на изменение первичного отно-
    шения, но может уменьшать затраты на поиски кортежа в первич-
    ном отношении.

    Будет ли  вторичный  индекс  улучшать  использование  или  не
    строго  зависеть от уникальности значений индексированных до-
    менов.  Первая забота это: будет ли просмотр  вторичного  ин-
    декса  более эффективным, чем простое чтение первичного отно-
    шения.  В сущности это важно, если  число  кортежей,  которые
    удовлетворяют  квалификации,  меньше, чем общее число страниц
    (как первичных, так и страниц переполнения) в первичном отно-
    шении

    Например, если нам часто бывает желательно найти всех  людей,
    которые  внесли вклад меньше, чем 5 долларов, рассмотрим соз-
    дание вторичного индекса

         index on donation is donamount (amount)



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 24








    По умолчанию donamount будет иметь структуру isam по  amount.
    Если РУБИН выполняет запрос:

         retrieve(d.name) where d.amount < 5.0

    он будет располагать d.amount < 5.0 во вторичный индекс и для
    каждого кортежа, который он находит, будет  создаваться двой-
    ник соответстующего кортежа в отношении donation.  Кортежи  в
    donamount  сортируются по amount, а кортежи в отношении dona-
    tion нет.  Так в общем случае, каждый кортеж-двойник из dona-
    tion,  в  отличие от donamount будет на другой странице.  Вы-
    борка с использованием вторичного индекса, тем  самым,  может
    читать  больше  страниц,  чем простое последовательное чтение
    всего отношения donation!  Таким образом,  в  данном  примере
    это была неверная идея воспользоваться вторичным индексом.










































СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 25









6.  ВОССТАНОВЛЕНИЕ И ИЗМЕНЕНИЕ ДАННЫХ




    РУБИН имеет удачные структурные решения, направленные на  за-
    щиту  целостности  базы данных от различных классов системных
    ошибок.  Чтобы это проделать, РУБИН выполняет обращение к от-
    ношению,  которые  мы  называем "отложенные изменения" ("dif-
    fered update") или "обновление пакетного файла" ("batch  file
    update").   Вдобавок существуют две программы РУБИН "restore"
    и "purge", которые могут быть использованы для проверки  базы
    данных после системного сбоя.  Сначала мы будем обсуждать как
    создаются и выполняются отложенные изменения, а потом уже ис-
    пользование команд "purge" и "restore".

    ОТЛОЖЕННЫЕ ИЗМЕНЕНИЯ (пакетное обновление)

   Команды append, replace или delete запускаются в четыре шага:

   1.  Создается пустой файл отложенных изменений.
   2.  Команда запускается до завершения, и каждое полученное ре-
        зультирующее отношение записывается в файл отложенных из-
        менений.
   3.  Читается файл отложенных изменений, и исходное отношение и
        его вторичные индексы (если есть) соответствующим образом
        изменяются.
   4.  Файл отложенных изменений удаляется и РУБИН возвращается к
        обслуживанию пользователя.

    Отложенные изменения дают отсрочку выполнению текущих измене-
    ний  до окончания выполнения запроса.  Существуют три преиму-
    щества для такого выполнения.

    l.  Обеспечение восстановления после системных сбоев.

    Если во время изменения  произошел  крах  системы,  программа
    восстановления будет решать: запускать ли изменения полностью
    или, иначе, возвратиться к первоначальному содержимому  отно-
    шения, которое было перед запуском изменений.

    2. запрещение бесконечных запросов.

    Если отношение "donation" имеет структуру куча и запрос:

        range of d is donation
        append to donation(d.all)

    будет запущен без отложенных изменений,  он  будет  прекращен
    только  когда  ему  не хватит свободного места на диске!  Это
    произойдет потому, что РУБИН будет начинать чтение  отношения
    сначала  и добавлять каждый кортеж в конец.  Вскоре он начнет
    читать кортежи, которые уже встречались и такая работа  будет



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 26








    продолжаться до бесконечности "в погоне за хвостом".

    На самом деле такой запрос не типичен, приведен он просто для
    иллюстрации.   Сущетствуют разнообразные классы запросов, где
    проблема заключается в том, что точно не ясно, КОГДА произво-
    дить  необходимые  текущие изменения.  При отложенных измене-
    ниях мы можем гарантировать содержательный и логичный резуль-
    тат.

    3.  Ускорение выполнения вторичных индексов

    Вторичные индексы могут обновляться быстрее, если они обраба-
    тываются  по одному, вместо всех за раз.  Это также обеспечи-
    вает защиту от вторичных индексов, ставших бессодержательными
    относительно своих первичных отношений.

    ОТКЛЮЧЕНИЕ ОТЛОЖЕННЫХ ИЗМЕНЕНИЙ

    Если вас не убедили все эти аргументы,  РУБИН  позволяет  вам
    отключить  отложенные  изменения!   В  самом деле, существуют
    различные случаи, где это бывает удобно (хотя, конечно, несу-
    щественно) производить изменения сразу же, т.е. отношение из-
    меняется в процессе выполнения запроса.

    Чтобы использовать такие направленные  изменения,  вы  должны
    иметь разрешения, данные вам суперпользователем РУБИН.  Тогда
    при вызове РУБИН надо указать ключ "-, который  отключает  па-
    кетные изменения.

        % ingres mydate -b

    РУБИН будет использовать направленные изменения на всех отно-
    шениях,  кроме  вторичных индексов.  Он все равно будет молча
    использовать отложенные изменения, если дело касается отноше-
    ний, имеющих вторичные индексы.  При использовании ключа "-b"
    вы приносите в жертву пунты 1 и 2, указанные выше.   В  боль-
    шинстве случаев вы НЕ МОЖЕТЕ использовать ключ -b.

    Если вы используете РУБИН для интерактивного ввода или  изме-
    нения одного кортежа в один момент времени, то отключение от-
    ложенных изменений здесь  не  прибавляют  особенно  эффектив-
    ности.  Если сбой системы произошел во время производившегося
    изменения, то пользователь, вводящий данные, будет осознавать
    ситуацию и сможет проверить, был ли изменен кортеж или нет.

    ВОССТАНОВЛЕНИЕ

    РУБИН имеет средства для восстановления данных после типичных
    сбоев  системы,  которые  свойственны файловой системе ДЕМОС.
    Имеется возможность восстановления   после  команд  изменния,
    создания, удаления, модификации и индексирования.

    РУБИН предназначен для хранения данных ("fail  safe").   Eсли
    обнаруживаются  некоторые несовместимости или некоторые сбои,



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 27








    поступающие от ДЕМОС, РУБИН будет  генерировать  сообщение  о
    системной ошибке (SYSERR) и оканчивать работу.

    Всякий раз, когда происходит сбой ДЕМОС при работе РУБИН, или
    всегда,  когда РУБИН встречает системную ошибку, самая лучшая
    идея в таком случае, чтобы администратор базы данных запустил
    команду

         % restore data_base_name

    Программа восстановления проделывает следующее:

   1.  Просматривает файлы отложенных изменений.   Если  все  они
        найдены,  она проверяет целостность каждого из них.  Если
        системный сбой произошел пока файл  отложенных  изменений
        читался,  а база данных изменялась, то восстановление бу-
        дет завершать изменение.  С другой стороны,файл  отложен-
        ных  изменений  может  быть с нарушенной целостностью или
        просто разрушенным; тогда эффект от восстановления  будет
        таким, как-будто запрос вовсе не был запущен.

   2.  Проверяет незаконченность команд  модификации.   Этот  шаг
        является  решающим.   Он гарантирует, что вы будете иметь
        отношение в том виде, в каком оно  было  до  модификации,
        или  оно будет результатом  полной работы команды modify.
        Работа команды modify заключается в  том,  что  создается
        отношение  с другой структурой. Затем, когда она готова к
        замене старого отношения, она загружает новую  информацию
        в файл отложенных изменений команды modify ("modify batch
        file").  И это дает возможность  процессу  восстановления
        определить состояние невыполненной команды modify.

   3.  Проверка состояния системных  отношений.   Такая  проверка
        используется  для  завершения команд "destory", остановки
        команд "create" и для  остановки  или  завершения  команд
        "index", которые были прерваны при сбое системы.

   4.  Чистка временных отношений и файлов.  Программа восстанов-
        ления  выполняет  программу "purge", которая удаляет вре-
        менные файлы, созданные  системой.   purge  будет  обсуж-
        даться в деталях чуть позже.

    restore не может сообщать пользователю,  какие  запросы  были
    запущены,  а какие нет.  Она может только идентифицировать те
    запросы, которые были в процессе  выполнения  во  время  сбоя
    системы.   Когда  запускается  поток запросов вместе, хорошей
    идеей является сохранить вывод в файле.  При наличии монитор-
    ной выдачи запроса или множества запросов, пользователь может
    позднее определить, какой запрос был запущен.

    restore имеет различные опции, которые улучшают его использо-
    вание.  Они определяются указанием ключей.  Опиции включают:

    -a       запрашивать подтверждение



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 28








             на выполнение
    -f       для purge. Используется для удаления
             временных файлов.
    -p       для purge. Используется для удаления
             отношений, у которых истек срок
             хранения.
    no database
             восстановить все базы данных, для
             которых вы администратор

    Из этих опций наиболее важная "-a".   При  сбое  ДЕМОС  может
    произойти ситуация, при которой становится некорректной стра-
    ница системного отношения.  Это может стать причиной разруше-
    ния  отношения.   Фактически,  вы можете "залатать" системное
    отношение  для исправления  ситуации.   Нет  такой  программы
    восстановления, при которой решались бы все проблемы.  Следо-
    вательно, замену разуму придумать трудно.

    Если указан ключ "-a", restore будет сообщать о том, что  она
    сейчас  хочет  делать и запрашивать подтверждение на выполне-
    ние.  Она читает стандартный ввод и, получив  "y",  выполняет
    действие,  при  любом другом символе не выполняет.  Например,
    для того, чтобы restore спрашивал вас перед выполнением  вся-
    кого действия:

         restore -a mydatabase

    Для того, что бы получать "no" на все вопросы можно дать  ко-
    манду:

         restore -a mydatabase </dev/null

    Используя ключ -a, restore сможет спрашивать  разрешение  для
    выполнения  некоторых чисток; например, если она найдет атри-
    бут, для которого нет соответствующего отношения, или вторич-
    ный индекс, для которого нет первичного отношения и т.д.

    Нет таких сбоев системы, после которых РУБИН не смог бы восс-
    тановить  данные.  Это не означает, что они не будут происхо-
    дить, но вы не должны особенно беспокоиться.  Имейте в  виду,
    что  восстановление  не  является  заменой для периодического
    возврата, и не применяется как функция.

    ЧИСТКА (PURGE)

    purge может использоваться для сообщения об отношениях, у ко-
    торых истек срок хранения, разрушения временных системных от-
    ношений, удаления посторонних файлов и удаления отношений,  у
    которых  истек  срок  хранения.   Для  использования purge вы
    должны быть DBA для данной базы данных.

         % purge mydatabase

    У команды purge имеется несколько опций, которые определяются



СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 29








    путем указания флагов:

    -f   (по умолчанию отключен) удалять все
          посторонние файлы
          О каждом файле сообщать, затем
          удалять. Если ключ "-f" не
          указан, то о таких файлах
          будет только сообщаться.

    -p   (по умолчанию отключен) разрушать все
          отношения, у которых истек срок
          хранения. О каждом таком файле
          сообщать, и если ключ "-p" был указан,
          то удалять.

    purge всегда удаляет отношения и файлы, которые являются вре-
    менными файлами РУБИН.  При выполнении мульти-переменных зап-
    росов и запросов с агрегатными функциями, РУБИН обычно  будет
    создавать  временные отношения с промежуточными результатами.
    Такие отношения всегда начинаются с символов "_SYS".   Другие
    команды  РУБИН создают временные файлы, которые также начина-
    ются с "_SYS".  При нормальном выполнении они всегда  уничто-
    жаются.   При системном сбое они могут остаться.  Тогда purge
    обязательно очистит  временные  системные  файлы.   Отношения
    пользователя  он удаляет только в том случае, если его специ-
    ально об этом попросят.































СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД РУБИН                     Стр. 30


