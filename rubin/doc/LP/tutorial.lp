






           000000   0     0  0000000  0     0  0     0
           0     0  0     0  0        0     0  0     0
           0     0  0     0  0        0   0 0  0     0
           000000    000000  000000   0  0  0  0000000
           0              0  0     0  0 0   0  0     0
           0              0  0     0  0     0  0     0
           0        000000   000000   0     0  0     0






         СС ИИ СС ТТ ЕЕ ММ АА   УУ ПП РР АА ВВ ЛЛ ЕЕ НН ИИ ЯЯ   ББ АА ЗЗ ОО ЙЙ
                     ДД АА НН НН ЫЫ ХХ   РР УУ ББ ИИ НН


                            ВЕРСИЯ 2
              У Ч Е Б Н О Е   В В Е Д Е Н И Е    В
                       С У Б Д   Р У Б И Н























                         ММоосскквваа 77//2244//8899






















                    Учебное введение в РУБИН





Это пособие описывает использование системы управления базой дан-
ных  РУБИН.   Вы  должны  иметь возможность выполнять приведенные
здесь примеры и наблюдать те же самые результаты.

Язык манипуляции данными, предоставляемый РУБИН, называется  QUEL
(QUEry Language - язык запросов).  Полную информацию по QUEL и по
РУБИН можно найти в  "Справочном  руководстве  по  РУБИН".   Этот
учебник не имеет своей целью охватить все детали РУБИН.

Начнем с входа в ДЕМОС - систему разделения времени, под управле-
нием  которой  работает  РУБИН. Если это возможно, то используйте
терминал со строчными и прописными буквами,  в  противном  случае
вам  будет довольно тяжело.  Если вы все-таки будете использовать
терминал только с прописными буквами, набирайте "\\" везде, где в
тексте встречается "\".

На вашем терминале сейчас должно быть напечатано приглашение сис-
темы.  Чтобы начать работать с РУБИН, наберите команду:

% rubin demo

Эта команда означает, что нужно запустить РУБИН с  использованием
базы данных под именем "demo".  После нескольких секунд на терми-
нале появится текст:

СУБД РУБИН
Пят ноя 14 16:27:53 1988

Версия для 16/32 битных машин

Ready
*

В первых трех строчках указан номер версии РУБИН (в данном случае
май  1986)  и  текущая дата. Дальше следует т.н. "dayfile" - файл
ежедневных сообщений, в котором находятся сообщения,  относящиеся
к системе РУБИН.  "Ready" показывает, что РУБИН готова к работе с
вами.

Монитор РУБИН печатает звездочку ("*") в  начале  каждой  строки,
как напоминание о том,что РУБИН ждет ваших команд.

Наберите команду:

* print части
* \g
Executing . . .



Учебное введение в РУБИН                                   Стр. 2









Строчка "print части" запрашивает  распечатку  некоторых  данных,
хранящихся  в базе данных. Команда "\g" означает "go".  Сообщение
"Executing . . ." показывает, что  РУБИН  выполняет  ваш  запрос.
Далее появляется следующее:

Отношение части


!номер !имя                 !цвет    !вес   !кол-во!
!--------------------------------------------------!
!     1!центр. процессор    !розовый !    10!     1!
!     2!память              !серый   !    20!    32!
!     3!дисковод            !черный  !   685!     2!
!     4!контроллер лент     !черный  !   450!     4!
!     5!магнитофон          !серый   !     1!   250!
!     6!печатающее у-во     !желтый  !   578!     3!
!     7!бумага АЦПУ         !белый   !    15!    95!
!     8!терминалы           !голубой !    19!    15!
!    13!счит. с перфолент   !черный  !   107!     0!
!    14!ленточный перфоратор!черный  !   147!     0!
!     9!терминальная бумага !белый   !     2!   350!
!    10!байтовое мыло       !прозрач.!     0!   143!
!    11!счит. с перфокарт   !серый   !   327!     0!
!    12!карточный перфоратор!серый   !   427!     0!
!--------------------------------------------------!

Continue *

На вашем терминале распечаталось "отношение части".   Интуитивно,
отношение - это не что иное, как таблица из строчек и столбцов.

В данном случае отношение называется "части".  В нем пять  столб-
цов  (будем  называть  их  доменами),  озаглавленных  номер(номер
части), имя(имя части), цвет, вес и  кол-во(количество).   Каждая
строчка  отношения  (называется  кортеж) это один вход в таблице,
который представляет  собой  часть  оборудования  вычислительного
центра.  В отношении может быть до 49 доменов и практически неог-
раниченное число кортежей.

Обратите внимание, что после того, как запрос выполнен, РУБИН пе-
чатает  "Continue",  тогда  как  в  начале работы РУБИН напечатал
"Ready".  Когда вы вводите запрос, РУБИН  сохраняет  то,  что  вы
набрали в "рабочей области". Если вы ошиблись в своем запросе, то
напечатав "\r" вы "сбросите" (т.е. очистите) свою рабочую область
(позже  мы  покажем,  как  редактировать ошибки, не перепечатывая
весь запрос).

В любой момент вы можете посмотреть, что находится в вашей  рабо-
чей области, набрав "\p".  Давайте сделаем это:

* \p
print части
Continue



Учебное введение в РУБИН                                   Стр. 3









*

Распечатывается текущее содержание рабочей области. Теперь  напе-
чатаем "\r":

* \r
Ready
*

Теперь рабочая область пуста.  Маленькое правило: когда РУБИН пе-
чатает  "Continue", то рабочая область не пуста, когда же она пе-
чатает "Ready" - рабочая область пуста.

После выполнения запроса РУБИН обычно печатает "Continue".   Если
вы наберете новый запрос, РУБИН сотрет предыдущий, так что вам не
нужно печатать "\r" после каждого запроса.  Мы объясним  все  это
немного позже.

Используя команду "retrieve" (выдать), мы  можем  составлять  де-
тальные запросы об отношениях.  В качестве примера давайте заста-
вим РУБИН печатать только домен имя  отношения  части.   Наберите
команду:

* range of p is части
* retrieve (p.имя )
* \g
Executing . . .


!имя                 !
!--------------------!
!центр. процессор    !
!память              !
!дисковод            !
!контроллер лент     !
!магнитофон          !
!печатающее у-во     !
!бумага АЦПУ         !
!терминалы           !
!счит. с перфолент   !
!ленточный перфоратор!
!терминальная бумага !
!байтовое мыло       !
!счит. с перфокарт   !
!карточный перфоратор!
!--------------------!

Continue *

Мы получили только домен имя из отношения части.  Для  этого  нам
потребовалось  сделать две вещи.  Сначала мы объявили то, что на-
зывается "кортеж-переменной" и предписали ей действовать на отно-
шении части.



Учебное введение в РУБИН                                   Стр. 4









range of p is части

Это значит, что буква p представляет отношение части.   Ее  можно
можно  считать  указателем,  который движется по отношению части,
показывая, с каким именно элементом мы  сейчас  работаем.   РУБИН
запоминает это соответствие так, что если p объявляется действую-
щей на части, нам не нужно  будет  повторять  объявление  области
действия в дальнейшем.  Это полезно, когда мы работаем более, чем
с одним отношением.  Такой пример мы приведем немного позднее.

Далее мы использовали команду retrieve.  Она имеет следующий вид:

retrieve ( перечислите здесь то, что вы хотите получить )

"p" сама по  себе  обозначает  (ссылается)  на  отношение  части.
"p.имя   "  ссылается  на домен имя в этом отношении, так что ко-
манда

retrieve (p.имя  )

обозначает: получить домен имя   отношения части.

Теперь попробуем получить имя и цвет :

* retrieve p.имя  , p.цвет
* \g
Executing . . .

2500: Синтаксическая ошибка в строке 1. Последний прочитанный символ: .

Continue
*

К сожалению, мы сделали ошибку.  РУБИН сообщает,  что  она  нашла
синтаксическую ошибку в 1 строке запроса.  Такое мсообщение озна-
чает, что мы набрали что-то,что РУБИН  не  может  разобрать.  Эта
ошибка  была найдена в строчке 1. РУБИН делает иногда полезные, а
иногда и не очень, попытки распознать ошибку. Если это  возможно,
РУБИН сообщает нам последнее, что она прочла перед тем, как испы-
тать затруднение.

В данном случае ошибкой является отсутствие скобок вокруг  списка
того,  что  мы хотим получить.  (Это называется целевым списком).
Правильным запросом будет :

* retrieve (p.имя, p.цвет)
* \g
Executing . . .


!имя                 !цвет    !
!-----------------------------!
!центр. процессор    !розовый !



Учебное введение в РУБИН                                   Стр. 5









!память              !серый   !
!дисководve          !черный  !
!контроллер лент     !черный  !
!магнитофон          !серый   !
!печатающее у-во     !желтый  !
!бумага АЦПУ         !белый   !
!терминалы           !голубой !
!счит. с перфолент   !черный  !
!ленточный перфоратор!черный  !
!терминальная бумага !белый   !
!байтовое мыло       !прозрач.!
!счит. с перфокарт   !серый   !
!карточный перфоратор!серый   !
!-----------------------------!

Continue *

Вы можете ограничить набор выдаваемых кортежей, добавив к запросу
"квалификации".  Например, чтобы получить имя и цвет только серых
частей допечатайте

* retrieve (p.имя, p.цвет)
* where p.цвет  = "серый"
* \g
Executing . . .


!имя                 !цвет    !
!-----------------------------!
!память              !серый   !
!магнитофон          !серый   !
!счит. с перфолент   !серый   !
!карточный перфоратор!серый   !
!-----------------------------!

Continue *

Обратите внимание,что РУБИН печатает только те части,  у  которых
p.цвет   -  серый Так же обратите внимание на то, что слово серый
должно быть в "". Это необходимо, т.к.  единственный  признак,  с
помощью  которого  РУБИН  различает символьные строчки (например,
слова), это наличие вокруг них кавычек.

А что, если нам нужны имена частей серого или  розового  цвета  ?
Для этого нам надо добавить к предыдущему запросу следующую фразу

or p.цвет  = "розовый"

Но при это помните, что если следующая вводимая строчка  начинает
новый  запрос,  РУБИН  автоматически  сбрасывает рабочую область.
Рабочая область будет сохранена, если  только  следующая  строчка
начинается  с  таких команд, как "\p" или "\g"( есть еще подобные
команды, о которых будет упомянуто ниже ).  Если напечатать такую



Учебное введение в РУБИН                                   Стр. 6









команду, предыдущий запрос будет сохранен, и все дальнейшее будет
присоединено к нему. Т.о., допечатав


* \_p
retrieve (p.имя, p.цвет)
where p.цвет  = "серый"
*

вы сможете посмотреть предыдущий запрос. Теперь напечатайте :

* or p.цвет  = "розовый"
*

РУБИН добавит эту строчку в конец запроса.  Вы  можете  проверить
это, распечатав рабочую область.

* \p
retrieve (p.имя  , p.цвет )
where p.цвет  = "серый"
or p.цвет  = "розовый"
*

Теперь запустите этот запрос :

* \g
Executing . . .


!имя                 !цвет    !
!-----------------------------!
!центр.процессор     !розовый !
!память              !серый   !
!магнитофон          !серый   !
!счит. с перфолент   !серый   !
!карточный перфоратор!серый   !
!-----------------------------!

Continue *

Может быть, правила о сбросе  рабочей  области  могут  показаться
вначале  очень сложными.  В общем, РУБИН делает именно то, что Вы
хотите, не заставляя Вас особенно задумываться над этим.

Мы использовали "квалификации" с "or" и "=".  Кроме этого,  можно
использовать :

        and
        or
        not
        =       (равно)
        !=      (не равно)
        >       (больше )



Учебное введение в РУБИН                                   Стр. 7









        >=      (больше или равно)
        <       (меньше)
        <=      (меньнше или равно)


Вычисление этих квалификаций производится в том порядке, в  кото-
ром Вы их печатаете (слева направо), для изменения порядка вычис-
лений используются скобки.

РУБИН может производить вычисления над данными, хранящимися в от-
ношении.   Например,  в  отношении части указаны количество и вес
для каждой части.  Мы хотим узнать общий вес для каждой части. Мы
хотим  узнать общий вес для каждой группы частей ( т.е. вес * ко-
личество ).

Чтобы получить имя, номер и общий вес для каждой части,  наберите
запрос :

* retrieve (p.имя, p.номер, p.колич * p.вес)
* \g
Executing . . .

2500: Синтаксическая ошибка в строке 1. Последний прочитанный символ: *.


Continue
*

Опять ошибка. Проблема состоит в том, что когда умножение  выпол-
нено,  РУБИН  не  знает,  как озаглавить домен в распечатке.  Для
простых доменов РУБИН использует в качестве заголовка имя домена.
Для  всеь  остальных,  вы  должны создать новый Заголовок домена,
указав:

        общ = p.колич * p.вес

Или в более общем виде:

        заголовок = выражение

Например:

        имя = p.имя
        вычисление = p.вес / 2000 * (p.колич + 2)

Исправим ошибку, перепечатав запрос.  Т.к.  первая  строка  после
запроса  не  начиналась с  "\p" или "\g" , то РУБИН автоматически
стирает рабочую область, удаляя предыдущий запрос.

* retrieve (p.имя, p.номер, общ =p.колич * p.вес)
* \g
Executing . . .




Учебное введение в РУБИН                                   Стр. 8









!имя                 !номер !общ   !
!----------------------------------!
!центр.процессор     !     1!    10!
!память              !     2!   640!
!дисковод            !     3!  1370!
!контроллер лент     !     4!  1800!
!магнитофон          !     5!   250!
!печатающее у-во     !     6!  1734!
!бумага АЦПУ         !     7!  1425!
!терминалы           !     8!   285!
!счит. с перфолент   !    13!     0!
!ленточный перфоратор!    14!     0!
!терминальная бумага !     9!   700!
!байтовое мыло       !    10!     0!
!счит. с перфокарт   !    11!     0!
!карточный перфоратор!    12!     0!
!----------------------------------!

Continue *

Кроме умножения РУБИН умеет делать

        +   сложение
        -   вычитание ( и смена знака )
        /   деление
        *   умножение
        **  возведение в степень ( например 3**10 )
        abs абсолютное значение
        mod  деление по модулю

и многое другое.  Краткое, но полное описание арифметических воз-
можностей  смотрите в справочном руководстве РУБИН.

Если мы хотим получить части с номерами от 2 до 10, то мы  должны
добавить квалификации:
        where p.номер = 2 or p.номер = 10
ПРЕДУПРЕЖДЕНИЕ: если мы начнем печатать "where p.номер.... "  РУ-
БИН  поймет это, как начало нового запроса, и очистит рабочую об-
ласть. Для предотвращения этого надо напечатать  сначала  "\p"  и
заставить  РУБИН распечатать рабочую область, или вы можете напе-
чатать "\a" (append-добавить).  Команда "append" гарантирует, что
все, что вы будете печатать, будет добавлено к тому, что уже есть
в рабочей области.  Эта команда особенно необходима после  выпол-
нения  запроса.  В других случаях добавление происходит автомати-
чески.  Попробуйте сделать следующее:

* \a
* where p.номер= 2 or p.номер= 10
* \g
Executing . . .


|имя                 |номер |общ   |



Учебное введение в РУБИН                                   Стр. 9









|----------------------------------|
|память              |     2|   640|
|байтовое мыло       |    10|     0|
|----------------------------------|

Continue *

Для получения всех частей, номера которых больше 2 и  меньше  или
равны 10:

* retrieve (p.имя, p.номер, общ =p.колич * p.вес)
* where p.номер> 2 and p.номер<= 10
* \g
Executing . . .


!имя                 !номер !общ   !
!----------------------------------!
!дисковод            !     3!  1370!
!контроллер лент     !     4!  1800!
!магнитофон          !     5!   250!
!печатающее у-во     !     6!  1734!
!бумага АЦПУ         !     7!  1425!
!терминалы           !     8!   285!
!терминальная бумага !     9!   700!
!байтовое мыло       !    10!     0!
!----------------------------------!

Continue *

Предположим, что мы хотим изменить предыдущий запрос для  получе-
ния  частей  с номерами от 5 до 10 вместо от 2 до 10.  Вам, веро-
ятно, уже наскучило  перепечатывать  весь  запрос  для  исменения
всего  одного  символа.  Поэтому РУБИН позволяет вам использовать
текстовый редактор ДЕМОС для внесения исправлений и/или  добавле-
ний  в вашу рабочую область.  Как только вы напечатаете "\e", мо-
нитор РУБИН запишет вашу рабочую область в файл и  вызовет  прог-
рамму  "red"  - экранный редактор текстов ДЕМОС.  (строго говоря,
это зависит от настройки макро в стартовом файле РУБИН, и вы  мо-
жете  изменить  имя редактора в своем стартовом файле, см. раздел
MACRO(QUEL) в справоном руководстве).  Например:

* \e
>>red

На экран выдастся рамка и изображение файла - буфера запросов РУ-
БИН.

Теперь вы можете редактировать запрос, изменять в  нем  2  на  5.
Начальные сведения об исользовании редактора "red" включены в до-
кументацию по ДЕМОС.

В запросе



Учебное введение в РУБИН                                  Стр. 10









  retrieve (p.имя, p.номер, общ = p.колич * p.вес)
  where p.номер> 2 and p.номер<= 10

заменим во второй строке 2 на 5:

  where p.номер> 5 and p.номер<= 10

и выйдем из редактора с записью изменений.

Continue
*

В редакторе вы можете использовать все его команды.

Когда вы выходите из редактора (команда "q"), монитор РУБИН печа-
тает "Continue", сообщая вам, что вы опять вернулись в РУБИН.

Для проверки правильности и выполнения запроса, печатайте:

* \p\g
retrieve (p.имя, p.номер, общ = p.колич * p.вес)
where p.номер> 5 and p.номер<= 10
Executing . . .


|имя                 |номер |общ   |
|----------------------------------|
|печатающее у-во     |     6|  1734|
|бумага АЦПУ         |     7|  1425|
|терминалы           |     8|   285|
|терминальная бумага |     9|   700|
|байтовое мыло       |    10|     0|
|----------------------------------|

Continue *


Исчерпав  интересующие  нас  запросы,  связанные   с   отношением
"части",  давайте  теперь перейдем к рассмотрению другого отноше-
ния, называемого "поставки".  Печатайте:

* print поставки
* \g
Executing . . .


Отношение поставки

|nпост |nчасти|nакта |дата_пос|размер|
|------------------------------------|
|   475|     1|  1001|73-12-31|     1|
|   475|     2|  1002|74-05-31|    32|
|   475|     3|  1001|73-12-31|     2|



Учебное введение в РУБИН                                  Стр. 11









|   475|     4|  1002|74-05-31|     1|
|   122|     7|  1003|75-02-01|   144|
|   122|     7|  1004|75-02-01|    48|
|   122|     9|  1004|75-02-01|   144|
|   440|     6|  1001|74-10-10|     2|
|   241|     4|  1001|73-12-31|     1|
|    62|     3|  1002|74-06-18|     3|
|   475|     2|  1001|73-12-31|    32|
|   475|     1|  1002|74-07-01|     1|
|     5|     4|  1003|74-11-15|     3|
|     5|     4|  1004|75-01-22|     6|
|    20|     5|  1001|75-01-10|    20|
|    20|     5|  1002|75-01-10|    75|
|   241|     1|  1005|75-06-01|     1|
|   241|     2|  1005|75-06-01|    32|
|   241|     3|  1005|75-06-01|     1|
|    67|     4|  1005|75-07-01|     1|
|   999|    10|  1006|76-01-01|   144|
|   241|     8|  1005|75-07-01|     1|
|   241|     9|  1005|75-07-01|   144|
|------------------------------------|

Continue *

Отношение "поставки" содержит nпост  (номер  поставщика),  nчасти
(номер части, поставляемой поставщиком), nакта (номер акта о пос-
тавке), дата_пос (дата отгрузки), и размер (размер поставки).

Для поиска частей, поставляемых оставщиком номер 122 печатайте:

* retrieve (s.nчасти) where s.nпост =122
* \g
Executing . . .

2109: СТРОКА 1, Переменная 's' не объявлена
в операторе RANGE.

Continue
*

Мы сослались на кортеж-переменную "s" (т.е. s.nчасти без объявле-
ния  РУБИН,  что  она  представляет.)  Мы  ошиблись  в декларации
"range".  Перепечатаем запрос следующим образом:

* range of s is поставки
* retrieve (s.nчасти)where s.nпост =122
* \g
Executing . . .


|nчасти|
|------|
|     7|



Учебное введение в РУБИН                                  Стр. 12









|     7|
|     9|
|------|

Continue *

Поставщик номер 122 поставляет части с номерами 7, 7 и 9.   Обра-
тите  внимание,  что 7 повторяется дважды.  При выдаче результата
запроса на терминал для РУБИН более эффективно не проверять  дуб-
лирование кортежей.  Но РУБИН можно принудить удалять повторяющи-
еся кортежи.  Мы придем к этому позже.  Сейчас мы знаем, что пос-
тавщик  номер  122  поставляет части 7 и 9.  Если вы не запускали
этот запрос довольно долго, вы можете  не  знать  какие  названия
частей  соответствуют  частям с номерами 7 и 9.  Мы можем это уз-
нать просто выдав запрос:

* retrieve (p.имя) where p.номер= 7 or
* p.номер= 9
* \g
Executing . . .


|имя                 |
|--------------------|
|бумага АЦПУ         |
|терминальная бумага |
|--------------------|

Continue *

После выполнения этих двух запросов мы знаем названия частей пос-
тавляемыь  поставщиком  номер 122.  Мы могли получить этот же ре-
зультат в одном запросе:

* retrieve (p.имя) where p.номер= s.nчасти
* and s.nпост  122
* \g
Executing . . .


|имя                 |
|--------------------|
|бумага АЦПУ         |
|бумага АЦПУ         |
|терминальная бумага |
|--------------------|

Continue *

Снова заметим, что "бумага АЦПУ" повторяется  дважды.   Посмотрим
внимательно  на этот запрос.  Заметим, что домен номер существует
в  обоих  отношениях  "части"  и  "поставки".   Сказав,  p.номер=
s.nчасти, мы логически объединим эти два отношения.



Учебное введение в РУБИН                                  Стр. 13









Предположим, мы захотели найти всех поставщиков, которые  постав-
ляют  центральный  процессор.   Мы  знаем,  что  мы должны выдать
s.nпост  (номер  поставщика).   Но  мы  хотим  выдать  только  те
s.nпост,  где  соответствующий  s.nчасти  (номер  части) означает
часть с названием "центр.процессор".

Если мы найдем p.имя, которое равно "центр.процессор", то у  этой
части   интересующий   нас  p.номер.   Окончательно  мы  хотим  :
s.nчасти=p.номер Запрос будет:

* retrieve (s.nпост) where
* s.nчасти=p.номер and p.имя = "центр.процессор"
* \g
Executing . . .


|nпост |
|------|
|   475|
|   475|
|   241|
|------|

Continue *

Давайте оставим отношения "части" и "поставки" и перейдем к  дру-
гим.   Для  начала мы посмотрим, какие другие отношения имеются в
базе данных, напечатав:

* help \g
*Executing . . .


 имя отношения     владелец отношения

 relation          rubin
 attribute         rubin
 indexes           rubin
 integrity         rubin
 constraint        rubin
 товары            rubin
 сбыт              rubin
 служащие          rubin
 снабжение         rubin
 части             rubin
 поставки          rubin
 отделы            rubin
 поставщики        rubin


Continue
*




Учебное введение в РУБИН                                  Стр. 14









Давайте рассмотрим отношение "служащие".  Однако,  мы  ничего  не
знаем  об этом отношении, но мы можем использовать команду "help"
для получения информации о нем.  Печатайте:

* help служащие
* \g
Executing . . .


Отношение:              служащие
Владелец:               rubin
Ширина кортежа:         30
Сохранять до:           Сре Ноя 19 11:01:30 1986
Число кортежей:         25
Структура файла:        листованная куча
Тип отношения:          отношение пользователя

 имя атрибута     тип   длина    ключ.

 номер              i       2
 имя                c      20
 оклад              i       2
 управл             i       2
 дата_рожд          i       2
 нач_раб            i       2


Continue
*

Команда "help" выдает общую информацию об отношении вместе с каж-
дым атрибутом, его типом и длиной.

РУБИН поддерживает 3 типа данных: целые числа, числа с  плавающей
точкой и строки символов.  Символьные домены могут быть длиной от
1 до 255 символов. Целые домены могут быть длиной 1,2 и 4  байта.
Это  значит,  что целые могут принимать значения до 127, 32.767 и
2.147.483.647 соответственно.  Числа  с  плавающей  точкой  могут
быть  длиной  4  или  8 байтов. Числа обоих типов могут принимать
значения до 10**38 с точностью 7  или  17  знаков  соответсвенно.
Чтобы   просмотреть  все  домены,  мы должны использовать команду
"print" или использовать команду "retrieve",  где  указан  каждый
домен в запросе.  РУБИН предоставляет наикратчайший путь.  Попро-
буйте следующее:

* range of e is служащие
* retrieve (e.all)
* \g
Executing . . .


|номер |имя                 |оклад |управл|дата_р|нач_ра|
|-------------------------------------------------------|



Учебное введение в РУБИН                                  Стр. 15









|  157 | Петрыкин, Михаил   | 140  | 199  |1961  | 1983 |
| 1110 | Петров, Михаил     | 300  |  33  |1955  | 1978 |
|   35 | Никифоров, Михаил  | 300  |  32  |1961  | 1983 |
|  129 | Васильева, Ирина   | 160  | 199  |1961  | 1983 |
|   13 | Артуров, Игорь     | 135  | 199  |1964  | 1983 |
|  215 | Артурова, Галина   | 135  |  10  |1964  | 1983 |
|   55 | Сергеев, Дмитрий   | 135  | 199  |1964  | 1984 |
|   26 | Ильина, Елена      | 140  | 199  |1959  | 1981 |
|   98 | Петин, Александр   | 280  | 199  |1949  | 1971 |
|   32 | Веселый, Сергей    | 280  | 199  |1956  | 1979 |
|   33 | Скучный, Евгений   | 100  | 199  |1966  | 1982 |
|  199 | Семенов, Андрей    | 160  |   0  |1956  | 1979 |
| 4901 | Простакова, Елена  | 250  |  32  |1956  | 1979 |
|  843 | Рашидов, Надим     | 320  |  26  |1950  | 1972 |
| 2398 | Васильева, Наталья | 160  |  26  |1961  | 1983 |
| 1639 | Охта, Ольга        | 145  |  55  |1956  | 1979 |
| 5119 | Пупырев, Михаил В. | 180  |  55  |1961  | 1983 |
|   37 | Пантеров, Андрей   | 135  |  26  |1961  | 1983 |
| 5219 | Медведев, Андрей   | 220  |  33  |1961  | 1981 |
| 1523 | Лисина, Евгения    | 140  | 129  |1963  | 1980 |
|  430 | Соболев, М.И.      | 420  | 129  |1941  | 1964 |
|  994 | Андриянов, Николай | 120  | 129  |1961  | 1983 |
| 1330 | Зеленов, Игорь     | 190  |  13  |1966  | 1986 |
|   10 | Зеленов, Иван      | 120  | 199  |1965  | 1984 |
|   11 | Яблочков, Максим   | 300  |   0  |1964  | 1986 |
---------------------------------------------------------

Continue *

"all" - это ключевое слово, которое РУБИН разворачивает в  список
всех  доменов.  Не существует обязательного порядка в котором пе-
речисляются домены.  Предыдущий запрос эквивалентен следующему:

        range of e is служащие
        retrieve (e.номер, e.имя, e.оклад, e.управл,
                e.дата_рожд, e.нач_раб)

Давайте выдадим оклад Зеленова Вани.  В этом месте нам нужно  бу-
дет  печатать  буквы как верхнего, так и нижнего регистров.  Если
на Вашем терминале только прописные буквы, напечатайте "\"  перед
буквой,  которая должна быть заглавной. Т.о. на терминалах только
с верхним регистром печатайте т.о.  "\ЛОБАНОВ, \ВАНЯ" Если  же  у
Вас на терминале есть как прописные, так и строчные буквы, то ис-
пользуйте соответствующие клавиши переключения регистров.

Выдайте запрос:

* retrieve (e.имя,e.оклад)
* where e.name = "Зеленов, Ваня"
* \g
Executing . . .





Учебное введение в РУБИН                                  Стр. 16









!имя                 !оклад !
!---------------------------!
!---------------------------!

Continue *

Результат пуст.  Нет такого e.имя, которое соответствует заданной
квалификации.  Это странно, т.к. мы знаем, что у нас есть Зеленов
Ваня, но РУБИН тем не менее, не знает, что "Ваня" и "Иван" семан-
тически одно и то же.

Чтобы получить правильный ответ в этой ситуации,  Вы  можете  ис-
пользовать поиск по образцу, который предоставляет РУБИН.

Одним из специальных символов, служащих для этой  цели,  является
"*".   Она  соответствует любой строке длиной 0 и более символов.
Выдайте запрос:

* retrieve (e.имя,e.оклад)
* where e.name = "Зеленов, И*"
* \g
Executing . . .


!имя                 !оклад !
!---------------------------!
!Зеленов, Игорь      ! 190  !
!Зеленов, Иван       ! 120  !
!---------------------------!

Continue *

В первом случае "*" соответствует "горь", а во втором "ван".

Пожалуйста, еще один пример, выдать оклады  всех  людей,  которых
зовут "Михаил".

* retrieve (e.имя,e.оклад)
* where e.имя = "*,Михаил*"
* \g
Executing . . .


!имя                 !оклад !
!---------------------------!
| Петрыкин, Михаил   | 140  |
| Петров, Михаил     | 300  |
| Никифоров, Михаил  | 300  |
| Пупырев, Михаил В. | 180  |
!---------------------------!

Continue *




Учебное введение в РУБИН                                  Стр. 17









Обратите внимание, что если бы мы задали e.имя = "*, Михаил",  мы
не  получили  бы  четвертый  кортеж. Кроме того, РУБИН игнорирует
пробелы в любом символьном сравнении, независимо от того, исполь-
зуется ли поиск по образцу или нет.  Это значит, что

        e.имя = "Петров,Михаил"
        e.имя = "Петров,  Михаил   "
        e.имя = "П е т р о в, Михаил"

дает один и тот же результат.  Отдельные  символы  или  диапазоны
символов  могут  заключаться в квадратные скобки ( [,] ).  Напри-
мер, выдать тех, чьи имена начинаются с букв от А до О.

* retrieve (e.имя,e.оклад)
* where e.name = "[А-О]*"
* \g
Executing . . .


!name                !salary!
!---------------------------!
| Петрыкин, Михаил   | 140  |
| Никифоров, Михаил  | 300  |
| Васильева, Ирина   | 160  |
| Артуров, Игорь     | 135  |
| Артурова, Галина   | 135  |
| Сергеев, Дмитрий   | 135  |
| Ильина, Елена      | 140  |
| Петин, Александр   | 280  |
| Веселый, Сергей    | 280  |
| Скучный, Евгений   | 100  |
| Семенов, Андрей    | 160  |
| Простакова, Елена  | 250  |
| Рашидов, Надим     | 320  |
| Васильева, Наталья | 160  |
| Охта, Ольга        | 145  |
| Медведев, Андрей   | 220  |
| Соболев, М.И.      | 420  |
| Андриянов, Николай | 120  |
| Зеленов, Игорь     | 190  |
| Зеленов, Иван      | 120  |
-----------------------------

Continue *

Обратите внимание, что этот запрос можно было задать по другому.

* retrieve (e.имя,e.оклад)
* where e.имя >"А*" and e.имя <"П*"
* \g
Executing . . .





Учебное введение в РУБИН                                  Стр. 18









!имя                 !оклад !
!---------------------------!
| Петрыкин, Михаил   | 140  |
| Никифоров, Михаил  | 300  |
| Васильева, Ирина   | 160  |
| Артуров, Игорь     | 135  |
| Артурова, Галина   | 135  |
| Сергеев, Дмитрий   | 135  |
| Ильина, Елена      | 140  |
| Петин, Александр   | 280  |
| Веселый, Сергей    | 280  |
| Скучный, Евгений   | 100  |
| Семенов, Андрей    | 160  |
| Простакова, Елена  | 250  |
| Рашидов, Надим     | 320  |
| Васильева, Наталья | 160  |
| Охта, Ольга        | 145  |
| Медведев, Андрей   | 220  |
| Соболев, М.И.      | 420  |
| Андриянов, Николай | 120  |
| Зеленов, Игорь     | 190  |
| Зеленов, Иван      | 120  |
-----------------------------

Continue *

Результаты совпадают.  Тем не менее, второй способ более эффекти-
вен при работе с РУБИН.

    Есть три типа конструкций для поиска по образцу: *  -   соот-
        ветствует строке любой длины
    ?  -  соответствует 1 символу ( отличному от пробела )
    [] -  соответствует любому символу, перечисленному в скобках.
        Если  два  символа разделены знаком минус ( "-" ), то они
        соответствуют  любому  символу,  попадающему  в  диапазон
        между ними.


Чтобы спецсимвол воспринимался, как обычный, перед ним надо  пос-
тавить "\".  Так "\*" означает символ "*".

Теперь мы переходим к описанию групповых действий, поддерживаемых
РУБИН.   Эти действия позволяют пользователю производить вычисле-
ния по целым доменам отношения.  Например, таким действием  явля-
ется "найти среднее" ( avg ).  Чтобы посчитать средний оклад всех
сотрудников, мы даем запрос:

* retrieve (сроклад=avg(e.оклад))
* \g
Executing . . .


!сроклад   !



Учебное введение в РУБИН                                  Стр. 19









!----------!
!   198.600!
!----------!

Continue *

Заголовок можно выбрать любой, обязательно только  его  присутст-
вие.  РУБИН требует заголовок для любого выражения ( отличного от
простого домена ) в целевом списке.

_М_ы _т_а_к_ж_е _м_о_ж_е_м _н_а_й_т_и _с_а_м_ы_й _м_а_л_е_н_ь_к_и_й и самый большой оклад:

* retrieve (minокл=min(e.оклад),maxокл=max(e.оклад))
* \g
Executing . . .


!minокл!maxокл!
!-------------!
!  100 ! 420  !
!-------------!

Continue *

Если мы хотим узнать имена сотрудников, получающих самый  малень-
кий и самый большой оклады, то запрос должен иметь вид:

* retrieve (e.имя, e.оклад)
* where e.оклад = min(e.оклад) or e.оклад = max(e.оклад)
* \g
Executing . . .

!имя                 !оклад !
!---------------------------!
!Скучный, Евгений    !  100 !
!Соболев, М.И.       !  420 !
!---------------------------!

Continue *

В РУБИН есть следующие групповые действия:

        count
        min
        max
        avg
        sum
        any

Теперь давайте посмотрим на запрос, который  выдает  имя  каждого
сотрудника вместе со средним окладом:

* retrieve (e.имя,сроклад=avg(e.оклад))



Учебное введение в РУБИН                                  Стр. 20









* \g
Executing . . .


!имя                 !сроклад   !
!-------------------------------!
| Петрыкин, Михаил   | 198.600  |
| Петров, Михаил     | 198.600  |
| Никифоров, Михаил  | 198.600  |
| Васильева, Ирина   | 198.600  |
| Артуров, Игорь     | 198.600  |
| Артурова, Галина   | 198.600  |
| Сергеев, Дмитрий   | 198.600  |
| Ильина, Елена      | 198.600  |
| Петин, Александр   | 198.600  |
| Веселый, Сергей    | 198.600  |
| Скучный, Евгений   | 198.600  |
| Семенов, Андрей    | 198.600  |
| Простакова, Елена  | 198.600  |
| Рашидов, Надим     | 198.600  |
| Васильева, Наталья | 198.600  |
| Охта, Ольга        | 198.600  |
| Розовый, Михаил    | 198.600  |
| Пантеров, Андрей   | 198.600  |
| Медведев, Андрей   | 198.600  |
| Лисина, Евгения    | 198.600  |
| Соболев, М.И.      | 198.600  |
| Андриянов, Николай | 198.600  |
| Зеленов, Игорь     | 198.600  |
| Зеленов, Иван      | 198.600  |
| Яблочков, Максим   | 198.600  |
---------------------------------

Continue *

Групповое действие всегда выдает одно значение.  Обрабатывая пос-
ледний запрос, РУБИН повторила средний оклад после каждого e.имя.

Групповые действия могут  иметь  свою  собственную  квалификацию.
Например, мы можем получить список из имен всех сотрудников, плюс
средний оклад для всех сотрудников старше 30 лет.

* retrieve (e.имя,сроклад=
* avg(e.оклад where 1986-e.дата_рожд > 30)
* \g
Executing . . .


!имя                 !сроклад   !
!-------------------------------!
| Петрыкин, Михаил   | 330.000  |
| Петров, Михаил     | 330.000  |
| Никифоров, Михаил  | 330.000  |



Учебное введение в РУБИН                                  Стр. 21









| Васильева, Ирина   | 330.000  |
| Артуров, Игорь     | 330.000  |
| Артурова, Галина   | 330.000  |
| Сергеев, Дмитрий   | 330.000  |
| Ильина, Елена      | 330.000  |
| Петин, Александр   | 330.000  |
| Веселый, Сергей    | 330.000  |
| Скучный, Евгений   | 330.000  |
| Семенов, Андрей    | 330.000  |
| Простакова, Елена  | 330.000  |
| Рашидов, Надим     | 330.000  |
| Васильева, Наталья | 330.000  |
| Охта, Ольга        | 330.000  |
| Розовый, Михаил    | 330.000  |
| Пантеров, Андрей   | 330.000  |
| Медведев, Андрей   | 330.000  |
| Лисина, Евгения    | 330.000  |
| Соболев, М.И.      | 330.000  |
| Андриянов, Николай | 330.000  |
| Зеленов, Игорь     | 330.000  |
| Зеленов, Иван      | 330.000  |
| Яблочков, Максим   | 330.000  |
---------------------------------

 Continue
 *

Предыдущий запрос отличается от следующего.  Мы получим имена тех
служащих, которым за 30 среднюю зарплату для всех служащих.

* retrieve (e.имя,сроклад=avg(e.оклад))
* where 1986-e.дата_рожд > 30
* \g
Executing . . .


|имя                 |сроклад   |
|-------------------------------|
| Петров, Михаил     | 198.600  |
| Петин, Александр   | 198.600  |
| Рашидов, Надим     | 198.600  |
| Соболев, М.И.      | 198.600  |
|-------------------------------|

Continue *

Имеется очень важное отличие между последующими двумя  запросами.
Групповые  функции  полностью  самостоятельны.   На них не влияют
квалификации всего запроса.

В первом случае средний  оклад  получен  только  для  сотрудников
старше  30 лет и выдаются все сотрудники.  Во втором случае сред-
ний оклад считается для всех сотрудников, но выдаются только  те,



Учебное введение в РУБИН                                  Стр. 22









которые старше 30 лет.

Если мы хотим получить список  всех  сотрудников  старше  30  лет
вместе с их средним окладом, то мы должны объединить 2 предыдущих
запроса в 1.  Получится вот что:

* retrieve (e.имя, сроклад=
* avg(e.оклад where 1986 - e.дата_рожд > 30))
* where 1986 - e.дата_рожд > 30
* \g
Executing . . .


!имя                 !сроклад   !
!-------------------------------!
| Петров, Михаил     | 330.000  |
| Петин, Александр   | 330.000  |
| Рашидов, Надим     | 330.000  |
| Соболев, М.И.      | 330.000  |
!-------------------------------!

Continue *

Иногда бывает полезно убрать повторяющиеся значения перед  выпол-
нением  группового  действия.   Например,  если  нам нужно узнать
сколько у нас управляющих, следующий запрос не даст нам  правиль-
ного ответа.

* retrieve (руков = count(e.управл))
* \g
*Executing . . .


!руков        !
!-------------!
!           25!
!-------------!

Continue *

Обратите внимание, что нам выдалось количество кортежей в отноше-
нии. Нам же нужно узнать сколько неповторяющихся e.manager есть в
нем.

В РУБИН есть 3 особые формы групповых действий:


        countu   посчитать неповторяющиеся значения
        avgu    вычислить среднее для неповторяющихся значений
        sumu    суммировать неповторяющиеся значения


Интересно заметить, что minu, maxu и anyu не нужны.  Их  значения



Учебное введение в РУБИН                                  Стр. 23









не зависят от того, есть неповторяющиеся значения или нет.

Правильным запросом для выяснения  количества  управляющих  будет
следующий:

* retrieve (руков=countu(e.управл))
* \g
Executing . . .


!руков        !
!-------------!
!            9!
!-------------!

Continue *

В РУБИН также есть т.н. групповые функции. Групповые функции раз-
бивают данные на категории и выполняют отдельные групповые дейст-
вия для каждой категории.

Например, чтобы получть имя каждого сотрудника, средний оклад для
всех  сотрудников  с одинаковыми управляющими, нужно набрать зап-
рос:

* retrieve (e.имя,ср_по_упр=avg(e.оклад by e.управл))
* \g
Executing . . .


!имя                 !ср_по_упр !
!-------------------------------!
|Артурова, Галина    |   135.000|
|Семенов, Андрей     |   230.000|
|Яблочков, Максим    |   230.000|
|Простакова, Елена   |   275.000|
|Никифоров, Михаил   |   275.000|
|Медведев, Андрей    |   260.000|
|Петров, Михаил      |   260.000|
|Зеленов, Игорь      |   190.000|
|Охта, Ольга         |   162.500|
|Розовый, Михаил     |   162.500|
|Васильева, Наталья  |   205.000|
|Рашидов, Надим      |   205.000|
|Пантеров, Андрей    |   205.000|
|Артуров, Игорь      |   165.556|
|Сергеев, Дмитрий    |   165.556|
|Скучный, Евгений    |   165.556|
|Веселый, Сергей     |   165.556|
|Петрыкин, Михаил    |   165.556|
|Петин, Александр    |   165.556|
|Зеленов, Иван       |   165.556|
|Васильева, Ирина    |   165.556|



Учебное введение в РУБИН                                  Стр. 24









|Ильина, Елена       |   165.556|
|Андриянов, Николай  |   226.667|
|Соболев, М.И.       |   226.667|
|Лисина, Евгения     |   226.667|
---------------------------------

Continue *

Первый  человек работает под руководством одного и того же управ-
ляющего, и их оклад составляет 135.000 рублей.  Следующие 2 чело-
века тоже работают под руководством одного и  того  же  управляю-
щего, и их оклад - 162.500 рублей.

Еще раз, если мы хотим получить список сотрудников старше 30 лет,
то запрос будет иметь следующий вид:

* retrieve (e.имя,ср_по_упр=
  avg(e.оклад by e.управл))
* where 1986-e.дата_рожд > 30
* \g
Executing . . .


!имя                 !ср_по_упр !
!-------------------------------!
| Петров, Михаил     | 260.000  |
| Петин, Александр   | 165.556  |
| Рашидов, Надим     | 205.000  |
| Соболев, М.И.      | 226.000  |
!-------------------------------!

Continue *

Групповые функции ( в отличие от групповых действий ) не замкнуты
в  себе.   Домены,  по  которым  разбиваются  данные ( называемые
"список-by") логически присоединяются ко всем остальным доменам в
запросе.

В последних примерах "e.управл" в by-списке относится к  тому  же
кортежу, что и "e.имя" в целевом списке.

Если мы хотим посчитать средний оклад тех, кто работает под руко-
водством управляющих 33 и 199, то запрос будет таким:

* retrieve (e.имя,ср_по_упр=
* avg(e.оклад by e.управл)
* where e.управл = 199 or e.управл = 33
* \g
Executing . . .


!имя                 !ср_по_упр !
!-------------------------------!



Учебное введение в РУБИН                                  Стр. 25









|Петров, Михаил      |   260.000|
|Медведев, Андрей    |   260.000|
|Петрыкин, Михаил    |   165.556|
|Васильева, Ирина    |   165.556|
|Артуров, Игорь      |   165.556|
|Сергеев, Дмитрий    |   165.556|
|Ильина, Елена       |   165.556|
|Петин, Александр    |   165.556|
|Веселый, Сергей     |   165.556|
|Скучный, Евгений    |   165.556|
|Зеленов, Иван       |   165.556|
---------------------------------

Continue *

Теперь предположим, что нам нужно выяснить сколько человек  рабо-
тает  под  руководством  каждого  управляющего,  причем  учитывая
только тех сотрудников, кто проработал минимум 7 лет:

* retrieve (e.управл,человек=
 count(e.имя by e.управл where
* e.нач_раб < 1979))
* \g
Executing . . .


!управл!человек      !
!--------------------!
!     0!            0!
!    10!            0!
!    13!            0!
!    26!            1!
!    32!            0!
!    33!            0!
!    55!            0!
!   129!            1!
!   199!            1!
!--------------------!

Continue *

Обратите внимание, что управляющие 0, 10, 13, 32, 33, 55 не имеют
сотрудников,  кто  работал до 79 года.  Теперь, скажем, нам нужно
узнать средний  оклад  для  этих  сотрудников.   Просто  поменяем
"count" на "avg".

* retrieve (e.управл,человек=
 avg(e.оклад by e.управл where
* e.нач_раб < 1979))
* \g
Executing . . .





Учебное введение в РУБИН                                  Стр. 26









!управл!человек   !
!-----------------!
!     0!     0.000!
!    10!     0.000!
!    13!     0.000!
!    26!   320.000!
!    32!     0.000!
!    33!   300.000!
!    55!     0.000!
!   129!   420.000!
!   199!   280.000!
!-----------------!

Continue *

Обратите внимание, что РУБИН делает для управляющих  0,  10,  13,
32,  55.  Средний оклад для сотрудников этих управляющих не опре-
делен, т.к. у них нет сотрудников, работавших раньше 1979  г.   В
гупповых  действиях  РУБИН всегда считает неопределенные значения
равными нулю.

Если Вы хотите удалить нулевые значения из вывода, то  к  запросу
надо добавить соответствующую квалификацию.  Следующий запрос вы-
дает средние оклады, только если они больше 0.

* retrieve (e.управл,человек=
*  avg(e.оклад by e.управл where e.нач_раб < 1979))
*  where
*  avg(e.оклад by e.управл where e.нач_раб < 1979) > 0
* \g
Executing . . .


!управл!человек   !
!-----------------!
!    26!   320.000!
!    33!   300.000!
!   129!   420.000!
!   199!   280.000!
!-----------------!

Continue *

До сих пор мы выдавали результаты прямо на терминал. Также  можно
сохранить  результаты  в  новом отношении.  Это выполняется такой
командой:

        retrieve into newrel ( ... )
        where . . .

Все правила будут точно такими же, как и для выдачи на  терминал.
РУБИН  создаст  новое отношение с соответствующими доменами и по-
местит результат запроса в новое отношение.



Учебное введение в РУБИН                                  Стр. 27









Например,  создадим  новое  отношение,  которое  называется  "на-
чальство",  в котором будут только те сотрудники, которые зараба-
тывают больше 250 рублей.

* retrieve into начальство (e.all)
* where e.оклад > 250
* print начальство
* \g
Executing . . .


Отношение начальство

!номер !имя                 !оклад !управл!день_р!нач_ра!
!-------------------------------------------------------!
|   11 | Яблочков, Максим   | 300  |   0  |1964  | 1986 |
|   32 | Веселый, Сергей    | 280  | 199  |1956  | 1979 |
|   35 | Никифоров, Михаил  | 300  |  32  |1961  | 1983 |
|   98 | Петин, Александр   | 280  | 199  |1949  | 1971 |
|  430 | Соболев, М.И.      | 420  | 129  |1941  | 1964 |
|  843 | Рашидов, Надим     | 320  |  26  |1950  | 1972 |
| 1110 | Петров, Михаил     | 300  |  33  |1955  | 1978 |
---------------------------------------------------------

Continue *

По команде "retrive into" ничего не печатается.  Мы должны  вклю-
чить  команду  "print"  в  запрос, чтобы выдать результат.  Кроме
того, отношения с таким именем не должно существовать.  Например,
если  мы  запустим  еще  раз этот запрос, то получим сообщение об
ошибке.

* \g
Executing . . .

5102: CREATE: нельзя дублировать имя отношения

Continue
*

У "retrive into" есть две особенности. Во-первых, новое отношение
автоматически  сортируется  и  повторяющиеся  кортежи  удаляются.
Во-вторых, отношение становится частью базы данных, и  Вы  являе-
тесь  его владельцем.  Если Вы не хотите сохранить это отношение,
то Вам нужно его  разрушить.  Как  это  делается,  мы  рассмотрим
чуть-чуть позже.

До сих пор мы только выдавали данные, но не изменяли их.  В РУБИН
есть 3 команды изменения: append( добавить ), replace( заменить )
и delete( уничтожить ).

Например, чтобы добавить Игоря Алексеева к  списку  очень  хорошо
получающих с окладом 320 рублей надо сделать запрос:



Учебное введение в РУБИН                                  Стр. 28









* append to начальство(имя = "Алексеев, Игорь", оклад = 320)
* \g
Executing . . .


Continue
*

Обратите внимание, что мы задали значение только для 2 из 6 доме-
нов.  Это  правильно. РУБИН автоматически установит численные до-
мены в 0 и символьные домены в пробел, если они не заданы.

Кроме того РУБИН ничего не напечатал  после  выполнения  запроса.
Все команды изменения ничего не печатают.

Давайте дадим всем, кто хорошо получает, 10% надбавку:

* range of o is начальники
* replace o(оклад = o.оклад * 1.1)
* \g
Executing . . .


Continue
*

Команде "append" требуется имя отношения (  например:  append  to
начальники  ),  тогда как командам "replace" и "delete" требуется
кортеж-переменная.  Т.е. команда будет иметь вид:

        replace o ( . . . )
                where . . .

а не:

        replace начальство ( . . . )
                where . . .

Напечатаем результаты двух последних изменений:

* print начальство
* \g
Executing . . .


Отношение начальство

!номер !имя                 !оклад !управл!день_р!нач_ра!
!-------------------------------------------------------!
|   11 | Яблочков, Максим   | 330  |   0  |1964  | 1986 |
|   32 | Веселый, Сергей    | 308  | 199  |1956  | 1979 |
|   35 | Никифоров, Михаил  | 330  |  32  |1961  | 1983 |
|   98 | Петин, Александр   | 308  | 199  |1949  | 1971 |



Учебное введение в РУБИН                                  Стр. 29









|  430 | Соболев, М.И.      | 462  | 129  |1941  | 1964 |
|  843 | Рашидов, Надим     | 352  |  26  |1950  | 1972 |
| 1110 | Петров, Михаил     | 330  |  33  |1955  | 1978 |
|    0 | Алексеев, Игорь    | 352  |   0  |   0  |    0 |
!-------------------------------------------------------!

Continue *

Давайте уволим тех, у кого самый маленький оклад:

* delete o where o.оклад = min(o.оклад) \g
Executing . . .


Continue
*

Еще раз заметьте, что команда "delete" требует  кортеж-переменной
(например : delete 0 ), а не имя отношения.

Предположим, мы хотим узнать, кто зарабатывает больше Игоря Алек-
сеева  ?   Рассмотрим,  как создать такой запрос.  Сначала мы ис-
пользуем новую кортеж-переменную "t"  с  областью  действия  "на-
чальство"  которая указывать на Игоря.  "t.name" должно быть рав-
ным "Алексеев, Игорь" Далее мы используем кортеж-переменную  "о",
которая  будет пробегать все отношение.  Если мы найдем o.оклад >
t.оклад, то это значит, что o.name получает больше, чем Игорь.

Итак, запрос выглядит следующим образом:

* range of t is начальство
* retrieve (o.имя, оокл=o.оклад, иоклад = t.оклад)
* where o.оклад > t.оклад
* and t.name = "Алексеев, Игорь"
* \g
*Executing . . .


!имя                 !оокл  !иоклад!
!----------------------------------!
| Соболев, М.И.      | 462  |  352 |
!----------------------------------!

Continue *

Если мы хотим, чтобы Игорь Алексеев получал на 50 рублей  больше,
чем кто бы то ни был, мы должны сделать запрос:

* replace o(оклад = max(o.оклад) + 50)
* where o.имя = "Алексеев, Игорь"
* \g
Executing . . .




Учебное введение в РУБИН                                  Стр. 30









Continue
*

Наконец, чтобы разрушить отношение, владельцем которого Вы являе-
тесь, напечатайте команду:

* destroy начальство
* \g
Executing . . .


Continue
*

Теперь можно и закончить работу в РУБИН.  Это можно сделать, наб-
рав символ "CNTRL-D"  или командой "\q":

* \q

СУБД РУБИН,  конец работы
Пят ноя 14 16:27:53 1986
До свидания, rubin
приходите еще.


  ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ ОБ ИСПОЛЬЗОВАНИИ РУБИН


На самом деле РУБИН значительно больше, чем описано в приведенных
выше  примерах. Если вы собираетесь создавать и сопровождать базы
данных, вам совершенно необходимо изучить  документ  "Создание  и
поддержка базы данных с использованием РУБИН" - в нем описана вся
"подводная" часть СУБД, которая не нужна начинающему пользователю
для  общения  с уже существующей базой, но необходима администра-
тору баз данных.  Кроме того, вам очень скоро  будет  не  хватать
описанных  выше  возможностей.  Для  того,  чтобы готовить отчеты
сложной формы, организовывать диалог с  пользователем,  обрабаты-
вать данные из базы используется язык EQUEL - расширение языка Си
для взаимодействия с СУБД РУБИН. Подробное описание  языка  EQUEL
имеется в справочном руководстве, а здесь приведем простой пример
программы на языке EQUEL и прокомментируем его:

  #include <stdio.h>
  ## char pname[21];
  ## char col[9];
  main(argc, argv)
  int     argc;
  char    *argv[];

  {
  ##      rubin "-i210" demo
  ##      print части
  ##      range of p is части     /*



Учебное введение в РУБИН                                  Стр. 31









  ##      retrieve (pname = p.#пимя)
  ##      {
                  printf("%s0, pname);
  ##      }
  ##   exit
  }

Как можно заметить, операторы QUEL просто  записываются  в  прог-
рамме  на языке Си, используя символы ## в качестве признака опе-
ратора EQUEL.  При этом Си переменные  могут  использоваться  для
формирования значений, имен, условия поиска. В операторе RETRIEVE
происходит передача найденных значений в переменные языка Си.

Полный текст примера с комментариями можно  найти  в  справочнике
"doc/Examples"  (считая от корневого справочника Рубин), все при-
меры на EQUEL кончаются суффиксом .q . На самом деле  язык  EQUEL
содержит  ряд расширений по отношению к QUEL, связанных с взаимо-
действием СУБД и программы на Си; все они  описаны  в  справочном
руководстве по РУБИН.

В ряде простых применений можно обойтись без EQUEL, воспользовав-
шись  возможностями встроенного в QUEL макроязыка. Так, для того,
чтобы вводить новые данные в отношение  "части",  можно  написать
такое задание для QUEL (оно записывается в отдельный файл, напри-
мер, "newp.mac"):


 \r
 {type Вводим новую часть. }
 retrieve (макс_номер=max(части.номер))
 \g\r
 \mark start
 append to части
 (номер={read Номер? },
 имя="{read Имя? }",
 цвет="{read Цвет? }",
 вес= {read Вес? },
 колич={read Колич? })
 \v\a
 \branch ?{read ЕЩЕ (1 - да, 0 - нет)? }=1 start
 {type Проверьте результат и введите команду \\ g}
 \v\a
 \e


Этот пример записан в справочнике "demo" под  именем  "newp.mac".
Для  ввода  новых данных в отношение "части" остается только наб-
рать:

 \i demo/newp.mac

(если, конечно, вы находитесь в корневом  справочнике  РУБИН),  и
ввести требуемую информацию. Подробное описание макро можно найти



Учебное введение в РУБИН                                  Стр. 32









в разделе MACRO(QUEL) справочного руководства, а примеры  сложных
заданий  на  макро - в справочнике doc/Examples/ (суффикс *.mac);
здесь заметим только, что в данном примере после ввода информации
перед  ее записью в базу пользователю дается возможность отредак-
тировать ее редактором "red".

Еще одним средством, облегчающим работу с РУБИН, является система
управления  экраном  и экранными формами "DIXY" (разработка АЗЛК,
Москва).  Она не входит в комплект  поставки  РУБИН,  но  в  него
включен  демонстрационный  пример  программы на DIXY: перейдите в
справочник "demodixy" и вызовите программу "pred":

 cd ~rubin/demodixy
 pred demo

Теперь вы получили начальные знания о системе РУБИН и можете  на-
чинать с ней работать.







































Учебное введение в РУБИН                                  Стр. 33


