head     4.6;
access   ;
symbols  RED_4:3.1.2 RED_3_9:3.16 DEMOS_2:3.3 COMMON3:3.2 ES:3.1.1;
locks    ;
comment  @ * @;


4.6
date     89.02.20.22.48.12;  author alex;  state Exp;
branches ;
next     4.5;

4.5
date     88.04.07.12.19.20;  author alex;  state Exp;
branches ;
next     4.4;

4.4
date     88.04.07.12.02.13;  author alex;  state Exp;
branches ;
next     4.3;

4.3
date     88.04.04.22.16.14;  author alex;  state Exp;
branches ;
next     4.2;

4.2
date     88.03.31.22.50.29;  author alex;  state Exp;
branches ;
next     4.1;

4.1
date     88.03.31.22.06.09;  author alex;  state Exp;
branches ;
next     3.17;

3.17
date     88.03.30.17.25.07;  author alex;  state Exp;
branches ;
next     3.16;

3.16
date     87.06.12.18.07.21;  author alex;  state Exp;
branches ;
next     3.15;

3.15
date     87.06.08.20.01.08;  author alex;  state Exp;
branches ;
next     3.14;

3.14
date     87.06.05.23.48.29;  author alex;  state Exp;
branches ;
next     3.13;

3.13
date     87.06.04.23.41.52;  author alex;  state Exp;
branches ;
next     3.12;

3.12
date     87.04.21.22.46.30;  author alex;  state Stab;
branches ;
next     3.11;

3.11
date     87.04.21.22.28.57;  author alex;  state Exp;
branches ;
next     3.10;

3.10
date     87.04.02.18.29.44;  author alex;  state Exp;
branches ;
next     3.9;

3.9
date     87.02.17.06.49.40;  author alex;  state Exp;
branches ;
next     3.8;

3.8
date     86.11.25.08.06.26;  author alex;  state Exp;
branches ;
next     3.7;

3.7
date     86.10.29.02.46.37;  author root;  state Exp;
branches ;
next     3.6;

3.6
date     86.10.14.23.02.52;  author alex;  state Exp;
branches ;
next     3.5;

3.5
date     86.09.19.21.39.35;  author alex;  state Exp;
branches ;
next     3.4;

3.4
date     86.09.19.19.59.39;  author alex;  state Exp;
branches ;
next     3.3;

3.3
date     86.08.04.20.55.13;  author alex;  state Exp;
branches ;
next     3.2;

3.2
date     86.07.24.19.07.48;  author alex;  state Exp;
branches ;
next     3.1;

3.1
date     86.04.20.23.43.21;  author alex;  state Exp;
branches 3.1.2.1;
next     ;

3.1.2.1
date     87.06.19.16.56.43;  author alex;  state Exp;
branches ;
next     3.1.2.2;

3.1.2.2
date     87.06.23.18.55.33;  author alex;  state Stab;
branches ;
next     3.1.2.3;

3.1.2.3
date     87.06.24.22.36.46;  author alex;  state Stab;
branches ;
next     3.1.2.4;

3.1.2.4
date     87.07.03.22.03.56;  author alex;  state Exp;
branches ;
next     3.1.2.5;

3.1.2.5
date     87.07.09.20.44.11;  author alex;  state Exp;
branches ;
next     ;


desc
@  –ü–æ–ª–∏—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä RED
  –í–µ—Ä—Å–∏—è 3.
  –ò–ê–≠ –∏–º. –ö—É—Ä—á–∞—Ç–æ–≤–∞, –ú–æ—Å–∫–≤–∞.
@


4.6
log
@–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ SUSPEND 
@
text
@/*
 *      –†–µ–¥–∞–∫—Ç–æ—Ä RED.
 *       $Header: S.ttyio.c,v 4.5 88/04/07 12:19:20 alex Exp $
 *
 *      $Log:	S.ttyio.c,v $
 * Revision 4.5  88/04/07  12:19:20  alex
 * –û—á–µ—Ä–µ–¥–Ω–∞—è –ø—Ä–∞–≤–∫–∞ –≤ —Ä–æ–ª–ª–∏—Ä–æ–≤–∞–Ω–∏–∏.
 * 
 * Revision 4.4  88/04/07  12:02:13  alex
 * –ò—Å–ø—Ä–∞–≤–∏–ª–∏ –æ—à–∏–±–∫—É –≤ —Ä–∞–±–æ—Ç–µ setscroll.
 * 
 * Revision 4.3  88/04/04  22:16:14  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ –≤ —Ä–∞–±–æ—Ç–µ –ø—Ä–∏ —Ä–∞—Å—â–µ–ø–ª–µ–Ω–∏–∏ —Å—Ç—Ä–æ–∫–∏ (—Ä–µ–∂–∏–º CS).
 * 
 * Revision 4.2  88/03/31  22:50:29  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ –Ω–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ –≠–ª–µ–∫—Ç—Ä–æ–Ω–∏–∫–∞.
 * 
 * Revision 4.1  88/03/31  22:06:09  alex
 * –í–µ—Ä—Å–∏—è 4.1 - –æ–±–∫–∞—Ç–∫–∞ –Ω–∞ UTEC, –°–ú
 * 
 * Revision 3.17  88/03/30  17:25:07  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ –≤ readch. –í–≤–µ–¥–µ–Ω—ã —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è/–≤—Å—Ç–∞–≤–∫–∏
 * —Å—Ç—Ä–æ–∫ –Ω–∞ —ç–∫—Ä–∞–Ω–µ —á–µ—Ä–µ–∑ ChangeScroll/InsertLine-DeleteLine.
 * 
 * Revision 3.1.2.5  87/07/09  20:44:11  alex
 * REVISION
 * 
 * Revision 3.1.2.4  87/07/03  22:03:56  alex
 * Graph_characters used in margin
 * 
 * Revision 3.1.2.3  87/06/24  22:36:46  alex
 * New readch + gettc + tc table Tested
 * 
 * Revision 3.1.2.2  87/06/23  18:55:33  alex
 * –í—ã–∫–∏–Ω—É—Ç–∞ lread1 –∫–∞–∫ –∫–ª–∞—Å—Å.
 * 
 * Revision 3.1.2.1  87/06/19  16:56:43  alex
 * Start revision for red/4
 * 
 * Revision 3.16  87/06/12  18:07:21  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –æ—à–∏–±–∫–∏ –≤ —Ä–µ–∂–∏–º–µ vilcase –∏ –º–µ–ª–æ—á–∏ –¥–ª—è vt-200
 * 
 * Revision 3.15  87/06/09  19:45:28  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ —Ä–∞–±–æ—Ç–∞ —Å tty ~ VT200 –∏ 15-–ò–≠-0013
 * 
 * Revision 3.14  87/06/05  23:48:29  alex
 * –î–æ–±–∞–≤–ª–µ–Ω roll –¥–ª—è —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–≤ —Å sr/sf –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
 *  —Ç–∞–±—É–ª—è—Ü–∏–π –≤ —Ä–µ–∂–∏–º–µ -t + –≤—Å—è–∫–∞—è –º–µ–ª–æ—á—å
 * 
 * Revision 3.13  87/06/04  23:41:52  alex
 * Scroll on -sr- or -al/dl- added
 * 
 * Revision 3.12  87/04/21  22:46:30  alex
 * Debug
 * 
 * Revision 3.11  87/04/21  22:28:57  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ –≤ writefile.
 * 
 * Revision 3.10  87/04/02  18:29:44  alex
 * –í–µ—Ä—Å–∏—è –¥–ª—è Utec —Å–ª–∏—Ç–∞ —Å –≤–µ—Ä—Å–∏–µ–π —Å –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º –ø—Ä–æ–ø–∏—Å–Ω—ã—Ö –±—É–∫–≤
 * 
 * Revision 3.9  87/04/01  19:14:19  alex
 * Revision for Utec: Cs, Ce, Ct, hR
 * 
 * Revision 3.8  86/11/25  08:06:26  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ ioctl(..,TIOCFLUSH,&flag)
 * 
 * Revision 3.7  86/10/29  02:46:37  root
 * –ü—Ä–∏ –Ω–µ–≤–µ—Ä–Ω–æ–π escape-–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Å–±—Ä–∞—Ç—ã–≤–∞–µ–º –≤—Å—é –æ—á–µ—Ä–µ–¥—å –≤–≤–æ–¥–∞.
 * –°–¥–µ–ª–∞–Ω–æ –¥–ª—è –±–æ—Ä—å–±—ã —Å –ø—Ä–æ–ø–∞–¥–∞–Ω–∏–µ–º —Å–∏–º–≤–æ–ª–æ–≤.
 * 
 * Revision 3.6  86/10/14  23:02:52  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –æ—à–∏–±–∫–∏ —Å: RUSDIAG (–Ω–µ –æ–ø–∏—Å–∞–Ω latdiag), –∏ —Å LCASEO
 * (KI40BIT –Ω—É–∂–Ω–æ –∑–∞–¥–∞–≤–∞—Ç—å —Ç–∞–∫, —á—Ç–æ–±—ã –ø—Ä–∏ lcasef –±—ã–ª–∞ 1).
 * –í –°–ú-1700 –±—ã–ª–æ 2 –æ—à–∏–±–∫–∏, –≤ —Ä–µ–∑. –≤—Å–µ —Ä–∞–±–æ—Ç–∞–ª–æ –Ω–∞ LCASE –ø—Ä–∞–≤–∏–ª—å–Ω–æ.
 * 
 * Revision 3.5  86/09/19  21:39:35  alex
 * 
 * 
 * Revision 3.4  86/09/19  19:59:39  alex
 * –í–µ—Ä—Å–∏—è –¥–ª—è –°–ú-1700
 * 
 * Revision 3.3  86/08/04  20:55:13  alex
 * Bepqh dk LMNQ/DELNQ 2
 * 
 * Revision 3.2  86/07/24  19:07:48  alex
 * –û–±'–µ–¥–∏–Ω–µ–Ω—ã –≤–µ—Ä—Å–∏–∏ —Ç–µ–∫—Å—Ç–æ–≤ –¥–ª—è –ï–° –∏ –°–ú
 *
 * Revision 3.1  86/04/20  23:43:21  alex
 * –ë–∞–∑–æ–≤–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –ï–°.
 *
 * Revision 3.1  86/04/20  23:43:21  alex
 * *** empty log message ***
 *
 *      –†–∞–±–æ—Ç–∞ —Å —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–º : —É—Å—Ç–∞–Ω–æ–≤–∫–∞/—Å–Ω—è—Ç–∏–µ —Ä–µ–∂–∏–º–æ–≤, –≤–≤–æ–¥/–≤—ã–≤–æ–¥.
 *      –í–≤–æ–¥ —É–ø—Ä–∞–≤–ª—è—é—â–∏—Ö –∫–ª–∞–≤–∏—à.
 *      –§–∏–∑–∏—á–µ—Å–∫–∏–π —É—Ä–æ–≤–µ–Ω—å
 */

#include "r.defs.h"
#include "S.tele.h"
#include <sgtty.h>
#include <sys/types.h>
#include <sys/file.h>

#define NPUTCBUF 256   /* –†–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞ –≤—ã–≤–æ–¥–∞ */

#ifdef TIOCSETA
#define stty(des,fil) ioctl(des,TIOCSETA,fil)
#define gtty(des,fil) ioctl(des,TIOCGETA,fil)
#endif
#ifdef SGTTYB /* –ü—Ä–∏–∑–Ω–∞–∫ –î–ï–ú–û–°-2 */
#define sgttyb SGTTYB
#endif

#ifndef ANYP
#define ANYP (ODDP|EVENP)
#endif
struct sgttyb templ;
#ifdef TIOCGETC
struct tchars tchars0;
#endif
#ifdef TIOCSLTC
static struct ltchars tmpltc,oldltc;
#endif
int ospeed; /* –î–ª—è termcap */
short cy40bit; /* –î–ª—è –ø–µ—Ä–µ–≤–æ—Ä–æ—Ç–∞ –≤ —É–ø—Ä. –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—è—Ö */
short lcasef0; /* –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –ø—Ä–∏–∑–Ω–∞–∫ lcase –¥–ª—è –≤—ã–≤–æ–¥–∞ */
short latdiag;
short vilcasef;

/*
 * ttstartup()
 * –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–µ–∂–∏–º—ã —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
 */
ttstartup()
{
    static struct sgttyb templw;
#ifdef TIOCGETC
    static struct tchars tcharsw;
#endif
#ifdef TIOCGETC
    ioctl(2,TIOCGETC, &tchars0);
    tcharsw=tchars0;
    if  (tcharsw.t_intrc=='\177')tcharsw.t_intrc=3; /* ETX - intrup of RE */
    tcharsw.t_quitc = -1;
    ioctl(2,TIOCSETC, &tcharsw);
#endif
#ifdef TIOCSLTC
    ioctl(2,TIOCGLTC,&tmpltc);
    oldltc = tmpltc;
    tmpltc.t_suspc = tmpltc.t_dsuspc = tmpltc.t_flushc = -1;
    ioctl(2,TIOCSLTC,&tmpltc);
#endif
    gtty(2,&templ);
/*  printf("GTTY %o\n", &templ);        */
    templw=templ;
    ospeed = templ.sg_ospeed;
    lcasef=lcasef0=LCFLG(templ.sg_flags);
    latf = LATFLG(templ.sg_flags);
    if ( latf ) latdiag = 1;
    if(lcasef) latf=0;
    kioutf = KIOFLG(templ.sg_flags);
#ifdef KI40BIT
    cy40bit = KI40BIT(templ.sg_flags);
#endif
    if(atcread)
    {   register int i;
	i=(*atcread)();
	atcread = (int (*)())NULL;
	if(i) {
	    printf1((i==1?
	    DIAG("unknown term capabilities\n please, type \n  TERM=<type>;export TERM \n and repeat red\n","–ù–µ –∑–∞–¥–∞–Ω–æ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π —Ç–µ—Ä–º–∏–Ω–∞–ª–∞, \n –Ω–∞–±–µ—Ä–∏—Ç–µ TERM=—Ç–∏–ø;export TERM –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤—ã–∑–æ–≤"):
	    DIAG("re can not work with this terminal\n","red –Ω–µ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å —ç—Ç–∏–º —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–º")));
	    exit(1);
	}
    }
    templw.sg_flags=REDFLG(templw.sg_flags);
    if(lcasef) templw.sg_flags =REDFLGL(templw.sg_flags);
     if(lcasef && cvtout[COVIOPE] ) {
       vilcasef = 1; lcasef = 0;
     }
#ifdef TIOCSETA
    templw.sg_length=0;
    templw.sg_width=0;
/*
#ifdef Y_SIGSTOP
    templw.sg_suspc = templw.sg_dsuspc = -1;
#endif
#ifdef TIOCSLTC
    templw.sg_flushc = -1;
#endif
 */
#endif
    stty(2,&templw);
}

/*
 * ttcleanup()
 * –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–µ–∂–∏–º—ã —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
 */
ttcleanup()
{
    setscroll(&wholescreen,0);
    setatr(A_NORM);
    putcha(COFIN);
    dumpcbuf(0);
    printf("\n");
    stty(2,&templ);
#ifdef TIOCSLTC
    ioctl(2,TIOCSLTC, &oldltc);
#endif
#ifdef TIOCGETC
    ioctl(2,TIOCSETC, &tchars0);
#endif
}

/*
 * pcursor(col,lin) -
 * —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫—É—Ä—Å–æ—Ä –≤ —Ñ–∏–∑–∏—á–µ—Å–∫–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞
 * —ç–∫—Ä–∞–Ω–µ. –û—Ç–≤–µ—Ç 0, –µ—Å–ª–∏ –Ω–µ—Ç –ø—Ä—è–º–æ–π –∞–¥—Ä–µ—Å–∞—Ü–∏–∏
 */
pcursor(col,lin)
int col,lin;
{ 
    register char *c,sy;
    if ((c=curspos)==NIL) return 0;
    if (agoto) c=(*agoto)(curspos,col,lin);
    if (*c=='O') return(0);
    while ((sy = *c++))
    {
        if(!agoto&&(sy&0200)){ 
            if (sy&0100) sy=(sy&077)+col;  /* 300 - col */
            else sy=(sy&077)+lin;
        }                        /* 200 - lin */
        putchb(sy);
    } 
    return (1);
}

/* ===================
 * –†–∞–±–æ—Ç–∞ —Å –±—É—Ñ–µ—Ä–æ–º —Å–∏–º–≤–æ–ª–æ–≤
 * ===================
 */

char putcbuf[NPUTCBUF];
int iputcbuf=0;

/*
 * putcha(c) - –≤—ã–¥–∞—Ç—å —Å–∏–º–≤–æ–ª "c".
 * "c" –º–æ–∂–µ—Ç –±—ã—Ç—å –∫–æ–¥–æ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è.
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è 0, –µ—Å–ª–∏ –∑–∞–ø—Ä–æ—à–µ–Ω–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞
 */
putcha(c)
register int c;
{
    register char cr, *s;
    static short vicase=0;
    static short graphcase = 0;
    short vineed, needgraph;
    c &= 0377;
    if (c>=0 && c<=COMCOD) {
	if( c == COSTART) n0scroll = n1scroll = -1;
	if(!(s=cvtout[c])) return(0);
        while ((cr = *s++) != 0) putchb(cr);
        goto e;
    }
    if ((char)c == (char)(esc2)) c='#';
    if(vilcasef) {
      vineed = 1;
      if( c>= 'A' && c<= 'Z' ) c= c+'a'-'A';
      else if( RLPRO(c))  c= c+'–±'-'–ë';
      else if( c=='`')  c='\'';
      else if( c=='|')  c='!';
      else if( c=='}')  c=')';
      else if( c=='{')  c='(';
      else if( c=='~')  c='^';
      else vineed = 0;
      if( vineed != vicase) putcha((vicase=vineed)?COVIOPE:COVICLO);
      }
      if ( c >= G_START && c <= G_END)
	{
	if( c < G_START + gchars ) { c = g_table[(c) - G_START];
		needgraph = 1;
		}
		else {
		c = g0table[c-G_START];
		needgraph = 0;
		}
	 } else needgraph = 0;
	 if ( needgraph != graphcase ) putcha(COGSTART + graphcase);
	  graphcase = needgraph;
#ifdef RED_CYRILL
    if( Rcyflag ) {
	if (iscyrill(c) ) {
		if(!Cyout) putcha(COCYON);
			   Cyout= 1;
			   c = OUTT(c);
		}
	else if( !isanychr(c) && Cyout) {
			   putcha(COCYOFF);
			   Cyout=0;
	       }
    }
#endif
#ifdef LCASEO
    if ( lcasef0 && !vilcasef ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
#endif
    putcbuf[iputcbuf++] = c;
    if (iputcbuf >= NPUTCBUF) dumpcbuf();
e:
    return(1);
}

/*
 * putchb(c) -
 * –í—ã–≤–æ–¥ —Å–∏–º–≤–æ–ª–∞ –±–µ–∑ –≤ –±–µ–∑—É—Å–ª–æ–≤–Ω–æ–º —Ä–µ–∂–∏–º–µ
 */
putchb(c)
char c;
{
#ifdef LCASEO
    if ( lcasef0 ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
#endif
    putcbuf[iputcbuf++] = c;
    if (iputcbuf >= NPUTCBUF) dumpcbuf();
    return;
}

/*
 * putblanks(k) -
 * –í—ã–≤–æ–¥ —Å—Ç—Ä–æ–∫–∏ –ø—Ä–æ–±–µ–ª–æ–≤
 */
putblanks(k)
register int k;
{       cursorcol += k;
    setatr(A_NORM);
    while (k--) {
        putcbuf[iputcbuf++] = ' ';
        if(iputcbuf == NPUTCBUF)  dumpcbuf();
    }
    dumpcbuf(); return;
}

/*
 * dumpcbuf() -
 * –≤—ã—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–∞ –≤—ã–≤–æ–¥–∞
 */
dumpcbuf()
{
	if (iputcbuf != 0) write(2,putcbuf,iputcbuf);
	iputcbuf = 0;
}

setatr(atr)
int atr;
{
 register int i = NUMA(atr);
 if ( i != cur_atr && i <= COAOUT ) putcha(i);
 cur_atr = atr;
}

/*
 * readch()
 * –ß—Ç–µ–Ω–∏–µ –æ—á–µ—Ä–µ–¥–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ —Å —Ç–µ—Ä–º–∏–Ω–∞–ª–∞.
 * –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –∑–¥–µ—Å—å –∂–µ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞—é—Ç—Å—è –º–∞–∫—Ä–æ –∏
 * –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —á—Ç–µ–Ω–∏–µ –∏–∑ —Ñ–∞–π–ª–∞ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞.   –ü–æ—Å–ª–µ–¥–Ω–∏–µ –¥–≤–µ
 * —Ñ—É–Ω–∫—Ü–∏–∏ –±—É–¥—É—Ç —É–±—Ä–∞–Ω—ã –ø–æ–≤—ã—à–µ.
 * –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:
 * oldchar - —Å–∏–º–≤–æ–ª, –≤–æ–∑–≤—Ä–∞—â–µ–Ω–Ω—ã–π –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è –ø/–ø unread1()
 * ps_inmac - —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —á–∏—Ç–∞–µ–º–æ–µ –º–∞–∫—Ä–æ
 * ps_exin - —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —á–∏—Ç–∞–µ–º–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Å–∏–º–≤–æ–ª–∞
 * (*pf_wmac)() - —Ç–µ–∫—É—â–∞—è –∑–∞–ø–∏—Å—å –≤ –º–∞–∫—Ä–æ, –æ–Ω–∞ –∂–µ –æ—Ç—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç CCQUIT –≤ –∫–æ–Ω—Ü–µ
 * litchar - –ø—Ä–∏–∑–Ω–∞–∫ (—Å–ª–µ–¥. —Å–∏–º–≤–æ–ª - –ª–∏—Ç–µ—Ä–∞–ª)
 * rmacl(name) - –¥–∞–µ—Ç –º–∞–∫—Ä–æ –ø–æ –∏–º–µ–Ω–∏
 */
char *ps_inmac, *ps_exin;
int (*pf_wmac)();
char *rmacl();
static short litchar;
static int oldchar  = -1;
char *rmacl();

int readch()
{
#define GETSY1(c,g) if(read(inputfile,&c,1) != 1) goto g; else
	register int lc;
	char sy;
	if(oldchar != -1) { 
		lc = oldchar; 
		oldchar = -1; 
		return(lc); 
	}
	dumpcbuf();
rmacro:
    if( ps_inmac) {
	lc = (*ps_inmac++) &0377;
	if(*ps_inmac == 0) ps_inmac = NULL;
	goto w_macro;
	}
    if(inputfile && (lc = readfc()) != -1) goto w_macro;
r_exin:
    if( ps_exin) {
	lc = (*ps_exin++) &0377;
	if(*ps_exin == 0) ps_exin = NULL;
	goto w_proto;
	}
/*
 * –ß—Ç–µ–Ω–∏–µ –æ—á–µ—Ä–µ–¥–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞
 */
new:
#ifdef RED_CYRILL
    if (Rcyflag && Cyin != Cyout )
	{ putcha(COCYON + 1 - Cyin); Cyout = Cyin; dumpcbuf();}
#endif RED_CYRILL
    intrflag = 0;
    GETSY1(sy, readquit);
    lc = sy & 0377;
    if(litchar) {
	if( lc < 040)
		lc = (lc&037)|'@@';
	litchar = 0;
	goto w_proto;
	}
#ifdef RED_CYRILL
    if ( Rcyflag) {
	lc &= 0177;
	if( lc==CHA_RUS) {Cyin=1; goto new; }
	if( lc==CHA_LAT) {Cyin=0; goto new; }
	if( Cyin==1 && lc >= 040 && lc < 0177) lc = INTT(lc);
    }
#endif RED_CYRIILL
    if( ISCTRL(lc)) {
	int *i1,*i2, ts, k;
	i1=i2=0;
	ts=0;
	sy=lc;
	while ((k=findt(&i1,&i2,sy,ts++))== CONTF)
	{
	    GETSY1(sy,readquit);
	    if(sy&0200) sy = STASCII(cy40bit?(sy^040):sy);
	}
	if ( k== BADF) {
	    int flag=FREAD; putcha(COBELL); dumpcbuf();
	    ioctl(inputfile,TIOCFLUSH,&flag);goto new;
	}
	lc=k;
	if (lc == CCMAC) {
	    GETSY1(sy, readquit);
	    if(sy&0200) sy = STASCII(cy40bit?(sy^040):sy);
	    if(sy >= 'a' && sy <='z')
		{
		lc = (int)sy - 'a' + CCMAC+1;
		} else goto new;
	    }
	    goto w_proto;
    }
    /* ========================================================= */
    /* –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å–∏–º–≤–æ–ª–æ–≤ –ø—Ä–∏ –≤–≤–æ–¥–µ –≤ lcase */
    if((lcasef||latf) && (lc >= '@@'))
    {
#define LBUFWSY 5
	static char bufwsy[LBUFWSY+1];
        char bufr[2], *si=bufr, *so=bufwsy;
	int i;
#ifndef MNOS
#ifndef LCASEO
	if(lcasef&&(lc>=0300)) lc ^= 040; /* –∏–∑?–∑–∞ –¥—Ä–∞–π–≤–µ—Ä–∞*/
#endif
#endif
	i=1;
	bufr[0]=lc;
	exinss(&si, si+1, &so, &i, LBUFWSY-1);
	*so=0;
	lc=((int)bufwsy[0])&0377;
	if(so!= bufwsy+1) ps_exin = bufwsy+1;
    }
/*
 * –¢–æ—á–∫–∏ –≤—ã—Ö–æ–¥–∞ –∏–∑ –ø–æ–¥–ø—Ä–æ–≥—Ä–∞–º–º—ã
 */
w_proto:
    if(ttyfile > 0) {
	sy = lc;
	write(ttyfile,&sy, 1);
	}
/*
 * –û—Ç—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –∫–æ–¥–æ–≤
 */
    if(lc > CCMAC && lc <= CCEMAC)
	{
	ps_inmac = rmacl(lc);
	if(ps_inmac) goto rmacro;
	else goto new;
	}
    if( lc == CCCTRLQUOTE) {
	litchar = 1;
	}
w_macro:
    if(pf_wmac) {
	if( ((*pf_wmac)(lc))  == 0) goto new; /* –°–∏–º–≤–æ–ª —Å'–µ–ª–∏ */;
	}
    return(lc);
readquit:
    if(intrflag){
	lc=CCENTER;
	intrflag=0;
    }   else
	lc=CCQUIT;
    goto w_proto;
}

unread1(ch)
int ch;
{
oldchar = ch&0377;
}

static int isy0f = -1;
/*
 * readfc()
 * - –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–∏–º–≤–æ–ª–∞ –∏–∑ —Ñ–∞–π–ª–∞ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞
 *   –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è 0, –µ—Å–ª–∏ —Ñ–∞–π–ª –∫–æ–Ω—á–∏–ª—Å—è
 */
readfc()
{
    char sy1 = CCQUIT;
    register int lread1;
    do {
        lread1=isy0f;
        if ( intrflag || (read(inputfile,&sy1,1) !=1))
        {
            if(inputfile != ttyfile) close (inputfile);
            else  lseek(ttyfile,(long)(-1),1);
            inputfile=0;
            intrflag=0; 
            putcha(COBELL);
            dumpcbuf();
	    return (-1);
        }
        isy0f = ((int)sy1) & 0377;
    }
    while (lread1<0);
    return (lread1);
}

/*
 * intrup() -
 *       –æ–ø—Ä–æ—Å, –Ω–µ –±—ã–ª–æ –ª–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è.
 */
intrup()
{       
    char sy1;
    if( inputfile ){
        if(isy0f == CCINTRUP ){
            isy0f= -1;
            return(1);
        }
        else return(0);
    }
    else
    {
        if(intrflag){
            intrflag=0;
            sy1=CCINTRUP;
            write(ttyfile,&sy1,1);
            return(1);
        }
        return(0);
    }
}

#define CCDEL 0177
/* read2() -
 *     —Ñ—É–Ω–∫—Ü–∏—è, —á–∏—Ç–∞—é—â–∞—è –≤—Ö–æ–¥–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
 *     –±–µ–∑ –∏—Ö –∞–Ω–∞–ª–∏–∑–∞.  –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–∏
 *     –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –∫–ª–∞–≤–∏—à.
 */
read2()
{
    char c;
    register int lread1;
    if (inputfile && (lread1=readfc())!= -1) return(lread1);
    if (read(0,&c,1) != 1) {
        c=CCDEL;
        intrflag = 0;
    }
    c &= 0177;
    write(ttyfile,&c,1);
    return(c);
}

/*
 * writefile -
 * –ó–∞–ø–∏—Å–∞—Ç—å –∫–æ–º–∞–Ω–¥—É —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ –≤ —Ñ–∞–π–ª –ø—Ä–æ—Ç–æ–∫–æ–ª–∞
 */

writefile(code1,str,code2)
int code1, code2;
char *str;
{
	char cd1=code1, cd2=code2;
	write(ttyfile,&cd1,1);
	for(;*str;str++) write(ttyfile,str,1);
	write(ttyfile,&cd2,1);
}

/*
 * findt (&fb,&fe,sy,ns) -
 * –ü–æ–∏—Å–∫ –∫–æ–¥–∞ –∫–ª–∞–≤–∏—à–∏.
 * struct ex_int * (fb , fe) = NULL –ø—Ä–∏ –ø–æ–¥–∞—á–µ
 * –ø–µ—Ä–≤–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ —Å –¥–∞–Ω–Ω–æ–π –∫–ª–∞–≤–∏—à–∏.
 * –î–∞–ª—å—à–µ –æ–Ω–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –∫–æ–¥–∞.
 * –ö–æ–¥—ã –æ—Ç–≤–µ—Ç–∞:
 * CONTF - –¥–∞–π —Å–ª–µ–¥—É—é—â–∏–π —Å–∏–º–≤–æ–ª,
 * BADF  - —Ç–∞–∫–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –Ω–µ—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ,
 * >=0   - –∫–æ–¥ –∫–æ–º–∞–Ω–¥—ã.
 */
short kioutf;
/*VARARGS*/
findt (fb,fe,sy,ns)
struct ex_int **fb, **fe; 
char sy; 
int ns;
{ 
    char sy1; 
    register struct ex_int  *fi;
    fi=( *fb? *fb:inctab);  
    *fb=0;
    if (sy==0) return BADF;
    if(kioutf&& (sy&0100)) sy |= 0240; /* –ù–µ —Ä–∞–∑–ª–∏—á–∞–µ–º —Ä–µ–≥–∏—Å—Ç—Ä –±—É–∫–≤ */
    for (;(fi!= *fe); fi++ )
    {
        if (!(*fe) && !(fi->excc) ) goto exit;
        sy1=fi->excc[ns];
        if(kioutf&& (sy1&0100)) sy1 |= 0240; /* –ù–µ —Ä–∞–∑–ª–∏—á–∞–µ–º —Ä–µ–≥–∏—Å—Ç—Ä –±—É–∫–≤ */
        if ( *fb) { 
            if (sy!=sy1) goto exit;
        }
        else { 
            if (sy==sy1) {  
                *fb=fi;
            }
        }
    }
exit: 
    *fe=fi; /* for "addkey" */
    if (! *fb) return BADF;
    fi= *fb;
    if(fi->excc[ns+1]) return CONTF;
    return ( fi->incc);
}

/* –¢–µ—Å—Ç findt
 main()
  { char *s = "\017abz"; int i,j,k,l,m,is;
	i=j=k=l=m=0;
	for(is=0;*s; is++)
	{ k=findt(&i,&j,*s++,l++); if(k!=CONTF) goto ex1; }
ex1:   printf(" k= %d is= %d pt %o %o ", k,is,i,j);
  }
 t(i) int i; {return;}
 */

/*
 * addkey(cmd,key) -
 * –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–π —É–ø—Ä–∞–≤–ª—è—é—â–µ–π –∫–ª–∞–≤–∏—à–∏
 *      –≤ —Ç–∞–±–ª–∏—Ü—É –∫–æ–¥–æ–≤
 */
extern int nfinc; /* —á–∏—Å–ª–æ —Å–≤–æ–±–æ–¥–Ω—ã—Ö –º–µ—Å—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ */
addkey(cmd,key)
int cmd; 
char *key;
{ 
    struct ex_int *fb,*fe; 
    register struct ex_int *fw;
    register int ns,i;
    ns=0; 
    fb = fe = 0;
    while((i=findt(&fb,&fe,key[ns],ns))==CONTF && key[ns++]);
    if(i != BADF)
    {
        telluser(DIAG("key redefined","–ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ"),0);
        fw = fb; 
        goto retn;
    }
    /* –ö–æ–¥ –Ω–æ–≤—ã–π = –Ω—É–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É */
    if (!nfinc) {
        error(DIAG("too many key's","–º–Ω–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π"));
        return(0);
    }
    fw = fe;nfinc--;
    while((fw++)->excc);
    do{
        *fw = *(fw-1);
    } 
    while(--fw != fe);
retn:   
#ifdef TEST
test("addkey out");
#endif
	fw ->excc = key; 
	fw->incc = cmd;
	return(1);
}
#ifdef TEST
test(s) char *s;
{printf("test: %s\n",s); return(0);}
#endif

/*
 * scroll(n,bl) - –ø—Ä–æ–∫—Ä—É—Ç–∏—Ç—å —ç–∫—Ä–∞–Ω –Ω–∞ n —Å—Ç—Ä–æ–∫ –≤–≤–µ—Ä—Ö (–≤–Ω–∏–∑), –Ω–∞—á–∏–Ω–∞—è —Å–æ
 * —Å—Ç—Ä–æ–∫–∏ bl. bl <0 == bl = -1-bl,–Ω–æ –æ—Å–æ–±—ã–π —Å–ª—É—á–∞–π - –Ω–µ –ø—Ä–æ–∫—Ä—É—Ç–∏—Ç—å, –∞ —É–¥–∞–ª–∏—Ç—å
 * –≤—ã–¥–∞–µ—Ç—Å—è 0, –µ—Å–ª–∏ –Ω–µ —Å–¥–µ–ª–∞–Ω–æ, –∏–Ω–∞—á–µ 1
 */
scroll(n,bl)
int n,bl;
{
	register int i;
	int dll,ill,nl;
	int no_sf;      /* –§–ª–∞–≥ - –ø—Ä–∏–∑–Ω–∞–∫ –∑–∞–ø—Ä–µ—Ç–∞ —Å–¥–≤–∏–≥–∞ –ø–æ sf */
#define PUTCC(c,n) for(i= n;i>0;i--) putcha(c)
	if(!(curport->flags&WF_ROLL)) {
		/*
		 * –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∏–∑–Ω–∞–∫ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ roll
		 */
		i=WF_NROLL;
		if(!can_scroll) goto ex;
		if(curport->lmarg != 0 || curport->rmarg != wholescreen.rmarg) goto ex;
		if(can_scroll == ROLL_SF
		    && (curport->tmarg != 0
		    || curport->bmarg != wholescreen.bmarg - NPARAMLINES)) goto ex;
		i = WF_YROLL;
ex: 
		curport->flags |= i;
	}
	if(!(curport->flags & WF_YROLL) ) return(0);
	if ( n == 0 ) return(1);
	no_sf = 0;
	if (bl < 0 ) { no_sf = 1; bl = -bl -1; }
	if( n+bl>curport->btext-2 || -n+bl > curport->btext-2) return(0);
	switch(can_scroll) {
	case ROLL_CS:
		if(!setscroll(curport,bl))  return(0);
		if(n>0) {
			poscursor(0, curport->btext);
			PUTCC(COSRFWD,n);
		} 
		else {
			poscursor(0,bl);
			PUTCC(COSRBAK, -n);
		}
		if (bl) setscroll(curport,0);
		break;
	case ROLL_IL:
		if(n>0) {
			nl=n;
			dll=bl;
			ill=curport->btext - nl+1;
		}
		else
		{
			nl = -n;
			dll = curport->btext - nl+1;
			ill=bl;
		}
		poscursor(0,dll);
		PUTCC(CODELIN,nl);
		poscursor(0,ill);
		PUTCC(COILINE,nl);
		break;
	case ROLL_SF:
		if(no_sf) return(0);
		{
			register struct viewport *w;
			w = curport;
			if ( n > 0 )
			{
				switchport(&wholescreen);
				poscursor(0,wholescreen.bmarg);
				PUTCC(COSRFWD,n);
				switchport(w);
				if(need_box != 2 )
				{
					poscursor(-w->ltext, w->btext-n+1);
					putcha(COCLSCR);
				}
			} 
			else {
				if(need_box != 2 )
				{
					poscursor(-w->ltext,w->btext+n+1);
					putcha(COCLSCR);
				}
				switchport(&wholescreen);
				poscursor(0,0);
				for(i= -n; i; i--)
					putcha(COCLLIN), putcha(COSRBAK);
				switchport(w);
			}
			need_box = (n==1||n== -1)?1:2;
			new_info = 1;
			break;
		}
	default: 
		return(0);
	}
	shiftview(bl,n);
	return(1);
}

/*
 * setscroll(viewp,begl) - —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –≥—Ä–∞–Ω–∏—Ü —Ä–æ–ª–ª–∏–Ω–≥–∞ —ç–∫—Ä–∞–Ω–∞
 * –Ω–∞ –æ–±–ª–∞—Å—Ç—å text –¥–∞–Ω–Ω–æ–≥–æ –æ–∫–Ω–∞
 * –Ω–∞—á–∏–Ω–∞—è —Å–æ —Å—Ç—Ä–æ–∫–∏ begl
 */
setscroll(viewp,begl)
register struct viewport *viewp;
{
	register char *c;
	extern char *tgoto();
	struct viewport *cp;
	register l0, l1;
	l0 = viewp->ttext;
	l1 = viewp->btext + l0;
	l0 += begl;
	if (l0 >= l1) return(0); /* –¢–µ—Ä–º–∏–Ω–∞–ª—ã –Ω–µ –¥–æ–ø—É—Å–∫–∞—é—Ç cs –Ω–∞ 1 —Å—Ç—Ä–æ–∫—É */
	if(n0scroll==l0 && n1scroll==l1)
		return(1);
	if( !ch_scroll) return(0);
	c= tgoto(ch_scroll,  l1, l0);
	if(!c) return(0);
	cp = curport;
	switchport(&wholescreen);
	while(*c) putchb(*c++);
	putcha(COHO);
	cursorcol = cursorline = 0;
	switchport(cp);
	n0scroll = l0;
	n1scroll = l1;
	return(1);
}
@


4.5
log
@–û—á–µ—Ä–µ–¥–Ω–∞—è –ø—Ä–∞–≤–∫–∞ –≤ —Ä–æ–ª–ª–∏—Ä–æ–≤–∞–Ω–∏–∏.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 4.4 88/04/07 12:02:13 alex Exp $
d6 3
d821 1
d832 1
d837 1
a837 1
	switchport(viewp);
@


4.4
log
@–ò—Å–ø—Ä–∞–≤–∏–ª–∏ –æ—à–∏–±–∫—É –≤ —Ä–∞–±–æ—Ç–µ setscroll.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 4.3 88/04/04 22:16:14 alex Exp $
d6 3
d717 1
d735 2
a739 1
		if(bl<0) bl = -1-bl;
a751 1
		if(bl<0) bl = -1-bl;
d769 1
a769 1
		if(bl != 0) return(0);
@


4.3
log
@–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ –≤ —Ä–∞–±–æ—Ç–µ –ø—Ä–∏ —Ä–∞—Å—â–µ–ø–ª–µ–Ω–∏–∏ —Å—Ç—Ä–æ–∫–∏ (—Ä–µ–∂–∏–º CS).
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 4.2 88/03/31 22:50:29 alex Exp $
d6 3
d818 1
@


4.2
log
@–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ –Ω–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ –≠–ª–µ–∫—Ç—Ä–æ–Ω–∏–∫–∞.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 4.1 88/03/31 22:06:09 alex Exp $
d6 3
d301 1
a301 1
    if (iputcbuf == NPUTCBUF) dumpcbuf();
d317 1
a317 1
    if (iputcbuf == NPUTCBUF) dumpcbuf();
d732 1
a732 2
		if(n0scroll != curport->ttext || n1scroll != curport->btext)
			if(!setscroll(curport,bl))  return(0);
d741 1
d811 6
d818 1
a818 1
	c= tgoto(ch_scroll,  viewp->ttext + viewp->btext, viewp->ttext+begl);
d825 2
a828 1

@


4.1
log
@–í–µ—Ä—Å–∏—è 4.1 - –æ–±–∫–∞—Ç–∫–∞ –Ω–∞ UTEC, –°–ú
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.17 88/03/30 17:25:07 alex Exp $
d6 3
d700 1
a700 1
 * —Å—Ç—Ä–æ–∫–∏ bl
d728 1
d741 1
@


3.17
log
@–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ –≤ readch. –í–≤–µ–¥–µ–Ω—ã —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è/–≤—Å—Ç–∞–≤–∫–∏
—Å—Ç—Ä–æ–∫ –Ω–∞ —ç–∫—Ä–∞–Ω–µ —á–µ—Ä–µ–∑ ChangeScroll/InsertLine-DeleteLine.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.1.2.5 87/07/09 20:44:11 alex Exp $
d6 4
d714 1
a714 1
		    && (curport->tmarg != 0  || bl != 0
d754 1
@


3.16
log
@–ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –æ—à–∏–±–∫–∏ –≤ —Ä–µ–∂–∏–º–µ vilcase –∏ –º–µ–ª–æ—á–∏ –¥–ª—è vt-200
@
text
@d2 2
a3 2
 *      –†–µ–¥–∞–∫—Ç–æ—Ä RED. –ò–ê–≠ –∏–º. –ò.–í. –ö—É—Ä—á–∞—Ç–æ–≤–∞, –û–° –î–ï–ú–û–°
 *       $Header: S.ttyio.c,v 3.15 87/06/09 19:45:28 alex Exp $
d6 18
d124 1
a124 1
    ioctl(0,TIOCGETC, &tchars0);
d128 1
a128 1
    ioctl(0,TIOCSETC, &tcharsw);
d131 1
a131 1
    ioctl(0,TIOCGLTC,&tmpltc);
d134 1
a134 1
    ioctl(0,TIOCSLTC,&tmpltc);
d136 1
a136 1
    gtty(0,&templ);
d176 1
a176 1
    stty(0,&templw);
d185 6
a190 1
    stty(0,&templ);
d192 1
a192 1
    ioctl(0,TIOCSLTC, &oldltc);
d195 1
a195 1
    ioctl(0,TIOCSETC, &tchars0);
d236 1
a236 1
char c;
d240 6
a245 5
    short vineed;
    cr=c & 0177;
    if (cr>=0 && cr<=COMCOD) {
	if( cr == COSTART) n0scroll = n1scroll = -1;
        if(!(s=cvtout[cr])) return(0);
d262 12
d318 1
d336 7
d345 2
a346 2
 * read1()
 * –ß—Ç–∞–Ω–∏–µ –æ—á–µ—Ä–µ–¥–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ —Å —Ç–µ—Ä–º–∏–Ω–∞–ª–∞.
d350 7
a356 1
 * –û—Ç–≤–µ—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç –≤ lread1.
d358 2
d361 5
a365 6
#define LBUFWSY 5
static char *sy0, knockdown=0, bufwsy[LBUFWSY];
extern char escch1, in0tab[];
int
read1()
#define GETSY1 if(read(inputfile,&sy1,1)!=1) goto readquit;
d367 25
a391 28
    char sy1;
    int i,cntf=0;
    register int *lr1 = &lread1;
#define lread1 (*lr1)   /* –î–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è */
    dumpcbuf();
    /* –ï—Å–ª–∏ –æ—Å—Ç–∞–ª—Å—è –Ω–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–º —Å–∏–º–≤–æ–ª */
    if (lread1 != -1) goto retnl;
    /* –ï—Å–ª–∏ –µ—â–µ –Ω–µ –∫–æ–Ω—á–∏–ª–æ—Å—å –º–∞–∫—Ä–æ-—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ */
rmac:
    if (symac) {
        lread1= *symac++;
        if(*symac==0) symac=0;
        goto retnl;
    }
    /* –ï—Å–ª–∏ –∏–¥–µ—Ç —á—Ç–µ–Ω–∏–µ –∏–∑ —Ñ–∞–π–ª–∞ */
    if (inputfile!=0 && readfc())
        goto retnm;
    /*
     * –ù–∏–∂–µ - —Ç–æ, —á—Ç–æ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ —Ç–µ—Ä–º–∏–Ω–∞–ª—É
     * =====================================
     */
    /* –ë—ã–ª–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏ —Å–∏–º–≤–æ–ª—ã –Ω–µ –∫–æ–Ω—á–∏–ª–∏—Å—å */
    if (sy0!=0) {
        lread1= *sy0++;
        if(*sy0==0) sy0=0;
        goto retn;
    }
    /* –ß—Ç–µ–Ω–∏–µ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã */
d397 9
a405 9
    intrflag=0;
    GETSY1;
    /* –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª –Ω–µ —É–ø—Ä–∞–≤–ª—è—é—â–∏–π */
    lread1=sy1;  
    if(lread1==0177) {
        lread1=CCBACKSPACE; 
        goto readycchr;
    }
    lread1 &= 0377;
d408 4
a411 4
	lread1 &= 0177;
	if( lread1==CHA_RUS) {Cyin=1; goto new; }
	if( lread1==CHA_LAT) {Cyin=0; goto new; }
	if( Cyin==1 && lread1 >= 040) lread1 = INTT(lread1);
d414 24
a437 4
    if ((lread1&0177) > 037) goto readychr;
    if (knockdown) {
        lread1 += 0100;
        goto readycchr;
a438 60
    /* –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª - —Å–ø–µ—Ü. –ø—Ä–∏–∑–Ω–∞–∫? */
    if (lread1==escch1)
    {
        GETSY1;
        switch (sy1)
        {
        case '\177': 
            lread1=CCQUIT; 
            goto readycchr;
        case '+':;
        case ';':
            lread1=CCPLLINE;
            goto readycchr;
        case '-':;
        case '=':
            lread1=CCMILINE;
            goto readycchr;
        case '.':;
        case '>':
            lread1=CCGOTO;
            goto readycchr;
        case ' ':
            lread1=CCENTER;
            goto readycchr;
        case '$':
rmacname:               
            GETSY1; 
	    if(sy1&0200) sy1 = STASCII(cy40bit?(sy1^040):sy1);
            if(sy1 >= 'a' && sy1 <='z')
	    {
		lread1 = (int)sy1 - 'a' + CCMAC+1;
                goto readycchr;
            }
            goto new;
        default:
            ;
        }
        lread1=((int)sy1)&037;
        goto corrcntr;
    }
    /* –í–µ–¥–µ–Ω —É–ø—Ä–∞–≤–ª—è—é—â–∏–π —Å–∏–º–≤–æ–ª - –∏—â–µ–º –∫–æ–º–∞–Ω–¥—É –≤ —Ç–∞–±–ª–∏—Ü–µ */
    {
        int *i1,*i2, ts, k;
        i1=i2=0;
        ts=0;
        sy1=lread1;
        while ((k=findt(&i1,&i2,sy1,ts++))== CONTF)
        {
            GETSY1;
	    if(sy1&0200) sy1 = STASCII(cy40bit?(sy1^040):sy1);
        }
        if ( k== BADF) {
            if (ts==1) goto corrcntr;
	    else { int flag=FREAD; putcha(COBELL); dumpcbuf();
		 ioctl(inputfile,TIOCFLUSH,&flag);goto new;}
        }
        lread1=k;  
        if (lread1 == CCMAC) goto rmacname;
        goto readycchr;
    }
d440 2
a441 11
corrcntr:
    if (lread1>0 && lread1<=BT) lread1=in0tab[lread1-1];
readycchr:
    cntf=1;
readychr:
    if (lread1==-1) goto new;
    if (lread1==0177) {
        cntf=1;
    }
    knockdown=0;
    if (lread1==CCCTRLQUOTE)
d443 2
a444 4
        knockdown=1;
    }
    if(!cntf && (lcasef||latf) && (lread1>='@@'))
    {
d446 1
d449 1
a449 1
        if(lcasef&&(lread1>=0300)) lread1 ^= 040; /* –∏–∑?–∑–∞ –¥—Ä–∞–π–≤–µ—Ä–∞*/
d452 6
a457 6
        i=1;
        bufr[0]=lread1;
        exinss(&si, si+1, &so, &i, LBUFWSY-1);
        *so=0;
        lread1=((int)bufwsy[0])&0377;
        if(so!= bufwsy+1) sy0=bufwsy+1;
d459 25
a483 12
retn:
    sy1=lread1;
    write (ttyfile,&sy1,1); /* ATTENSION - ONLY 8 BIT */
    /*
     * –ö–æ–Ω–µ—Ü —Ç–æ–≥–æ, —á—Ç–æ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ —Ç–µ—Ä–º–∏–Ω–∞–ª—É (–¥–æ quit).
     * ================================================
     */
retnm:
    if( lread1 >CCMAC && lread1 <= CCMAC+1+'z'-'a' && (symac=rmacl(lread1)))
        goto rmac;
retnl:
    return (lread1);
d486 5
a490 6
        lread1=CCENTER;
        intrflag=0;
        goto readycchr;
    }
    lread1=CCQUIT;
    goto readycchr;
a491 1
#undef lread1
d493 6
d508 1
d519 1
a519 1
            return 0;
d524 1
a524 1
    return (1);
d562 2
a563 1
    if (inputfile && readfc()) return(lread1);
d692 2
a693 1
 * scroll(n) - –ø—Ä–æ–∫—Ä—É—Ç–∏—Ç—å —ç–∫—Ä–∞–Ω –Ω–∞ n —Å—Ç—Ä–æ–∫ –≤–≤–µ—Ä—Ö (–≤–Ω–∏–∑)
d696 2
a697 2
scroll(n)
int n;
d710 1
a710 1
		    && (curport->tmarg != 0
d718 1
a718 1
	if( n>curport->btext-2 || -n > curport->btext-2) return(0);
d722 1
a722 1
			if(!setscroll(curport))  return(0);
d728 1
a728 1
			poscursor(0,0);
d735 1
a735 1
			dll=0;
d742 1
a742 1
			ill=0;
d784 1
a784 1
	shiftview(0,n);
d789 1
a789 1
 * setscroll(viewp) - —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –≥—Ä–∞–Ω–∏—Ü —Ä–æ–ª–ª–∏–Ω–≥–∞ —ç–∫—Ä–∞–Ω–∞
d791 1
d793 1
a793 1
setscroll(viewp)
d799 1
a799 1
	c= tgoto(ch_scroll,  viewp->ttext + viewp->btext, viewp->ttext);
@


3.15
log
@–î–æ–±–∞–≤–ª–µ–Ω roll –¥–ª—è —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–≤ —Å sr/sf –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
 —Ç–∞–±—É–ª—è—Ü–∏–π –≤ —Ä–µ–∂–∏–º–µ -t + –≤—Å—è–∫–∞—è –º–µ–ª–æ—á—å
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.14 87/06/05 23:48:29 alex Exp $
d6 3
d86 3
a106 1
/*  printf("TIOCGETC %o\n", &tchars0);  */
d109 1
a109 1
    tcharsw.t_eofc=tcharsw.t_quitc= -1;
a110 1
/*  printf("TIOCSETC %o\n", &tcharsw);  */
d112 6
d149 1
d153 1
a153 1
#ifdef LFLUSHO
d156 1
a158 1
/*  printf("STTY %o\n", &templw);       */
d168 3
d225 1
a225 1
    if(c == esc2) c = '#';
d252 1
a252 1
    if ( lcasef0 ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
d741 2
a742 1
				if(need_box != 2) {
d748 2
a749 1
				if(need_box != 2) {
@


3.14
log
@–î–æ–±–∞–≤–ª–µ–Ω roll –¥–ª—è —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–≤ —Å sr/sf –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
 —Ç–∞–±—É–ª—è—Ü–∏–π –≤ —Ä–µ–∂–∏–º–µ -t + –≤—Å—è–∫–∞—è –º–µ–ª–æ—á—å
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.13 87/06/04 23:41:52 alex Exp $
d6 4
d142 2
d145 1
d211 1
d727 4
a730 2
				poscursor(-w->ltext, w->btext-n+1);
				putcha(COCLSCR);
d733 4
a736 2
				poscursor(-w->ltext,w->btext+n+1);
				putcha(COCLSCR);
@


3.13
log
@Scroll on -sr- or -al/dl- added
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.12 87/04/21 22:46:30 alex Exp $
d6 3
d682 1
a682 1
		      if(!setscroll(curport))  return(0);
d709 26
@


3.12
log
@Debug
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.11 87/04/21 22:28:57 alex Exp $
d6 3
d10 1
a10 1
 * iSPRAWLENA O[IBKA W writefile.
d196 1
d648 85
@


3.11
log
@iSPRAWLENA O[IBKA W writefile.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.10 87/04/02 18:29:44 alex Exp $
d6 3
a77 1
#undef printf
d91 1
a91 1
    printf("TIOCGETC %o\n", &tchars0);
d96 1
a96 1
    printf("TIOCSETC %o\n", &tcharsw);
d99 1
a99 1
    printf("GTTY %o\n", &templ);
d134 1
a134 1
    printf("STTY %o\n", &templw);
@


3.10
log
@–í–µ—Ä—Å–∏—è –¥–ª—è Utec —Å–ª–∏—Ç–∞ —Å –≤–µ—Ä—Å–∏–µ–π —Å –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º –ø—Ä–æ–ø–∏—Å–Ω—ã—Ö –±—É–∫–≤
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.9 87/04/01 19:14:19 alex Exp $
d6 3
d75 2
d83 1
a83 1
    struct sgttyb templw;
d85 1
a85 1
    struct tchars tcharsw;
d89 1
d94 1
d97 1
d132 1
d534 2
a535 1
	write(ttyfile,&code1,1);
d537 1
a537 1
	write(ttyfile,&code2,1);
@


3.9
log
@–ø—Ä–æ–≤–µ–¥–µ–Ω—ã –ø—Ä–∞–≤–∫–∏ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –∑–∞–≥–ª–∞–≤–Ω—ã—Ö –±—É–∫–≤ –ø–æ vs
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.8 86/11/25 08:06:26 alex Exp $
d6 3
a81 11
    if(atcread)
    {   register int i;
	i=(*atcread)();
	if(i) {
	    printf1((i==1?
	    DIAG("unknown term capabilities\n please, type \n  TERM=<type>;export TERM \n and repeat red\n","–ù–µ –∑–∞–¥–∞–Ω–æ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π —Ç–µ—Ä–º–∏–Ω–∞–ª–∞, \n –Ω–∞–±–µ—Ä–∏—Ç–µ TERM=—Ç–∏–ø;export TERM –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤—ã–∑–æ–≤"):
	    DIAG("re can not work with this terminal\n","red –Ω–µ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å —ç—Ç–∏–º —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–º")));
	    exit(1);
	}
    }
    atcread = (int (*)())NULL;
d100 11
d113 3
a115 3
    if(lcasef && cvtout[COVIOP] ) {
	vilcasef = 1; lcasef = 0;
    }
d187 24
a210 11
	vineed = 1;
	if( c>= 'A' && c<= 'Z' ) c= c+'a'-'A';
	else if( RLPRO(c))  c= c+'–±'-'–ë';
	else if( c=='`')  c='\'';
	else if( c=='|')  c='!';
	else if( c=='}')  c=')';
	else if( c=='{')  c='(';
	else if( c=='~')  c='^';
	else vineed = 0;
	if( vineed != vicase) putcha((vicase=vineed)?COVIOP:COVICL);
	}
d212 1
a212 2
    else
    if ( lcasef0  ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
d274 1
a274 1
#define GETSY1 if(read(inputfile,&sy1,1)!=1) goto readquit;if(rawf)sy1=sy1&0177;
d305 4
d318 8
d360 2
a361 2
            { 
                lread1 = (int)sy1 - 'a' + CCMAC+1;
d406 1
a406 1
    if(!cntf && !rawf && (lcasef||latf) && (lread1>='@@'))
d541 1
a541 1
char kioutf;
@


3.8
log
@–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ ioctl(..,TIOCFLUSH,&flag)
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.7 86/10/29 02:46:37 root Exp $
d6 3
d68 1
d110 3
d175 2
d183 12
d196 2
a197 1
    if ( lcasef0 ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
@


3.7
log
@–ü—Ä–∏ –Ω–µ–≤–µ—Ä–Ω–æ–π escape-–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Å–±—Ä–∞—Ç—ã–≤–∞–µ–º –≤—Å—é –æ—á–µ—Ä–µ–¥—å –≤–≤–æ–¥–∞.
–°–¥–µ–ª–∞–Ω–æ –¥–ª—è –±–æ—Ä—å–±—ã —Å –ø—Ä–æ–ø–∞–¥–∞–Ω–∏–µ–º —Å–∏–º–≤–æ–ª–æ–≤.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.6 86/10/14 23:02:52 alex Exp $
d6 4
d335 2
a336 1
	    else { ioctl(inputfile,TIOCFLUSH,FREAD);goto new;}
@


3.6
log
@–ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –æ—à–∏–±–∫–∏ —Å: RUSDIAG (–Ω–µ –æ–ø–∏—Å–∞–Ω latdiag), –∏ —Å LCASEO
(KI40BIT –Ω—É–∂–Ω–æ –∑–∞–¥–∞–≤–∞—Ç—å —Ç–∞–∫, —á—Ç–æ–±—ã –ø—Ä–∏ lcasef –±—ã–ª–∞ 1).
–í –°–ú-1700 –±—ã–ª–æ 2 –æ—à–∏–±–∫–∏, –≤ —Ä–µ–∑. –≤—Å–µ —Ä–∞–±–æ—Ç–∞–ª–æ –Ω–∞ LCASE –ø—Ä–∞–≤–∏–ª—å–Ω–æ.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.5 86/09/19 21:39:35 alex Exp $
d6 5
d37 2
d331 1
a331 1
            else goto new;
@


3.5
log
@
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.4 86/09/19 19:59:39 alex Exp $
d6 3
d51 3
a53 1

d85 1
a85 1
    lcasef=LCFLG(templ.sg_flags);
d90 3
d164 1
a164 1
    if ( lcasef ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
d180 1
a180 1
    if ( lcasef ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
d298 1
a298 1
            if(sy1&0200) sy1 = STASCII(sy1);
d320 1
a320 1
            if(sy1&0200) sy1= STASCII(sy1);
@


3.4
log
@–í–µ—Ä—Å–∏—è –¥–ª—è –°–ú-1700
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.3 86/08/04 20:55:13 alex Exp $
d6 3
d69 1
d82 1
d90 3
@


3.3
log
@Bepqh dk LMNQ/DELNQ 2
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.2 86/07/24 19:07:48 alex Exp $
d5 4
a8 1
 *      $Log:   S.ttyio.c,v $
d33 2
a34 2
#ifdef TIOCSETB /* –ü—Ä–∏–∑–Ω–∞–∫ –î–ï–ú–û–°-2 */
#define sgttyb sgttyb1
d77 1
d147 4
a150 1
    putcbuf[iputcbuf++] =( rawf || latf || lcasef ? c&0177 : c );
d163 4
a166 1
    putcbuf[iputcbuf++] = c&0177;
d333 1
d335 1
@


3.2
log
@–û–±'–µ–¥–∏–Ω–µ–Ω—ã –≤–µ—Ä—Å–∏–∏ —Ç–µ–∫—Å—Ç–æ–≤ –¥–ª—è –ï–° –∏ –°–ú
@
text
@d3 1
a3 1
 *       $Header: r.ttyio.c,v 3.1 86/04/20 23:43:21 alex Exp $
d5 4
a8 1
 *      $Log:	r.ttyio.c,v $
d11 1
a11 1
 * 
d14 1
a14 1
 * 
d30 4
a40 3
#ifdef TIOCGETC
struct tchars tchars0;
#endif
d52 1
d55 7
a61 7
        i=(*atcread)();
        if(i) {
            printf1((i==1?
            DIAG("unknown term capabilities\n please, type \n  TERM=<type>;export TERM \n and repeat red\n","–ù–µ –∑–∞–¥–∞–Ω–æ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π —Ç–µ—Ä–º–∏–Ω–∞–ª–∞, \n –Ω–∞–±–µ—Ä–∏—Ç–µ TERM=—Ç–∏–ø;export TERM –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤—ã–∑–æ–≤"):
            DIAG("re can not work with this terminal\n","red –Ω–µ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å —ç—Ç–∏–º —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–º")));
            exit(1);
        }
d63 1
@


3.1
log
@–ë–∞–∑–æ–≤–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –ï–°.
@
text
@d7 3
d18 1
a18 1
#include "r.tele.h"
d48 10
d421 4
d426 8
@


3.1.2.1
log
@Start revision for red/4
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.16 87/06/12 18:07:21 alex Exp $
d5 1
a5 50
 *      $Log:	S.ttyio.c,v $
 * Revision 3.16  87/06/12  18:07:21  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –æ—à–∏–±–∫–∏ –≤ —Ä–µ–∂–∏–º–µ vilcase –∏ –º–µ–ª–æ—á–∏ –¥–ª—è vt-200
 * 
 * Revision 3.15  87/06/09  19:45:28  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ —Ä–∞–±–æ—Ç–∞ —Å tty ~ VT200 –∏ 15-–ò–≠-0013
 * 
 * Revision 3.14  87/06/05  23:48:29  alex
 * –î–æ–±–∞–≤–ª–µ–Ω roll –¥–ª—è —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–≤ —Å sr/sf –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
 *  —Ç–∞–±—É–ª—è—Ü–∏–π –≤ —Ä–µ–∂–∏–º–µ -t + –≤—Å—è–∫–∞—è –º–µ–ª–æ—á—å
 * 
 * Revision 3.13  87/06/04  23:41:52  alex
 * Scroll on -sr- or -al/dl- added
 * 
 * Revision 3.12  87/04/21  22:46:30  alex
 * Debug
 * 
 * Revision 3.11  87/04/21  22:28:57  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ –≤ writefile.
 * 
 * Revision 3.10  87/04/02  18:29:44  alex
 * –í–µ—Ä—Å–∏—è –¥–ª—è Utec —Å–ª–∏—Ç–∞ —Å –≤–µ—Ä—Å–∏–µ–π —Å –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º –ø—Ä–æ–ø–∏—Å–Ω—ã—Ö –±—É–∫–≤
 * 
 * Revision 3.9  87/04/01  19:14:19  alex
 * Revision for Utec: Cs, Ce, Ct, hR
 * 
 * Revision 3.8  86/11/25  08:06:26  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ ioctl(..,TIOCFLUSH,&flag)
 * 
 * Revision 3.7  86/10/29  02:46:37  root
 * –ü—Ä–∏ –Ω–µ–≤–µ—Ä–Ω–æ–π escape-–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Å–±—Ä–∞—Ç—ã–≤–∞–µ–º –≤—Å—é –æ—á–µ—Ä–µ–¥—å –≤–≤–æ–¥–∞.
 * –°–¥–µ–ª–∞–Ω–æ –¥–ª—è –±–æ—Ä—å–±—ã —Å –ø—Ä–æ–ø–∞–¥–∞–Ω–∏–µ–º —Å–∏–º–≤–æ–ª–æ–≤.
 * 
 * Revision 3.6  86/10/14  23:02:52  alex
 * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –æ—à–∏–±–∫–∏ —Å: RUSDIAG (–Ω–µ –æ–ø–∏—Å–∞–Ω latdiag), –∏ —Å LCASEO
 * (KI40BIT –Ω—É–∂–Ω–æ –∑–∞–¥–∞–≤–∞—Ç—å —Ç–∞–∫, —á—Ç–æ–±—ã –ø—Ä–∏ lcasef –±—ã–ª–∞ 1).
 * –í –°–ú-1700 –±—ã–ª–æ 2 –æ—à–∏–±–∫–∏, –≤ —Ä–µ–∑. –≤—Å–µ —Ä–∞–±–æ—Ç–∞–ª–æ –Ω–∞ LCASE –ø—Ä–∞–≤–∏–ª—å–Ω–æ.
 * 
 * Revision 3.5  86/09/19  21:39:35  alex
 * 
 * 
 * Revision 3.4  86/09/19  19:59:39  alex
 * –í–µ—Ä—Å–∏—è –¥–ª—è –°–ú-1700
 * 
 * Revision 3.3  86/08/04  20:55:13  alex
 * Bepqh dk LMNQ/DELNQ 2
 * 
 * Revision 3.2  86/07/24  19:07:48  alex
 * –û–±'–µ–¥–∏–Ω–µ–Ω—ã –≤–µ—Ä—Å–∏–∏ —Ç–µ–∫—Å—Ç–æ–≤ –¥–ª—è –ï–° –∏ –°–ú
 *
a6 3
 * –ë–∞–∑–æ–≤–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –ï–°.
 *
 * Revision 3.1  86/04/20  23:43:21  alex
d8 1
a8 1
 *
d15 1
a15 1
#include "S.tele.h"
a16 2
#include <sys/types.h>
#include <sys/file.h>
a23 4
#ifdef SGTTYB /* –ü—Ä–∏–∑–Ω–∞–∫ –î–ï–ú–û–°-2 */
#define sgttyb SGTTYB
#endif

d31 2
a32 2
#ifdef TIOCSLTC
static struct ltchars tmpltc,oldltc;
a34 4
short cy40bit; /* –î–ª—è –ø–µ—Ä–µ–≤–æ—Ä–æ—Ç–∞ –≤ —É–ø—Ä. –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—è—Ö */
short lcasef0; /* –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –ø—Ä–∏–∑–Ω–∞–∫ lcase –¥–ª—è –≤—ã–≤–æ–¥–∞ */
short latdiag;
short vilcasef;
d42 1
a42 1
    static struct sgttyb templw;
d44 1
a44 3
    static struct tchars tcharsw;
#endif
#ifdef TIOCGETC
d48 1
a48 1
    tcharsw.t_quitc = -1;
a50 6
#ifdef TIOCSLTC
    ioctl(0,TIOCGLTC,&tmpltc);
    oldltc = tmpltc;
    tmpltc.t_suspc = tmpltc.t_dsuspc = tmpltc.t_flushc = -1;
    ioctl(0,TIOCSLTC,&tmpltc);
#endif
a51 1
/*  printf("GTTY %o\n", &templ);        */
d54 1
a54 3
    lcasef=lcasef0=LCFLG(templ.sg_flags);
    latf = LATFLG(templ.sg_flags);
    if ( latf ) latdiag = 1;
a56 14
#ifdef KI40BIT
    cy40bit = KI40BIT(templ.sg_flags);
#endif
    if(atcread)
    {   register int i;
	i=(*atcread)();
	atcread = (int (*)())NULL;
	if(i) {
	    printf1((i==1?
	    DIAG("unknown term capabilities\n please, type \n  TERM=<type>;export TERM \n and repeat red\n","–ù–µ –∑–∞–¥–∞–Ω–æ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π —Ç–µ—Ä–º–∏–Ω–∞–ª–∞, \n –Ω–∞–±–µ—Ä–∏—Ç–µ TERM=—Ç–∏–ø;export TERM –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤—ã–∑–æ–≤"):
	    DIAG("re can not work with this terminal\n","red –Ω–µ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å —ç—Ç–∏–º —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–º")));
	    exit(1);
	}
    }
a58 3
     if(lcasef && cvtout[COVIOPE] ) {
       vilcasef = 1; lcasef = 0;
     }
a61 3
/*
#ifdef Y_SIGSTOP
    templw.sg_suspc = templw.sg_dsuspc = -1;
a62 5
#ifdef TIOCSLTC
    templw.sg_flushc = -1;
#endif
 */
#endif
a72 3
#ifdef TIOCSLTC
    ioctl(0,TIOCSLTC, &oldltc);
#endif
a117 2
    static short vicase=0;
    short vineed;
a119 1
	if( cr == COSTART) n0scroll = n1scroll = -1;
d124 1
a124 30
    if ((char)c == (char)(esc2)) c='#';
    if(vilcasef) {
      vineed = 1;
      if( c>= 'A' && c<= 'Z' ) c= c+'a'-'A';
      else if( RLPRO(c))  c= c+'–±'-'–ë';
      else if( c=='`')  c='\'';
      else if( c=='|')  c='!';
      else if( c=='}')  c=')';
      else if( c=='{')  c='(';
      else if( c=='~')  c='^';
      else vineed = 0;
      if( vineed != vicase) putcha((vicase=vineed)?COVIOPE:COVICLO);
      }
#ifdef RED_CYRILL
    if( Rcyflag ) {
	if (iscyrill(c) ) {
		if(!Cyout) putcha(COCYON);
			   Cyout= 1;
			   c = OUTT(c);
		}
	else if( !isanychr(c) && Cyout) {
			   putcha(COCYOFF);
			   Cyout=0;
	       }
    }
#endif
#ifdef LCASEO
    if ( lcasef0 && !vilcasef ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
#endif
    putcbuf[iputcbuf++] = c;
d137 1
a137 4
#ifdef LCASEO
    if ( lcasef0 ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
#endif
    putcbuf[iputcbuf++] = c;
d181 1
a181 1
#define GETSY1 if(read(inputfile,&sy1,1)!=1) goto readquit;
a211 4
#ifdef RED_CYRILL
    if (Rcyflag && Cyin != Cyout )
	{ putcha(COCYON + 1 - Cyin); Cyout = Cyin; dumpcbuf();}
#endif RED_CYRILL
a220 8
#ifdef RED_CYRILL
    if ( Rcyflag) {
	lread1 &= 0177;
	if( lread1==CHA_RUS) {Cyin=1; goto new; }
	if( lread1==CHA_LAT) {Cyin=0; goto new; }
	if( Cyin==1 && lread1 >= 040) lread1 = INTT(lread1);
    }
#endif RED_CYRIILL
d253 1
a253 1
	    if(sy1&0200) sy1 = STASCII(cy40bit?(sy1^040):sy1);
d255 2
a256 2
	    {
		lread1 = (int)sy1 - 'a' + CCMAC+1;
d275 1
a275 1
	    if(sy1&0200) sy1 = STASCII(cy40bit?(sy1^040):sy1);
d279 1
a279 2
	    else { int flag=FREAD; putcha(COBELL); dumpcbuf();
		 ioctl(inputfile,TIOCFLUSH,&flag);goto new;}
d300 1
a300 1
    if(!cntf && (lcasef||latf) && (lread1>='@@'))
a303 1
#ifndef LCASEO
a305 1
#endif
a407 4
/*
 * writefile -
 * –ó–∞–ø–∏—Å–∞—Ç—å –∫–æ–º–∞–Ω–¥—É —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ –≤ —Ñ–∞–π–ª –ø—Ä–æ—Ç–æ–∫–æ–ª–∞
 */
a408 9
writefile(code1,str,code2)
int code1, code2;
char *str;
{
	char cd1=code1, cd2=code2;
	write(ttyfile,&cd1,1);
	for(;*str;str++) write(ttyfile,str,1);
	write(ttyfile,&cd2,1);
}
d421 1
a421 1
short kioutf;
a511 117

/*
 * scroll(n) - –ø—Ä–æ–∫—Ä—É—Ç–∏—Ç—å —ç–∫—Ä–∞–Ω –Ω–∞ n —Å—Ç—Ä–æ–∫ –≤–≤–µ—Ä—Ö (–≤–Ω–∏–∑)
 * –≤—ã–¥–∞–µ—Ç—Å—è 0, –µ—Å–ª–∏ –Ω–µ —Å–¥–µ–ª–∞–Ω–æ, –∏–Ω–∞—á–µ 1
 */
scroll(n)
int n;
{
	register int i;
	int dll,ill,nl;
#define PUTCC(c,n) for(i= n;i>0;i--) putcha(c)
	if(!(curport->flags&WF_ROLL)) {
		/*
		 * –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∏–∑–Ω–∞–∫ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ roll
		 */
		i=WF_NROLL;
		if(!can_scroll) goto ex;
		if(curport->lmarg != 0 || curport->rmarg != wholescreen.rmarg) goto ex;
		if(can_scroll == ROLL_SF
		    && (curport->tmarg != 0
		    || curport->bmarg != wholescreen.bmarg - NPARAMLINES)) goto ex;
		i = WF_YROLL;
ex: 
		curport->flags |= i;
	}
	if(!(curport->flags & WF_YROLL) ) return(0);
	if ( n == 0 ) return(1);
	if( n>curport->btext-2 || -n > curport->btext-2) return(0);
	switch(can_scroll) {
	case ROLL_CS:
		if(n0scroll != curport->ttext || n1scroll != curport->btext)
			if(!setscroll(curport))  return(0);
		if(n>0) {
			poscursor(0, curport->btext);
			PUTCC(COSRFWD,n);
		} 
		else {
			poscursor(0,0);
			PUTCC(COSRBAK, -n);
		}
		break;
	case ROLL_IL:
		if(n>0) {
			nl=n;
			dll=0;
			ill=curport->btext - nl+1;
		}
		else
		{
			nl = -n;
			dll = curport->btext - nl+1;
			ill=0;
		}
		poscursor(0,dll);
		PUTCC(CODELIN,nl);
		poscursor(0,ill);
		PUTCC(COILINE,nl);
		break;
	case ROLL_SF:
		{
			register struct viewport *w;
			w = curport;
			if ( n > 0 )
			{
				switchport(&wholescreen);
				poscursor(0,wholescreen.bmarg);
				PUTCC(COSRFWD,n);
				switchport(w);
				if(need_box != 2 )
				{
					poscursor(-w->ltext, w->btext-n+1);
					putcha(COCLSCR);
				}
			} 
			else {
				if(need_box != 2 )
				{
					poscursor(-w->ltext,w->btext+n+1);
					putcha(COCLSCR);
				}
				switchport(&wholescreen);
				poscursor(0,0);
				for(i= -n; i; i--)
					putcha(COCLLIN), putcha(COSRBAK);
				switchport(w);
			}
			need_box = (n==1||n== -1)?1:2;
			new_info = 1;
			break;
		}
	default: 
		return(0);
	}
	shiftview(0,n);
	return(1);
}

/*
 * setscroll(viewp) - —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –≥—Ä–∞–Ω–∏—Ü —Ä–æ–ª–ª–∏–Ω–≥–∞ —ç–∫—Ä–∞–Ω–∞
 * –Ω–∞ –æ–±–ª–∞—Å—Ç—å text –¥–∞–Ω–Ω–æ–≥–æ –æ–∫–Ω–∞
 */
setscroll(viewp)
register struct viewport *viewp;
{
	register char *c;
	extern char *tgoto();
	if( !ch_scroll) return(0);
	c= tgoto(ch_scroll,  viewp->ttext + viewp->btext, viewp->ttext);
	if(!c) return(0);
	switchport(&wholescreen);
	while(*c) putchb(*c++);
	putcha(COHO);
	cursorcol = cursorline = 0;
	switchport(viewp);
	return(1);
}

@


3.1.2.2
log
@wYNESENA PEREMENNAQ lread1 I \TO OTLAVENO
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.1.2.1 87/06/19 16:56:43 alex Exp $
a5 3
 * Revision 3.1.2.1  87/06/19  16:56:43  alex
 * Start revision for red/4
 * 
a302 6
static int oldchar  = -1;
unread1(ch)
int ch;
{
oldchar = ch&0377;
}
d304 1
a304 1
 * readch()
d309 1
d315 2
a316 1
int readch()
d321 2
a322 1
    register int lread1;
d325 1
a325 1
    if (oldchar != -1) { lread1 = oldchar; oldchar = -1; goto retnl;}
d334 1
a334 1
    if (inputfile!=0 && (lread1=readfc())!= -1)
a495 1
    register int lread1;
d506 1
a506 1
	    return (-1);
d511 1
a511 1
    return (lread1);
d549 1
a549 2
    register int lread1;
    if (inputfile && (lread1=readfc())!= -1) return(lread1);
@


3.1.2.3
log
@New readch + gettc + tc table Tested
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.1.2.2 87/06/23 18:55:33 alex Exp $
a5 3
 * Revision 3.1.2.2  87/06/23  18:55:33  alex
 * –í—ã–∫–∏–Ω—É—Ç–∞ lread1 –∫–∞–∫ –∫–ª–∞—Å—Å.
 * 
a172 4
    setscroll(&wholescreen);
    putcha(COFIN);
    dumpcbuf(0);
    printf("\n");
d306 6
a317 7
 * –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:
 * oldchar - —Å–∏–º–≤–æ–ª, –≤–æ–∑–≤—Ä–∞—â–µ–Ω–Ω—ã–π –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è –ø/–ø unread1()
 * ps_inmac - —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —á–∏—Ç–∞–µ–º–æ–µ –º–∞–∫—Ä–æ
 * ps_exin - —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —á–∏—Ç–∞–µ–º–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Å–∏–º–≤–æ–ª–∞
 * (*pf_wmac)() - —Ç–µ–∫—É—â–∞—è –∑–∞–ø–∏—Å—å –≤ –º–∞–∫—Ä–æ, –æ–Ω–∞ –∂–µ –æ—Ç—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç CCQUIT –≤ –∫–æ–Ω—Ü–µ
 * litchar - –ø—Ä–∏–∑–Ω–∞–∫ (—Å–ª–µ–¥. —Å–∏–º–≤–æ–ª - –ª–∏—Ç–µ—Ä–∞–ª)
 * rmacl(name) - –¥–∞–µ—Ç –º–∞–∫—Ä–æ –ø–æ –∏–º–µ–Ω–∏
a318 2
char *ps_inmac, *ps_exin;
int (*pf_wmac)();
d320 3
a322 4
static short litchar;
static int oldchar  = -1;
char *rmacl();

d324 1
d326 27
a352 25
#define GETSY1(c,g) if(read(inputfile,&c,1) != 1) goto g; else
	register int lc;
	char sy;
	if(oldchar != -1) { 
		lc = oldchar; 
		oldchar = -1; 
		return(lc); 
	}
	dumpcbuf();
rmacro:
    if( ps_inmac) {
	lc = (*ps_inmac++) &0377;
	if(*ps_inmac == 0) ps_inmac = NULL;
	goto w_macro;
	}
    if(inputfile && (lc = readfc()) != -1) goto w_macro;
r_exin:
    if( ps_exin) {
	lc = (*ps_exin++) &0377;
	if(*ps_exin == 0) ps_exin = NULL;
	goto w_proto;
	}
/*
 * –ß—Ç–µ–Ω–∏–µ –æ—á–µ—Ä–µ–¥–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞
 */
d358 9
a366 8
    intrflag = 0;
    GETSY1(sy, readquit);
    lc = sy & 0377;
    if(litchar) {
	lc = (lc&037)|'@@';
	litchar = 0;
	goto w_proto;
	}
d369 4
a372 4
	lc &= 0177;
	if( lc==CHA_RUS) {Cyin=1; goto new; }
	if( lc==CHA_LAT) {Cyin=0; goto new; }
	if( Cyin==1 && lc >= 040) lc = INTT(lc);
d375 4
a378 24
    if( ISCTRL(lc)) {
	int *i1,*i2, ts, k;
	i1=i2=0;
	ts=0;
	sy=lc;
	while ((k=findt(&i1,&i2,sy,ts++))== CONTF)
	{
	    GETSY1(sy,readquit);
	    if(sy&0200) sy = STASCII(cy40bit?(sy^040):sy);
	}
	if ( k== BADF) {
	    int flag=FREAD; putcha(COBELL); dumpcbuf();
	    ioctl(inputfile,TIOCFLUSH,&flag);goto new;
	}
	lc=k;
	if (lc == CCMAC) {
	    GETSY1(sy, readquit);
	    if(sy&0200) sy = STASCII(cy40bit?(sy^040):sy);
	    if(sy >= 'a' && sy <='z')
		{
		lc = (int)sy - 'a' + CCMAC+1;
		} else goto new;
	    }
	    goto w_proto;
d380 60
d441 11
a451 2
    /* –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å–∏–º–≤–æ–ª–æ–≤ –ø—Ä–∏ –≤–≤–æ–¥–µ –≤ lcase */
    if((lcasef||latf) && (lc >= '@@'))
d453 4
a456 2
#define LBUFWSY 5
	char bufwsy[LBUFWSY+1];
a457 1
	int i;
d460 1
a460 1
	if(lcasef&&(lc>=0300)) lc ^= 040; /* –∏–∑?–∑–∞ –¥—Ä–∞–π–≤–µ—Ä–∞*/
d463 6
a468 6
	i=1;
	bufr[0]=lc;
	exinss(&si, si+1, &so, &i, LBUFWSY-1);
	*so=0;
	lc=((int)bufwsy[0])&0377;
	if(so!= bufwsy+1) ps_exin = bufwsy+1;
d470 12
a481 25
/*
 * –¢–æ—á–∫–∏ –≤—ã—Ö–æ–¥–∞ –∏–∑ –ø–æ–¥–ø—Ä–æ–≥—Ä–∞–º–º—ã
 */
w_proto:
    if(ttyfile > 0) {
	sy = lc;
	write(ttyfile,&sy, 1);
	}
/*
 * –û—Ç—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –∫–æ–¥–æ–≤
 */
    if(lc > CCMAC && lc <= CCEMAC)
	{
	ps_inmac = rmacl(lc);
	if(ps_inmac) goto rmacro;
	else goto new;
	}
    if( lc == CCCTRLQUOTE) {
	litchar = 1;
	}
w_macro:
    if(pf_wmac) {
	if( ((*pf_wmac)(lc))  == 0) goto new; /* –°–∏–º–≤–æ–ª —Å'–µ–ª–∏ */;
	}
    return(lc);
d484 6
a489 5
	lc=CCENTER;
	intrflag=0;
    }   else
	lc=CCQUIT;
    goto w_proto;
d491 1
a491 6

unread1(ch)
int ch;
{
oldchar = ch&0377;
}
@


3.1.2.4
log
@Graph_characters used in margin
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.1.2.3 87/06/24 22:36:46 alex Stab $
a5 3
 * Revision 3.1.2.3  87/06/24  22:36:46  alex
 * New readch + gettc + tc table Tested
 * 
d115 1
a115 1
    ioctl(2,TIOCGETC, &tchars0);
d119 1
a119 1
    ioctl(2,TIOCSETC, &tcharsw);
d122 1
a122 1
    ioctl(2,TIOCGLTC,&tmpltc);
d125 1
a125 1
    ioctl(2,TIOCSLTC,&tmpltc);
d127 1
a127 1
    gtty(2,&templ);
d167 1
a167 1
    stty(2,&templw);
d180 1
a180 1
    stty(2,&templ);
d182 1
a182 1
    ioctl(2,TIOCSLTC, &oldltc);
d185 1
a185 1
    ioctl(2,TIOCSETC, &tchars0);
d226 1
a226 1
register int c;
d230 5
a234 6
    static short graphcase = 0;
    short vineed, needgraph;
    c &= 0377;
    if (c>=0 && c<=COMCOD) {
	if( c == COSTART) n0scroll = n1scroll = -1;
	if(!(s=cvtout[c])) return(0);
a250 12
      if ( c >= G_START && c <= G_END)
	{
	if( c < G_START + gchars ) { c = g_table[(c) - G_START];
		needgraph = 1;
		}
		else {
		c = g0table[c-G_START];
		needgraph = 0;
		}
	 } else needgraph = 0;
	 if ( needgraph != graphcase ) putcha(COGSTART + graphcase);
	  graphcase = needgraph;
a311 7
setatr(atr)
int atr;
{
 register int i = NUMA(atr);
 if ( i != cur_atr && i <= COAOUT ) putcha(i);
 cur_atr = atr;
}
@


3.1.2.5
log
@REVISION
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.1.2.4 87/07/03 22:03:56 alex Exp $
a5 3
 * Revision 3.1.2.4  87/07/03  22:03:56  alex
 * Graph_characters used in margin
 * 
a179 1
    setatr(A_NORM);
a310 1
    setatr(A_NORM);
d338 1
a338 1
 * –ß—Ç–µ–Ω–∏–µ –æ—á–µ—Ä–µ–¥–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ —Å —Ç–µ—Ä–º–∏–Ω–∞–ª–∞.
d393 1
a393 2
	if( lc < 040)
		lc = (lc&037)|'@@';
d402 1
a402 1
	if( Cyin==1 && lc >= 040 && lc < 0177) lc = INTT(lc);
@
