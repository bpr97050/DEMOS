
            дддд   ееееее   м     м    oooo     сссс
           д   д   е        мм   мм   o    o   с    с
          д    д   е        м м м м   o    o   с    с
          д    д   еееее    м  м  м   o    o   с
          д    д   е        м     м   o    o   с
          д    д   е        м     м   o    o   с    с
         дддддддд  ееееее   м     м    oooo     сссс



          демосдемосдемосдемосдемосдемосдемосдемосде
          емосдемосдемосдемосдемосдемосдемосдемосдем
          мо                                      мо
          ос                                      ос
          сд        ОПЕРАЦИОННАЯ СИСТЕМА          сд
          де                                      де
          ем               ДЕМОС                  ем
          мо                                      мо
          ос                                      ос
          сд                                      сд
          де             Версия 1.0               де
          ем                                      ем
          мо                                      мо
          сдемосдемосдемосдемосдемосдемосдемосдемосд
          демосдемосдемосдемосдемосдемосдемосдемосде







                    КОМАНДНЫЙ ЯЗЫК SHELL






                Бардин Валерий Владимирович
               Черногрядская Наталья Юрьевна












                       МОСКВА - 1985









                                                           1



   В документе описан стандартный язык управления  заданиями
ОС ДЕМОС (SHELL).





























































2




                        1. ВВЕДЕНИЕ


   В семействе операционных систем, совместимых с  ОС  UNIX,
язык SHELL используется в качестве стандартного языка управ-
ления заданиями, т.е. является основным языком общения поль-
зователя  с системой. Он предоставляет средства для описания
таких действий, как, например, запуск какого-либо компилято-
ра   или  программы,  создание,  копирование  и  уничтожение
файлов, опрос состояния процессов. Кроме того, SHELL  широко
применяется  и в качестве языка разработки особых программ -
командных файлов. Последнее свойство  об'ясняется  тем,  что
SHELL имеет много общего с универсальными языками программи-
рования, в частности, конструкции, которые позволяют  созда-
вать программы, содержащие проверки условий и циклы.

   Важным достоинством языка, является возможность  его  по-
этапного  изучения.  Для того чтобы начать работу в системе,
пользователю достаточно ознакомиться  с  разделом  "Основные
понятия" данного документа.









































                                                           3




                    2. ОСНОВНЫЕ ПОНЯТИЯ


   После регистрации пользователя вся  дальнейшая  работа  с
системой  выполняется  под  управлением программы "sh" - ин-
терпретатора командного языка SHELL.

   Во время работы пользователь выдает  команды  и  получает
сообщения  системы о результатах их выполнения. Как правило,
при получении команды интерпретатор  определяет  имя  файла,
содержащего  программу,  которую необходимо выполнить, и по-
рождает процесс, который работает под  управлением  заданной
программы.  Исключения  составляют  случаи, когда вызываются
встроенные команды языка SHELL, при этом указанные  действия
выполняются  непосредственно  интерпретатором без порождения
нового процесса. Поскольку, в качестве имени  команды  может
указываться  любой  файл,  содержащий исполняемую программу,
существует практически безграничная  возможность  расширения
набора команд.

   С понятием процесса в ОС ДЕМОС связано  понятие  "среды".
Среда  формируется  процессом-родителем  и содержит дополни-
тельную информацию о способе  выполнения  процесса.  Каждому
процессу ставится в соответствие три файла: стандартный файл
ввода, стандартный файл вывода и файл диагностических  сооб-
щений.  При запуске команды пользователь может указать файлы
которые будут применяться в качестве стандартных. По умолча-
нию,  ввод/вывод информации осуществляется с терминала поль-
зователя.

   Характерной чертой систем, совместимых с ОС UNIX, являет-
ся  естественная возможность работы с несколькоми процессами
одновременно. Пользователь может указать в команде, что  со-
ответствующий  процесс  должен  работать как "фоновый" (т.е.
переход к приему следующей команды осуществляется без ожида-
ния окончания данного процесса). Кроме того, существует воз-
можность задания команд, для выполнения которых  интерпрета-
тор  порождает  несколько  взаимодействующих  процессов. При
этом создается цепочка процессов ("конвейер"), в которой об-
рабатываемая информация передается от одного процесса друго-
му по "каналу межпроцессной связи".


   2.1. Простые команды


   Простые команды состоят из одного  или  нескольких  слов,
разделенных пробелами. Первое слово является именем выполня-
емой команды; все остальные слова передаются команде  в  ка-
честве параметров. Например,

                             who

представляет собой  команду,  которая  выдает  информацию  о
пользователях, зарегистрированных в системе. Команда

                            ls -l

выдает список файлов  текущего  справочника.  Параметр  "-l"


4

указывает  команде  ls, что нужна информация о характеристи-
ках, размере и дате создания каждого файла.


   2.2. Фоновые процессы


   Для того, чтобы выполнить  команду,  интерпретатор  языка
SHELL  обычно  создает  новый процесс и ждет его завершения.
Пользователь может запускать процессы  в  "фоновом"  режиме,
при  этом  интерпретатор переходит к обработке следующей ко-
манды сразу после запуска процесса, не ожидая окончания  ра-
нее запущенного. Например, команда:

                       cc program.c &

вызывает компилятор для обработки файла "program.c".  Символ
"&",  завершающий  строку,  указывает интерпретатору команд,
что следует перейти к обработке следующей команды без ожида-
ния  окончания  трансляции.  Для  последующего наблюдения за
ходом процесса система сообщает уникальный номер, по которо-
му можно запрашивать информацию о его состоянии.


   2.3. Задание имен файлов


   В языке SHELL предусмотрен механизм для генерации  списка
имен  файлов, которые соответствуют некоторому образцу. Нап-
ример, при выполнении команды:

                          ls -l *.c

в качестве параметров "ls" передаются имена всех файлов  те-
кущего справочника, которые оканчиваются на ".c". Символ "*"
имеет специальное значение (т.е. является метасимволом языка
SHELL), ему соответствует любая строка (в том числе пустая).
При задании образцов могут использоваться следующие метасим-
волы:

*      соответствует любой строке символов  (включая  пустую
       строку);

?      соответствует любому одиночному символу;

[...]  соответствует любому из перечисленных  внутри  скобок
       символов;  пара  символов,  разделенных знаком минус,
       будет соответствовать  любому  символу  из  заданного
       лексического промежутка.

   Например, образцу

                           [А-Я]*

соответствуют все имена в текущем справочнике, которые начи-
наются с прописной русской буквы, а образцу

                      /usr/nata/test/?

соответствуют  все  односимвольные  имена   из   справочника
"/usr/nata/test".  Если  не  найдено  ни одного файла, соот-
ветствующего заданному образцу, то в качестве параметра  ко-


                                                           5

манде передается сам образец.

   Описанный механизм  сокращает время набора команд и  поз-
воляет  выбирать имена, отвечающие нужному образцу. Он также
может использоваться при поиске файлов. Например, команда

                    echo /usr/nata/*/core

находит и  печатает  полные  имена  всех  файлов  "core"  из
подсправочников  справочника "/usr/nata" (команда "echo" яв-
ляется стандартной командой ДЕМОС, которая печатает свои па-
раметры, разделяя их пробелами).

   Из  общих  правил,  указанных   для   образцов,   имеется
единственное  исключение.  Символ  "."  в начале имени файла
должен указываться явно. Поэтому команда:

                           echo *

будет выдавать все имена файлов в текущем справочнике, кото-
рые не начинаются с точки, а команда:

                           echo .*

напечатает имена файлов, начинаюшиеся с точки. Это позволяет
исключить  неумышленную подмену имен "." и "..", которые со-
ответственно означают "текущий справочник" и "основной спра-
вочник".


   2.4. Отмена специального значения метасимволов


   Для языка SHELL символы "<", ">", "*", "?", "|", "&" име-
ют специальное значение (полный список метасимволов приведен
в табл.2 Приложения). Любой метасимвол, которому предшеству-
ет  обратная  черта,  теряет свое специальное значение (дей-
ствие  "\"  распространяется  только  на  следующий  за  ним
символ, при этом сам знак "\" игнорируется). Так, команда:

                          echo \?

напечатает только знак вопроса "?", а команда:

                           echo \\

выдаст лишь один символ "\". Для записи длинных  конструкций
более чем в одной строке, специальное значение символа новой
строки "\n" отменяется.

   Знак "\" удобен для отмены специального значения  отдель-
ных  символов.  Когда  же необходимо экранировать сразу нес-
колько метасимволов, такой механизм оказывается слишком гро-
моздким. В этом случае последовательность знаков заключается
в апострофы. Например, команда:

                       echo хх'****'хх

напечатает

                          хх****хх



6


   Символ новой строки "\n", заключенный в апострофы, теряет
свое специальное значение. Однако, экранировать сам апостроф
таким способом нельзя.

   Еще одним механизмом отмены специального значения  симво-
лов является заключение их в двойные кавычки.


   2.5. Задание файлов ввода/вывода


   Результаты работы большинства команд записываются в стан-
дартный  файл  вывода. По умолчанию вся выдаваемая процессом
информация отображается на терминал пользователя. При  необ-
ходимости  она  может быть записана и в обычный файл. Так, в
следующем примере:

                       ls -l > filels

конструкция "> filels" рассматривается как указание  исполь-
зовать  в качестве стандартного вывода команды "ls" заданный
файл (в данном случае файл "filels").  Если  файл  с  данным
именем  отсутствует,  интерпретатор команд создает его. Если
файл существует, то его исходное содержимое  заменяется  ин-
формацией, выдаваемой командой.

   Если требуется сохранить содержимое файла, добавив в него
поступающую  информацию,  вместо  символа  ">"  используется
конструкция ">>". Например:

                        ls >> filels

В данном случае, если файл не существует, он также предвари-
тельно создается системой.

   Аналогичные возможности предоставляются и для переопреде-
ления стандартного файла ввода (по умолчанию данные вводятся
с терминала). Для этой цели используется символ "<".  Напри-
мер, команда:

                        wc < filels

выдает количество строк файла "filels".

   Далее перечислены основные конструкции, используемые  для
задания файлов ввода/вывода.

> файл
     В  качестве  стандартного  файла  вывода   используется
     "файл",  который перезаписывается заново или создается,
     если ранее не существовал.

>> файл
     Поступающая информация добавляется к содержимому  "фай-
     ла".  Если "файл" не существует, он предварительно соз-
     дается.

< файл
     В  качестве  стандартного  файла   ввода   используется
     "файл".



                                                           7

<< файл
     Чтение "локального файла" (см. раздел 4.8). Последующие
     строки  передаются  команде в качестве информации стан-
     дартного файла ввода до тех  пор,  пока  не  встретится
     строка,  содержащая последовательность символов "файл".
     Если специальное значение первого символа строки "файл"
     отменено,  выполняются  подстановки значений макропере-
     менных и результатов выполнения команд.

>& цифра
     Информация, записываемая в файл с дескриптором "цифра",
     передается в стандартный файл вывода.

<& цифра
     Стандартным файлом ввода является файл  с  дескриптором
     "цифра".

<&-  Файл стандартного ввода закрыт на запись.

>&-  Файл стандартного вывода закрыт на чтение.


   2.6. Связь процессов, конвейеры и фильтры


   Информация, выдаваемая в стандартный  файл  вывода  одной
командой,  может непосредственно передаваться другой команде
в качестве содержимого стандартного файла ввода. Например, в
результате работы команд:

                           ls | wc

будет выдано общее число символов в именах текущего справоч-
ника.  Составная  команда,  образованная  с помощью операции
"|", называется "конвейером". В данном случае она  выполняет
действие эквивалентное командам:

                 ls > filels
                 wc < filels
                 rm filels

за тем исключением, что для хранения промежуточных результа-
тов  не  используется никаких файлов. В конвейере каждая ко-
манда работает как параллельный независимый процесс,  инфор-
мация  передается  в  одном направлении. Если входные данные
процесса-получателя  еще  не  готовы,  или  выходные  данные
процесса-источника не успевают обрабатываться, то выполнение
соответствующего процесса приостанавливается.

   "Фильтром" называется команда, которая, получая данные из
стандартного файла ввода, производит какую-либо работу и вы-
дает результат в стандартный файл вывода. Типичным  примером
фильтра  может служить команда "grep", которая, читая данные
из стандартного файла  ввода,  выбирает  строки,  содержащие
указанную  последовательность  символов  и выдает их в стан-
дартный файл вывода. Например, команда:

                       ls | grep old

выдает только те имена файлов текущего справочника,  которые
содержат  последовательность  символов  "old". Конвеер может
состоять более чем из двух процессов. Например, конструкция:


8

                   ls | grep bak | wc -l

может использоваться для подсчета числа имен файлов в  теку-
щем  справочнике, которые содержат последовательность симво-
лов "bak".


   2.7. Макропеременные


   Имя макропеременной представляет собой последовательность
букв, цифр и символов подчеркивания, начинающуюся с буквы.

   При выполнении оператора присваивания в  командную  среду
текущего  процесса  заносится  запись типа "имя=значение", в
левой части которой стоит имя макропеременной, а в правой  -
последовательность  символов, являющаяся ее значением. В ко-
мандной строке все вхождения вида "$имя" заменяются значени-
ями  соответствующих  макропеременных (исключение составляют
случаи, когда подобные  конструкции  заключены  в  апострофы
'...' или символу "$" предшествует знак "\").

   Примеры:

USER=nata HOME=/usr/nata
     присваивание значений макропеременным USER и HOME;

null=
     присваивание макропеременной значения пустой строки;

echo $USER
     выполнение подстановки  значения  макропеременной  (ре-
     зультат - строка "nata").

   Переменные могут использоваться для введения  сокращений.
Так, при выполнении команд:

       b=/usr/nata/bin
       mv pgm $b

файл "pgm" будет перемещен из текущего справочника  в  спра-
вочник "/usr/nata/bin".

   В более общем виде макровызов записывается следующим  об-
разом:

       ${имя_макропеременной}

Фигурные скобки в данном случае играют роль  разделителей  и
используются тогда, когда за именем следует буква или цифра.
Например, в результате выполнения группы команд:

      П=ПРОБ
      ПА=ПЕРА
      echo ${П}А $ПА

будет выдан текст:

      ПРОБА ПЕРА





                                                           9

   В языке SHELL существуют специальные макропеременные, ко-
торые  определяются перед началом выполнения команды (исклю-
чение составляет макропеременная "?", которая получает  зна-
чение после выполнения команды):

?    Десятичное целое число - код завершения  последней  вы-
     полненной  команды. В большинстве случаев, при успешном
     выполнении команд, значение кода завершения равно нулю.
     В противном случае, если команда закончилась не удачно,
     код завершения не равен нулю.

#    Количество полученных параметров.

$    Номер данного процесса. Поскольку для каждого  процесса
     существует свой номер, то эта макропеременная часто ис-
     пользуется  для  создания  уникальных  имен   временных
     файлов. Например:

       ps a >/tmp/ps$$
       . . .
       rm /tmp/ps$$


!    Номер последнего процесса, запущенного в качестве фоно-
     вого.

-    Текущие  ключи  (установленные  режимы)  интерпретатора
     "sh" типа "-x" и "-v".

   Перечисленные далее макропеременные  языка  SHELL,  имеют
для системы особый смысл и не должны использоваться в других
целях:

MAIL  Перед тем как выдать  первую  подсказку  интерпретатор
      просматривает  файл,  имя  которого является значением
      этой макропеременной. Если данный файл изменялся с мо-
      мента  последнего  просмотра,  будет выданно сообщение
      "you have mail" (Для Вас есть корреспонденция). Значе-
      ние  этой  макропеременной  обычно устанавливается при
      выполнении файла ".profile".

      Например:

                     MAIL=/usr/mail/nata


HOME  Имя справочника для команды "cd" без параметров. Поиск
      файлов,  имена  которых  не  начинаются с символа "/",
      осуществляется в текущем справочникe. Для смены  теку-
      щего  справочника  применяется команда "cd". Например,
      команда:

                      cd /usr/nata/bin


      назначает текущим справочник "/usr/nata/bin". Команда:

                          cat show






10

      выводит на терминал содержимое файла "show"  из  спра-
      вочника  "/usr/nata/bin".  Команда "cd" без параметров
      эквивалентна команде:

                          cd $HOME


      значение этой макропеременной также обычно определяет-
      ся в файле ".profile".

PATH  Эта макропеременная  определяет  список  справочников,
      просматриваемых при поиске команды. Если значение мак-
      ропеременной "PATH"   не  определено,  то  принимается
      следующий порядок просмотра: текущий справочник, спра-
      вочник "/bin" и справочник "/usr/bin". При явном зада-
      нии значения макропеременной "PATH" имена справочников
      разделяются символом ":". Например:

         PATH= :/usr/nata/bin:/bin:/usr/bin


      означает, что просмотр справочников  будет  вестись  в
      следующем  порядке: текущий справочник (пустая позиция
      перед первым символом ":"), "/usr/nata/bin", "/bin"  и
      "/usr/bin".  Таким  образом,  конкретные  пользователи
      могут иметь свои "личные" команды, доступные независи-
      мо  от  того,  какой справочник является текущим. Если
      имя команды начинается с  символа  "/"  (т.е.  заданно
      полное  имя исполняемого файла), то поиск в справочни-
      ках не ведется. В этом случае делается всего одна  по-
      пытка выполнить указанную команду.

PS1   Подсказка интерпретатора (по  умолчанию  для  обычного
      пользователя - "$").

PS2   Подсказка интерпретатора, означающая продолжение ввода
      (по умолчанию ">").

IFS   Множество символов-разделителей, интерпретируемых  как
      "пробелы".

TERM  Тип связанного с процессом терминала.


   2.8. Выдача подсказок


   При работе с терминала, когда интерпретатор готов принять
следующую  команду, по умолчанию выдается подсказка "$". Она
может быть изменена командой:

                          PS1=ввод:

после выполнения которой подсказка будет  иметь  вид  строки
"ввод:".

   Если введенная строка содержит синтаксически  незавершен-
ную  конструкцию, для продолжения ввода интерпретатор выдаeт
в качестве подсказки  символ  ">".  Подсказка,  обозначающая
продолжение  ввода,  может  быть  изменена с помощью команды
присваивания нового значения макропеременной "PS2".



                                                          11

Например, команда:

                      PS2=Продолжение:

установит в качестве подсказки строку "Продолжение:".


   2.9. Составные команды


   Существует два способа об'единения  нескольких  команд  в
одну составную команду:

                     { список_команд; }
                      (список_команд)

В первом случае указанный "список_команд" просто  выполняет-
ся.  Во  втором - заданный "список_команд" тоже выполняется,
но уже как отдельный процесс.

   Например, конструкция:

                       (cd х; rm junk)

выполняет команду "rm junk" в справочнике  "х",  не  изменяя
текущего справочника, а команды

                     { cd х; rm junk; }

дают тот же самый результат, но  справочник  "х"  становится
текущим.


   2.10. Встроенные команды


   Как правило, при выполнении  какой-либо команды интерпре-
татор  порождает  отдельный  процесс. Однако, существует ряд
функций, выполнение которых в качестве  отдельного  процесса
либо  неэффективно,  либо невозможно. Прежде всего это отно-
сится к командам, выполнение которых  зависит  от  состояния
локальных  переменных интерпретатора. Команды, выполняющиеся
непосредственно интерпретатором (без  порождения  процесса),
называются  "встроенными  командами"  языка.  С точки зрения
пользователя встроенные команды практически не отличаются по
своим  свойствам от остальных команд системы, за исключением
того, что для них обычно нельзя  переопределить  стандартные
файлы ввода/вывода.

   Далее приводится список встроенных команд с кратким  опи-
санием выполняемых функций:

:    Эта команда не выполняет никаких действий, ее  код  за-
     вершения  равен нулю. Тем не менее производится подста-
     новка значений макропеременных.

. файл
     Считывает и выполняет команды из "файла". Для  нахожде-
     ния  справочника, содержащего "файл", используется мак-
     ропеременная "PATH".




12

cd [справочник]
     Об'явить указанный "справочник" текущим. Если  параметр
     не  задан,  в  качестве  имени справочника используется
     значение макропеременной "HOME". Синонимом команды "cd"
     является команда "chdir".

eval [команда ...]
     Выполняются все  макроподстановки,  после  чего,  слово
     "eval" отбрасывается и остальные символы обрабатываются
     как обычная командная строка.

exec [команда ...]
     Текущий процесс замещается процессом выполненя  указан-
     ной  "команды". Допускается переопределение стандартных
     файлов ввода/вывода.

exit [N]
     Прерывание выполнение текущего процесса. Сообщается код
     завершения  "N".  Если параметр "N" отсутствует, то ис-
     пользуется код завершения последней выполненной  коман-
     ды.

export [имя ...]
     Перечисленные макропеременные автоматически вводятся  в
     среду  порождаемых процессов. Если параметры не заданы,
     выдается список "экспортируемых" макропеременных.

login [параметр ...]
     Регистрация пользователя в системе без создания  нового
     процесса   (эквивалент  команды  "exec  login  параметр
     ...").

newgrp [параметр ...]
     Замена  текущего  идентификатора  группы  пользователей
     (эквивалент команды "exec newgrp параметр ...").

read имя ...
     Из стандартного файла ввода  считывается  одна  строка.
     Затем макропеременным "имя ..." последовательно присва-
     иваются значения слов, составляющих эту строку. Код за-
     вершения команды равен нулю во всех случаях, кроме тех,
     когда список параметров длиннее, чем число слов в  счи-
     танной строке.

readonly [имя ...]
     Запрещается переопреление  перечисленных  макроперемен-
     ных.  Если  параметры  не  заданы, выдается список всех
     макропеременных, определенных  как  "readonly"  (только
     для чтения).

set [-ekntuvx [параметр ...]]
     Устанавливает режимы работы интерпретатора языка SHELL.
     Могут задаваться следующие ключи:

      -e  В неинтерактивном режиме вызывает немедленное пре-
          рывание процесса при обнаружении ошибки в выполне-
          нии команды.

      -k  Все определенные макропеременные  "экспортируются"
          в среду запускаемых процессов.




                                                          13

      -n  Производит только синтаксический контроль команд.

      -t  Прерывает  выполнение  процесса  после  того,  как
          будет считана и выполнена одна команда.

      -u  Устанавливает режим диагностики ошибки при попытке
          использовать неопределенные макропеременные.

      -v  Устанавливает режим печати вводимых строк.

      -x  Распечатывает команды и их параметры по  мере  вы-
          полнения.

      -   Отменяет ключи "-v" и "-x".

     Установленные ключи содержатся в  макропеременной  "-".
     Остальным параметрам команды "set" присваиваются значе-
     ния позиционных параметров "1, 2, ...". Если  параметры
     не  заданы,  печатается список значений всех макропере-
     менных.

shift
     Позиционным параметрам "2, 3, ..." присваиваются значе-
     ния параметров "1, 2, ..." соответственно.

times
     Выдается время, затраченное пользователем и системой на
     выполнение процесса.

trap [команда] [N ...]
     При получении перечисленных сигналов  выполняется  ука-
     занная "команда".

umask [ddd]
     При формировании дескрипторов вновь создаваемых  файлов
     признаки  "разрешение чтения" и "разрешение записи" ус-
     танавливаются согласно маске "ddd". Цифра "0"  в  соот-
     ветствующем разряде означает установку признака. Формат
     маски совпадает с форматом  дескриптора,  задаваемым  в
     команде "chmod". Рассматриваются только те позиции, ко-
     торые определяют разрешение чтения  записи  "rw".  Если
     параметр  отсутствует, выдается текущее значение маски.
     Например, команда "umask 000" установит режим, при  ко-
     тором  всем  порождаемым  файлам  будет устанавливаться
     признаки "разрешения чтения записи" для всех  пользова-
     телей.

wait [N]
     Ожидает окончания выполнения процесса с номером  (N)  и
     присваивает его код завершения макропеременной "?".














14




                     3. КОМАНДНЫЕ ФАЙЛЫ


   Последовательность команд можно записать в файл и  выпол-
нить,  указав имя этого файла. Таким образом, обеспечивается
возможность создания достаточно сложных  программ  на  языке
SHELL.  В  языке  существуют  операторы управления (оператор
цикла, условного перехода, выбора) и аппарат передачи  пара-
метров.

   Выполнение командного файла  может  осуществляться  двумя
способами.  В  первом случае, указывается имя интерпретатора
языка SHELL - "sh", режимы его работы, имя и  параметры  ко-
мандного  файла.  Во  втором  - только имя файла и параметры
(аналогично вызову любой команды системы). При этом  предпо-
лагается, что файл имеет признак "выполнение разрешено".

   Результат работы команды не зависит от способа ее  выпол-
нения,  поэтому,  как  правило, используется второй вариант.
Запуск команды с явным указанием имени интерпретатора  часто
применяется  для  отладки командных файлов, когда необходимо
задавать различные режимы работы "sh".

   Например, команда:

                     sh file [параметры]

вызывает  интерпретатор  для  выполнения  команд  из   файла
"file".  Если в командной строке заданы параметры, они пере-
даются порождаемому процессу в виде значений макропеременных
"1", "2" и т.д.

   Например, если файл "wg" содержит строку:

                        who | grep $1

то команда

                         sh wg nata

выполняет действие эквивалентное

                       who | grep nata


   Признак того, что файл можно выполнять обычно  устанавли-
вает  компонента,  создавшая  данный файл (например компиля-
тор). Командные файлы, как правило, создаются непосредствен-
но  пользователем  и  данного  признака не содержат. Поэтому
возникает необходимость установить для файла признак "выпол-
нение  разрешено".  Для  этого  можно  использовать  команду
"chmod". Например, в результате работы команды:

                         chmod +х wg

файл "wg" получает признак "выполнение разрешено".

   Обработка параметров при запуске команды  выполняется  по
следующим правилам:


                                                          15


-    Обрабатываются все имеющиеся метасимволы языка.

-    Командная строка разбивается на  "слова"  -  последова-
     тельности    символов,    не    содержащие    символов-
     разделителей, к которым относятся пробел, символ начала
     строки и знак табуляции. Если в качестве параметра тре-
     буется передать текст, который содержит пробелы, он бе-
     рется в кавычки.

-    Выделенные слова последовательно присваиваются макропе-
     ременным с именами "0", "1", "2", и т.д.

-    В качестве значения макропеременной "#" устанавливается
     число параметров.

-    Значения  всех  параметров  (за  исключением  нулевого)
     присваиваются  макропеременой "*". Т.е. макровызов "$*"
     будет заменяться на строку,  содержащую  значения  всех
     параметров.

   Например, если командный файл "show" имеет вид:

       echo '
       Команда  $0 =' $0 '
       Значение $1 =' $1 '
       Значение $2 =' $2 '
       Число параметров =' $# '
       Значение $* =' $*

то в результате выполнения команды:

                     show первый второй

будет получен следующий текст:

       Команда  $0 = show
       Значение $1 = первый
       Значение $2 = второй
       Число параметров = 2
       Значение $* = первый второй



   3.1. Комментарии

В командной строке языка SHELL можно использовать  коммента-
рий,  который  служит  для  улучшения  читаемости  командных
файлов. Комментарий должен начинаться символом "#" и  распо-
лагаться  в  конце  командной  строки. Так как часть строки,
следующая за символом "#", не рассматривается  интерпретато-
ром, в ней могут встречаться любые символы.

   Например:

 #   Это   пример   комментария
 ls    #  Будет выполнена команда
       #  "ls" (это тоже комментарий)

Следует помнить, что  если  "#"  является  первым   символом
файла,  ему  придается  особый смысл - это признак того, что
должен использоваться интерпретатор языка "csh".


16

   3.2. Команда test


   Команда "test", хотя и  не  является  конструкцией  языка
SHELL, необходима при создании командных файлов. В результа-
те выполнения команды осуществляется проверка заданного  ус-
ловия  и сообщается код ее завершения, который может исполь-
зоваться в операторах условного перехода и цикла.

   Например, код завершения команды

                        test -f file

равен нулю, если файл "file" существует, и не равен нулю - в
противном случае.

   Основные возможности команды можно  проиллюстрировать  на
следующих примерах:

test s
     истинно, если аргумент s не является пустой строкой;

test -f file
     истинно, если файл существует;

test -r file
     истинно, если файл можно читать;

test -w file
     истинно, если в файл можно писать;

test -d file
     истинно, если файл является справочником.


   3.3. Оператор for


   В языке SHELL  существует  возможность  последовательного
повторения  какой-либо  группы  команд  для каждого элемента
указанного списка. Для этой цели используется оператор цикла
"for", который имеет следующий формат:

   for имя [in слово1 слово2 ...]
      do список_команд
      done

где "список_команд" - это последовательность одной или  нес-
кольких  простых команд, разделенных символами ";" или пере-
численных на разных строках. Зарезервированные слова "do"  и
"done" распознаются только в том случае, если они следуют за
символом новой строки или точки с запятой. "Имя" - это  мак-
ропеременная  языка  SHELL,  которая  в  процессе выполнения
"списка_команд" последовательно принимает  значения  "слово1
слово2  ...".  Если  конструкция  "in слово1 слово2 ..." от-
сутствует, то цикл выполняется один раз для каждого заданно-
го  параметра  (т.е. по умолчанию предполагается "in $*"). В
качестве примера можно привести команду "tel", которая прос-
матривает файл "/usr/lib/pfone", содержащий строки вида:





                                                          17

         ...
         Иванов И.И.   224 01 01
         Петров П.П.   123 07 07
         Сизов  В.И.   224 44 94
         ...


   Текст процедуры "tel":

      for i
      do grep $i usr/lib/pfone; done


   В результате выполнения команды:

                         tel Петров

будут напечатаны те строки файла  "/usr/lib/pfone",  которые
содержат последовательность символов "Петров", а команда:

                      tel Иванов Петров

напечатает  сначала  строки,  содержащие  последовательность
символов  "Иванов", а затем те строки, которые содержат сим-
волы "Петров".

   Еще одним примером использования цикла "for" является ко-
мандный файл "create":

                     for i do > $i; done

Результатом выполнения команды

                      create alpha beta

является создание двух пустых файлов "alpha" и "beta".


   3.4. Оператор case


   Рассмотрим в качестве примера командный файл  "add",  со-
держащий следующий текст:

 case $# in
      1) cat >> $1;;
      2) cat >> $2 < $1;;
      *) echo 'Формат: add [откуда] куда';;
 esac

При вызове команды с одним аргументом, например:

                          add file

параметр "$#" получает значение "1", и команда "cat" копиру-
ет  информацию  из  стандартного  файла  ввода в конец файла
"file". Команда:

                       add file1 file2

допишет содержимое файла "file1" в конец файла "file2". Если
число параметров, передаваемых команде "add", отлично от 1 и


18

от 2, то печатается сообщение "Формат: add куда [откуда]".

   Формат оператора "case":

case слово in
 [образец[|образец] ...) список_команд;;]
 ...
 [образец[|образец] ...) список_команд[;;]]
esac


   Интерпретатор последовательно сравнивает "слово" с каждым
из указанных "образцов". При обнаружении соответствия выпол-
няется записанный при образце "список_команд",  после  чего,
обработка  оператора  завершается.  Символ  "*" представляет
собой образец, который соответствует  любой  строке.  Каждый
"список_команд"  (за  исключением последнего) необходимо за-
вершать символами ";;".

   Первоеже совпадение слова с образцом полностью определяет
множество  выполняемых  команд. В следующем примере команды,
указанные за вторым символом "*", не будут  выполняться  ни-
когда:

     case $# in
          *) ...;;
          *) ...;;
     esac


   Оператор "case"  часто  используется  для  проверки  кор-
ректности  параметров.  Это можно проиллюстрировть следующим
фрагментом команды "cc":

for i
 do case $i in
   -[ocs]) ...;;
       -*) echo 'неизвестный ключ $i';;
      *.c) lib/c0 $i ...;;
        *) echo 'неизвестный параметр $i';;
    esac
done


   Если условием выполнения какого-либо "списка_команд"  яв-
ляется  группа  образцов,  то  при их перечислении в команде
"case" в качестве разделителя используется символ "|".  Так,
оператор:

     case $i in
        -х) echo $i
        -y) echo $i
     esac

может быть записан слудующим образом:

     case $i in
        -х|-y) echo $i
     esac





                                                          19

   При поиске соответствующего  образца  применимы  основные
соглашения об отмене специального значения метасимволов, так
образец в конструкции:

     case $i in
        ?) ...

будет соответствовать символу "?".


   3.5. Операторы while и until


   Оператор "while" предназначен для организации циклов, вы-
полнениекоторых производится до тех пор, пока код завершения
указанного списка команд равен нулю.

   Общая форма оператора "while":

       while список_команд_1
       [do список_команд_2]
       done


   В каждом цикле выполняются команды из  "списка_команд_1".
Оператор  "while" проверяет код завершения последней простой
команды из этого списка: если  он  равен  нулю,  выполняется
"список_команд_2"  и  цикл  повторяется,  иначе - выполнение
цикла завершается.

   Например, при выполнения следующих операторов:

       while test $1
       do ...
          shift
       done

и

       for i
       do ...
       done

будет получен одинаковый результат.

   Оператор "shift"  переименовывает  позиционные  параметры
"2, 3, ..." в параметры "1, 2, ..." соответственно; значение
параметра "1" теряется.

   Другим способом организации цикла является  использование
оператора "until":

       until список_команд_1
       [do список_команд_2]
       done

В отличие от "while" цикл "until" будет выполняться  до  тех
пор, пока код завершения последней команды "списка_команд_1"
не будет иметь нулевое значение.





20

   3.6. Операторы break и continue


   Операторы "break" и "continue" используются в конструкци-
ях "for", "while" и "until".

   Оператор "break" прерывает работу цикла, в теле  которого
он выполняется. В качестве примера можно привести программу,
которая выдает значения своих параметров,  расположенных  до
символа "%":

for i
do
case $i in
  %) break;;
  *) echo $i;;
esac
done


   Оператор "continue" осуществляет переход к следующей ите-
рации  цикла. Для примера рассмотрим командный файл, который
выводит только те параметры, которые начинаются с буквы:

 for i
 do
   case $i in
        [А-Яа-я]*) echo $i;;
        [A-Za-z]*) echo $i;;
                *) continue;;
   esac
 done



   3.7. Оператор if


   Условный оператор вида:

        if  список_команд_1
        then список_команд_2
        [else список_команд_3]
        fi

проверяет код завершения последней  простой  команды  "спис-
ка_команд_1":  если  он  равен нулю, выполняется "список_ко-
манд_2", иначе - "список_команд_3".

   Команда "if" может использоваться  совместно  с  командой
"test", например, для проверки существования файла:

       if test -f $1
       then  echo "ФАЙЛ $1 СУЩЕСТВУЕТ"
       else  echo "ФАЙЛ $1 НЕ СУЩЕСТВУЕТ"
       fi


   При многократном повторении условного  оператора,  напри-
мер:




                                                          21

        if ...
        then    ...
        else    ...
                if ...
                then    ...
                else    if ...
                        ...
                        fi
                fi
        fi

можно использовать сокращенную запись:

        if ...
        then    ...
        elif    ...
        then    ...
        elif    ...
        ...
        fi


   Конструкция

       if команда1
       then  команда2
       fi

может быть записана в виде:

                    команда1 && команда2

В конструкции

                    команда1 || команда2

"команда2" выполняется только в том случае, если  "команда1"
не  была выполнена успешно. Кодом завершения обеих конструк-
ций является код завершения последней простой команды.


   3.8. Локальный файл


   В процедуре "tel", рассмотренной в ранее, исходные данные
для  команды "grep" берутся из файла "/usr/lib/pfone". Обра-
батываемые данные могут  непосредственно  включаться  в  ко-
мандный  файл.  Для этого они оформляются в виде "локального
файла". В следующем примере:

     for i
     do grep $i <<!
        ...
        Иванов И.И.   224 01 01
        Петров П.П.   123 07 07
        Сизов  В.И.   224 44 94
        ...
     !
     done

строки, заключенные между символами "<<!" и "!",  передаются
команде  "grep"  в качестве данных стандартного файла ввода.


22

Строка-ограничитель "!" выбрана здесь произвольно:  главное,
чтобы  она совпадала с последовательностью символов, стоящей
за знаками "<<".

   Если следующая за "<<" последовательность символов  начи-
нается  со  знака "\", то прежде чем "локальный файл" станет
доступным командe, в нем выполняются все  подстановки  пара-
метров.

   Например, пусть файл "edg" содержит строки вида:

       ed $3 <<
       g/$1/s//$2/g
       w
       %

при вызове:

                  edg строка1 строка2 file

будет достигнут результат, который можно получить при выпол-
нении следующей последовательности команд:

       ed file <<%
       g/строка1/s//строка2/g
       w
       %



   3.9. Отладка командных файлов


   В SHELL  используются  два  механизма  отладки  командных
файлов. Первый из них:

                           set -v

выводит строки командного файла  по  мере  их  чтения.  Этот
режим  применяется при поиске синтаксических ошибок. Для его
использования не требуется производить модификацию командно-
го файла, например:

                        sh -v proc...

здесь "proc" - имя командного файла. Ключ "-v" может исполь-
зоваться  вместе  с  ключом "-n", предотвращающим выполнение
следующих за ним команд (команда "set -n" блокирует терминал
до тех пор, пока не вводится признак конца файла "EOF").

   Команда

                           set -х

выводит команды по мере их  выполнения.  Для  отмены  ключей
"-x" и "-v" можно воспользоваться командой

                            set -

а для установки - присвоить соответствующее значение  макро-
переменной "-".



                                                          23




      4. ПАРАМЕТРЫ И ОБЛАСТЬ ДЕЙСТВИЯ МАКРОПЕРЕМЕННЫХ


   Макропеременные, определенные в одном процессе,  при  от-
сутствии  явных указаний не доступны в других процессах. Для
того чтобы обеспечить возможность передачи порождаемому про-
цессу   какой-либо   информации,   в   языке  предусмотренны
средства, которые позволяют:

-    передавать команде параметры;

-    "экспортировать" определения макропеременных  из  среды
     текущего процесса в среду порождаемого;

-    определять макропеременные и передавать их  определения
     в среду порождаемого процесса без изменения среды теку-
     щего.

   Так, в следующем примере:

                     USER=nata команда

перед выполнением  файла  "команда"  макропеременная  "USER"
принимает значение "nata". При использовании флага "-k" опе-
раторы вида "имя=значение" могут вставляться в  любое  место
списка параметров. Такие "имена"  называются ключевыми пара-
метрами. Значения параметров присваиваются макропеременным с
именами  "1", "2", ... "N" (поскольку число в имени макропе-
ременной указывает позицию параметра в командной строке, та-
кие параметры называются позиционными).

   Для того чтобы присвоить значения позиционным  параметрам
непосредственно  из  командного  файла  используется команда
"set". Так, в следующем примере

                           set *

параметру "1" будет присвоено значение имени  первого  файла
текущего  справочника,  параметру  "2" - имя второго файла и
т.д.

   При выполнении команд интерпретатор производит  следующие
действия:

-    Подстановка значений параметров, например:

                           $user


-    Подстановка результатов выполнения команд, например:

                           `pwd`


     В тех случаях, когда в строке требуется выполнить  нес-
     колько  вложенных макроподстановок, используется встро-
     енная команда "eval". Например, если значением макропе-
     ременной  "X"  является  строка "$y", а макропеременной
     "y" - "pqr", то команда


24

                        eval echo $X


     выдаст строку "pqr".

     Результаты выполнения команды "eval" являются  входными
     данными  для  SHELL, который считывает их и выполняет в
     качестве команд. Таким образом, конструкция

              wg='eval who | grep'
              $wg fred


     эквивалентна команде

              who | grep fred


     В этом примере без команды "eval" не обойтись, так  как
     метасимвол  "|" при последующей макроподстановке не ин-
     терпретируется.

-    Интерпретация символов-разделителей.

     Символы, полученные в результате  выполнения  указанных
     выше подстановок, разбиваются затем на слова, не содер-
     жащие разделителей. "Пробелами" здесь названы  символы,
     являющиеся разделителями слов. Список этих символов со-
     держится в макропеременной "IFS"; по  умолчанию  к  ним
     относятся  пробел,  символы  горизонтальной табуляции и
     новой строки. Если специальное значение "пробела" отме-
     нить  одним  из  существующих способов, то он будет ин-
     терпретироваться  соответствующей   последовательностью
     символов. Например, командa

                          echo ''


     будет выдавать пустую строку,  поскольку  она  является
     первым  аргументом команды "echo", в то время как вызов
     команды

                         echo $null


     будет осуществляться без аргументов, если значение мак-
     ропеременной   "null"  не определено или определено как
     пустая строка.

-    Задание имен файлов.

     На этом этапе в словах  осуществляется  поиск  символов
     "*", "?" и "[...]" (являющихся образцами имен файлов) и
     замена каждого слова списком имен файлов, расположенных
     в  алфавитном порядке. Каждое имя файла рассматривается
     как отдельный параметр.

   Над словами, содержащимися в операторе цикла  "for",  вы-
полняются  все  перечисленные  действия. В опрераторе "case"
выполняется только подстановка значения параметра,  указыва-
емого после ключевого слова "case".



                                                          25

   Как отмечалось, в языке SHELL  существуют  три  механизма
экранирования  метасимволов  (с использованием символов "\",
'...' и "..."). Внутри строк, заключенных в двойные кавычки,
выполняются только подстановки значений параметров и резуль-
татов выполнения команд. Далее перечислены символы,  которые
при  заключении их в двойные кавычки не теряют своего специ-
ального значения:

$    подстановка значений параметров;

`    подстановка результатов выполнения команд;

""   ограничитель экранируемой строки;

\    экранирует метасимволы "$", "`",  " и "\".

   Например, в команде

                         echo "$х"

значение макропеременной "x" является единственным  аргумен-
том. Аналогично, в команде

                         echo "$*"

все  позиционные  параметры   рассматриваются   в   качестве
единственного аргумента; эта команда эквивалентна следующей:

                      echo "$1 $2 ..."

Макровызовы "$@" и "$*" идентичны, за  исключением  способов
их экранирования. Команды

                         echo "$@"

и

                     echo "$1" "$2" ...

эквивалентны. В результате их  выполнения  будут  выдаваться
значения всех позиционных параметров.

   На рисунке 1 показано воздействие механизмов  экранирова-
ния на каждый из метасимволов языка SHELL.

             Метасимволы

             $  *  `  "  '
        -|------------------|
       ' | -  -  -  -  -  t |
       ` | +  -  -  t  -  - |
       " | +  +  -  +  t  - |
        _|__________________|

   +   метасимвол экранируется;
   -   метасимвол не экранируется;
   t   ограничитель экранируемой строки.

               Рис.1





26

   4.1. Передача параметров


   Как позиционные, так и ключевые параметры могут быть  по-
лучены в процессе вызова командного файла. Ключевые парамет-
ры, кроме того, можно сделать доступными еще одним способом:
нужно  явно указать, что они вводятся в среду процесса (ста-
новятся макропеременными). Например, команда:

                      export USER BOX

указывает на то, что такими макропеременными являются "USER"
и  "BOX".  При  вызове командного файла создаются копии всех
макропеременных. Изменение значений макропеременных не вызы-
вает  их  модификации в порождающем процессе. Командный файл
не может изменить состояние порождающего процесса без явного
вызова со стороны порождающего процесса. (Исключение состав-
ляют дескрипторы распределенных файлов).

   Имена макропеременных, имеющих постоянные значения, могут
задаваться с помощью команды "readonly" (только для чтения).
Формат этой команды совпадает с форматом команды "export":

                      readonly имя...

После выполнения этой команды значения перечисленных  макро-
переменных больше изменить нельзя.


   4.2. Подстановка значений параметров


   Если параметру языка SHELL не было присвоено значение, то
он определяется как пустая строка. При выполнении команды

                        echo ${d-.}

выдается значение макропеременной "d", если она  определена,
или  символ  "."  - в противном случае. В команде "echo" ис-
пользуются обычные соглашения об отмене специальных значений
метасимволов.  Следовательно,  если значение макропеременной
"d" не было определено, то команда

                       echo ${d-'*'}

выведет символ "*". Аналогично, команда

                        echo ${d-$X}

если макропеременная "d" определена, выдаст ее значение, ес-
ли нет - значение макропеременной "X".

   Значение по умолчанию макропеременной  может быть опреде-
лено следующим образом:

                        echo ${d=.}

если макропеременная "d"  не  определена,  ей  присваивается
символ   "."   (для   позиционных   параметров   обозначение
${...=...} использовать нельзя).




                                                          27

   Команда

                    echo ${d?сообщение}

выдает значение макропеременной "d", если оно определено,  и
"сообщение"  - если не определено. В последнем случае выпол-
нение командного файла  завершается.  Если  "сообщение"  от-
сутствует, то выдается стандартная диагностика интерпретато-
ра. Командный файл, часть параметров которого  должна  иметь
определенные значения, может начинаться следующим образом:

          : ${USER?} ${HOME?} ${BIN?}
          ...

Двоеточие ":" представляет собой  встроенную  команду  языка
SHELL, предназначенную для оценки значений своих параметров.
Если значение хотя бы одной из переменных "USER", "HOME" или
"BIN"  не  определено, выдается диагностика и выполнение ко-
мандного файла прекращается.


   4.3. Подстановка результатов выполнения команд


   В языке SHELL существует  возможность  использования  ре-
зультата  выполнения  команд  в  различных целях. Так, стан-
дартным выходом команды "pwd" является имя текущего справоч-
ника,   и   если   таким  справочником  является,  например,
"/usr/nata/bin", то команда

                          d=`pwd`

будет эквивалентна команде

                      d=/usr/nata/bin

Строка, заключенная между обратными кавычками `...`, воспри-
нимается  как  команда  и  заменяется результатом выполнения
этой команды. Команды записываются с использованием  обычных
соглашений  об  отмене специальных значений метасимволов, за
исключением того, что специальное значение символа  обратной
кавычки "`" отменяется символом "\". Например, команда

                       ls `echo "$1"`

эквивалентна команде

                           ls $1


   Везде, где  разрешена  подстановка  значений  параметров,
может  производиться  и  подстановка  результатов выполнения
команд (в том числе и в локальных файлах). Обработка резуль-
татов  в  обоих случаях выполняется одинаково. Это позволяет
использовать в процедурах языка SHELL команды, предназначен-
ные для обработки строк. Примером такой команды является ко-
манда  "basename",  которая  удаляет  из   слова   указанный
суффикс. Например, в результате выполнения команды

                     basename main.c .c

будет получена последовательность символов "main". Использо-


28

вание  команды  "basename" можно проиллюстрировать следующим
фрагментом команды "cc":

        case $A in
             ...
             *.c) B=`basename $A .c`
             ...
        esac

В этом примере макропеременной  "B"  присваивается  значение
макропеременной "A", из которой удален суффикс ".c".


   4.4. Обработка ошибок


   Действия интерпретатора при обнаружении ошибки зависят от
двух  обстоятельств: типа ошибки и режима работы интерпрета-
тора. Режим работы интерпретатора считается интерактивным  в
том случае, если ввод/вывод информации осуществляется с тер-
минала или интерпретатор вызван с ключом "-i".

   Приведем список причин, которые приводят  к  ошибкам  при
выполнении команды:

   - неверное указание файлов ввода/вывода  (например,  файл
     не существует или не может быть создан);

   - самой команды не существует, или она не может быть  вы-
     полнена;

   - команда вызвалась нормально, но ее код завершения имеет
     ненулевое значение.

   Если интерпретатор работает в интерактивном  режиме,  то,
независимо  от  результата завершения предыдущей команды, он
переходит к выполнению следующей.

   В не интерактивном режиме  два  вида  ошибок  приводят  к
прекращению обработки командного файла:

   - синтаксическая ошибка в операторах  управления  (while,
     until, if, for);

   - ошибка при выполнении встроенной команды.

   Для того чтобы обеспечить прекращение выполнения  команды
при  обнаружении  любой  из указанных ошибок, при вызове ин-
терпретатора необходимо использовать ключ "-e".


   4.5. Обработка прерываний


   Сигналы, вызывающие прерывание выполнения команды,  пере-
числены в табл.1.

   В зависимости от своего режима работы, при получении сиг-
нала  интерпретатор  поступает следующим образом. Если режим
работы - интерактивный, то  (также  как  и  при  обнаружении
ошибки)  завершив  выполнение текущей команды, он перейдет к
выполнению следующей. Если же режим -  неинтерактивный,  ин-


                                                          29

терпретатор  завершит выполнение текущей команды, после чего
либо прекратит  работу,  либо  возвратится  в  интерактивный
режим.

                                                   Таблица 1

                   Сигналы системы ДЕМОС

------------------------------------------------------------
Сигнал Описание
------------------------------------------------------------
0      выход из интерпретатора (по  любой  причине,  включая
       достижение конца файла)
1      "зависание"
2      прерывание
3*     выход (<ctrl/Q> создается файл "core", содержащий ко-
       пию оперативной памяти процесса)
4*     запрещенная команда (не сбрасывается после приема)
5*     использование команды BPT (прерывание трассировки)
6*     использование команды прерывания ввода/вывода IOT
7*     использование команды EMT
8*     ошибка операции с плавающей точкой
9      уничтожить процесс (не может быть перехвачен или про-
       игнорирован)
10*    ошибка шины
11*    нарушение защиты памяти
12*    неправильный параметр в системном вызове
13     запись по каналу межпроцессной связи  при  отсутствии
       чтения процессом-получателем
14     прерывание по заданному времени
15     прерывание программы (по команде kill)
16     не используется
------------------------------------------------------------

   Команды, отмеченные знаком "*", осуществляют  копирование
оперативной памяти процесса. Однако, сам интерпретатор игно-
рирует эти сигналы.

   При поступлении сигнала прерывания выполняются  некоторые
стандартные  действия,  после чего обрабока командного файла
обычно завершается. Если это по тем  или  иным  причинам  не
устраивает пользователя, он может задать свои методы реакции
на определенные типы прерываний. Для этой цели в языке SHELL
применяется встроенная команда "trap". Например, команда

                trap 'rm /tmp/ps$$; exit' 2

перехватывает сигнал 2 ("прерывание") и выполняет команду

                     rm /tmp/ps$$; exit

Встроенная команда "exit"  прерывает  выполнение  командного
файла.

   Существует три способа обработки сигналов:

1. Сигналы игнорируются (в этом случае сигнал вообще не  по-
   сылается процессу).

2. Сигналы перехватываются (реакция на сигнал обеспечивается
   самим процессом).



30

3. Сигналы пропускаются без обработки. Работа  процесса  за-
   вершается.

   Если при входе в командный файл сигнал  игнорируется,  то
игнорируется и команда "trap".

   Если аргументом команды "trap" является пустая строка, то
процедура  игнорирует сигналы. В качестве примера можно при-
вести фрагмент команды "nohup":

                      trap '' 1 2 3 15

после выполнения которого как процедура, так и вызывающие ее
команды будут игнорировать перечисленные сигналы.

   Стандартная реакция на сигналы может быть  восстановлена,
например, следующей командой:

                          trap 2 3

Список текущих значений сигналов системы может быть  получен
с помощью команды

                            trap


   Еще одним примером использования команды "trap" (без пос-
ледующего  выхода  из  командного  файла) является процедура
"scan", которая осуществляет просмотр подсправочников в  те-
кущем справочнике и выполнение команд, вводимых с терминала,
до получения сигнала "конец файла" или "прерывание".  Сигнал
"прерывание" действует только по окончании выполнения коман-
ды. Текст процедуры "scan" имеет следующий вид:

    d=`pwd`
    for i in *
    do if test -d $d/$i
       then cd $d/$i
            while echo "$i:"
                trap exit 2
                read x
            do trap : 2; eval $x; done
       fi
    done

Встроенная команда "read x" считывает строки из файла  стан-
дартного  ввода и присваивает результат их выполнения макро-
переменной "x". Сигналы "конец-файла" или "прерывание" прек-
ращают выполнение этой команды с кодом завершения, не равным
нулю.














                                                          31




                  5. ВЫЗОВ ИНТЕРПРЕТАТОРА


   Вслед за регистрацией пользователя в системе  (с  помощью
команды  "login") вызывается интерпретатор языка SHELL. Если
регистрационный  справочник   пользователя   содержит   файл
".profile",  то прежде чем с терминала будет принята хотя бы
одна команда, интерпретатор выполняет этот файл  (подразуме-
вается, что файл ".profile" содержит команды).

   При вызове могут указываться следующие ключи:

-c строка
     Команды считываются из заданной "строки".

-s   Команды читаются из стандартного файла ввода. Сообщения
     интерпретатора записываются в стандартный файл диагнос-
     тик.

-i   Интерактивный режим работы.

   Если первым символом параметра "0" является знак "-",  то
команды считываются из файла ".profile".






































32

                                                 ПРИЛОЖЕНИЕ 


         1. СВОДКА ОСНОВНЫХ КОНСТРУКЦИЙ ЯЗЫКА SHELL


                                                   Таблица 2

                    СПЕЦИАЛЬНЫЕ СИМВОЛЫ

------------------------------------------------------------
Символ Описание
------------------------------------------------------------
#      коментарий;
|      создать канал связи процессов;
~      создать канал связи процессов;
;      разделитель команд;
&      запустить следующий процесс, не ожидая окончания пре-
       дыдущего;
&&     выполнить следующую команду, если код завершения пре-
       дыдущей равен нулю;
||     выполнить следующую команду, если код завершения пре-
       дыдущей не равен нулю;
'...'  литеральная константа;
"..."  после подстановки  значений  макропеременных,  строка
       рассматривается как литеральная константа;
\      отменяет специальное значение следующего за ним  сим-
       вола.
------------------------------------------------------------

                                                   Таблица 3

                         ВВОД-ВЫВОД

------------------------------------------------------------
Конструкция  Описание
------------------------------------------------------------
[d]<         следующий параметр является именем файла, кото-
             рый  используется в качестве стандартного файла
             ввода с дескриптором "d" (по умолчанию d=0);
[d]>         следующий параметр является именем файла, кото-
             рый  используется в качестве стандартного файла
             вывода с дескриптором "d" (по умолчанию d=1);
[d]>>        то же что ">", за исключением того, что выводи-
             мая информация дописывается к концу содержимого
             файла;
[d]<<        ввод осуществляется до тех пор, пока не  встре-
             чается  последовательность символов, стоящая за
             данной конструкцией;
[d]<&цифра   в качестве стандартный файла ввода используется
             файл с дескриптором "цифра";
[d]>&цифра   в качестве файла стандартного вывода  использу-
             ется файл с дескриптором "цифра";
[d]<&-       закрыть стандартный файл ввода;
[d]<>        открыть указанный файл для чтения (записи).
------------------------------------------------------------








                                                          33


                                                   Таблица 4

                    ЗАДАНИЕ ИМЕН ФАЙЛОВ

------------------------------------------------------------
Конструкция  Описание
------------------------------------------------------------
?            соответствует одиночному символу;
*            соответствует строке символов (в т.ч. пустой);
[...]        соответствует одному из перечисленных символов;
             пара  символов,  разделенная  знаком "-", соот-
             ветствует любому символу из  указанного  проме-
             жутка;
------------------------------------------------------------

                                                   Таблица 5

              ПОДСТАНОВКА ЗНАЧЕНИЙ ПАРАМЕТРОВ

------------------------------------------------------------
Конструкция   Описание
------------------------------------------------------------
$n            заменить "$n" значением "n";
$*            "1 2 ..."
$@            "1" "2" ...
$#            число позиционных параметров;
$-            ключи, которые вводятся при вызове или  с  по-
              мощью команды "set";
$?            код завершения последней команды;
$$            номер текущего процесса;
$!            номер процесса последней фоновой команды;
имя=значение  определение макропеременной;
${имя-слово}  если "имя"  определено,  подставить  значение,
              иначе - "слово";
${имя=слово}  использовать значение "имени"; если не опреде-
              лено - присвоить и использовать значение "сло-
              во";
${имя?слово}  использовать значение "имени", если  определе-
              но,  иначе  -  напечатать "слово" и прекратить
              выполнение командного файла;
${имя+слово}  использовать "слово", если  "имя"  определено,
              иначе - ничего не делать;
$HOME         имя справочника для команды "cd" без  парамет-
              ров;
$PATH         список имен справочников для поиска команд;
$MAIL         файл для приема почты;
$PS1          подсказка интерпретатора (по умолчанию "$");
$PS2          подсказка интерпретатора для продолжении ввода
              команды (по умолчанию ">");
$IFS          разделители "слов" командной строки (по  умол-
              чанию пробел, знак табуляции и новой строки);
$TERM         тип терминала.
------------------------------------------------------------










34


                       КОМАНДНЫЙ ЯЗЫК


for имя [in слово...]
do список_команд
done


case слово in
     [обр1 [|обр2]...) список_команд;;]
     ...
esac


if список_команд
then список_команд
[elif список_команд then список_команд]
[else список_команд]
fi


while список_команд
[do список_команд]
done


until список_команд
[do список_команд]
done


(список_команд)


{ список_команд; }


break [n]
     выход из циклов "for", "case", "while" или  "until"  на
     уровне "n";

continue
     переход к следующей итерации цикла "for",  "while"  или
     "until";

exit [N]
     выход с кодом завершения "N";

:    не производит никаких действий, за исключением  подста-
     новки значений макропеременных.













                                                          35


                     ВСТРОЕННЫЕ КОМАНДЫ


. файл
     выполнить командный "файл" в рамках текущего процесса;

eval [команда ...]
     провести  все  макроподстановки  и  выполнить  "команду
     ...";

exec [команда ...]
     текущий процесс заменить процессом выполнения  "команды
     ...";

export [имя ...]
     копировать определение макропеременной  "имя"  в  среду
     порождаемых процессов;

read имя ...
     считать файл стандартного ввода  и  присвоить  значение
     макропеременной "имя";

readonly [имя ...]
     запретить переопределение макропеременой;

set [-ekntuvx [пар ...]]
     установить режимы работы интерпретатора (значения  клю-
     чей см. в описании команды "sh");

shift
     переименовать позиционные параметры; 1=2 ...;

times
     выдать время, затраченное на выполнение процесса;

trap [команда] [n]
     выполнить "команду", если получен сигнал "n";

umask [nnn]
     маска создания файла -  обратный  код  (в  восьмеричной
     системе);

wait [pid]
     ожидать окончания процесса с номером "pid".



















36



                           СОДЕРЖАНИЕ



1.  ВВЕДЕНИЕ...........................................    3

2.  ОСНОВНЫЕ ПОНЯТИЯ...................................    4
    2.1. Простые команды...............................    4
    2.2. Фоновые процессы..............................    5
    2.3. Задание имен файлов...........................    5
    2.4. Отмена специального значения метасимволов.....    6
    2.5. Задание файлов ввода/вывода...................    7
    2.6. Связь процессов, конвейеры и фильтры..........    8
    2.7. Макропеременные...............................    9
    2.8. Выдача подсказок..............................   11
    2.9. Составные команды.............................   12
    2.10.Встроенные команды............................   12

3.  КОМАНДНЫЕ ФАЙЛЫ....................................   15
    3.1. Комментарии...................................   16
    3.2. Команда test..................................   17
    3.3. Оператор for..................................   17
    3.4. Оператор case.................................   18
    3.5. Операторы while и until.......................   20
    3.6. Операторы break и continue....................   21
    3.7. Оператор if...................................   21
    3.8. Локальный файл................................   22
    3.9. Отладка командных файлов......................   23

4.  ПАРАМЕТРЫ И ОБЛАСТЬ ДЕЙСТВИЯ МАКРОПЕРЕМЕННЫХ.......   24
    4.1. Передача параметров...........................   27
    4.2. Подстановка значений параметров...............   27
    4.3. Подстановка результатов выполнения команд.....   28
    4.4. Обработка ошибок..............................   29
    4.5. Обработка прерываний..........................   29

5.  ВЫЗОВ ИНТЕРПРЕТАТОРА...............................   32

ПРИЛОЖЕНИЕ 1.  СВОДКА   ОСНОВНЫХ   КОНСТРУКЦИЙ    ЯЗЫКА
    SHELL..............................................   33






















                                                          37

