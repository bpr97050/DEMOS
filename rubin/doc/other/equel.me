.ct
.he ''Программирование на EQUEL''
.ft B
.de $0
.if \\$3<2 \{
.of '%''\\$1'
.ef '\\$1''%'
.\}
..
'sp 4
.t0
П Р О Г Р А М М И Р О В А Н И Е   Н А
Я З Ы К Е    E Q U E L
.t1
.tr @"
.ft R
.bp
.sh 1 "ВВЕДЕНИЕ. ЧТО ТАКОЕ EQUEL"
.pp
Язык \fBEQUEL\fR -"встроенный (embedded) QUEL" является
языком манипулирования данными системы \fBРУБИН\fR. EQUEL встроен в язык Си
и обеспечивает доступ программ, написанных на языке Си, ко всем
возможностям СУБД. Он представляет собой некоторое
расширение языка Си, в который встроены операторы языка манипулирования
данными \fBQUEL\fR, операторы управления системой \fBРУБИН\fR
и операторы описания.
.pp
Программа, написанная на языке EQUEL, обрабатывается прекомпилятором
\fBequel\fR, затем транслируется обычным Си-компилятором
с использованием библиотеки служебных программ \fBlibq.a\fR.
При выполнении оператора вызова СУБД вызывается ядро СУБД РУБИН и
начинает взаимодействовать с программой с помощью программных каналов
(скрыто от программиста). После вызова СУБД программа может выдавать
операторы манипулирования данными и операторы запроса данных, и
таким образом обменивается информацией с базой данных.
.pp
Обычно (при вызове с терминала) СУБД РУБИН состоит из терминального
монитора и ядра, которые взаимодействуют следующим образом:
.(l
.tr %

\z %%\z %%\z %%\z<%%\z %%\z %%\zТ%%\zе%%\zр%%\zм%%\zи%%\zн%%\zа%%\zл%%\z %%\z %%\z %%\z>%%\z %%\z %%\z %%\z<%%\z-%%\z-%%\z-%%\z-%%\z-%%\z-%%\z-%%\z-%%\z-%%\z-%%\z-%%\z-%%\z-%%\z-%%\z+%%
\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%\z %%\z!%%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z^%%
\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%\z %%\z!%%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%
\z %%\z %%\z<%%\z %%\zТ%%\zе%%\zр%%\zм%%\zи%%\zн%%\zа%%\zл%%\zь%%\zн%%\zы%%\zй%%\z %%\zм%%\zо%%\zн%%\zи%%\zт%%\zо%%\zр%%\z %%\z>%%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%
\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%\z %%\z!%%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%
\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%\z %%\z!%%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%
\z %%\z %%\z<%%\z %%\zЯ%%\zд%%\zр%%\zо%%\z %%\zС%%\zУ%%\zБ%%\zД%%\z %%\zР%%\zУ%%\zБ%%\zИ%%\zН%%\z %%\z>%%\z-%%\z-%%\z-%%\z-%%\z-%%\zд%%\zа%%\zн%%\zн%%\zы%%\zе%%\z-%%\z-%%\z-%%\z>%%\z+%%

.tr %%
.)l
.lp
При вызове задачи, написанной на EQUEL, она заменяет терминальный монитор:
.(l
.tr %
\z %%\z %%\z %%\z[%%\z %%\z<%%\z %%\z %%\zТ%%\zе%%\zр%%\zм%%\zи%%\zн%%\zа%%\zл%%\z %%\z %%\z %%\z>%%\z %%\z]%%
\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%\z %%\z %%\z!%%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z^%%
\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%\z %%\z %%\z!%%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%
\z %%\z %%\z %%\z %%\z<%%\z %%\zП%%\zр%%\zо%%\zг%%\zр%%\zа%%\zм%%\zм%%\zа%%\z %%\zн%%\zа%%\z %%\zE%%\zQ%%\zU%%\zE%%\zL%%\z %%\z\%%\z %%\z>%%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%
\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%\z %%\z %%\z!%%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z %%\z!%%
\z %%\z %%\z %%\z<%%\z %%\zя%%\zд%%\zр%%\zо%%\z %%\zС%%\zУ%%\zБ%%\zД%%\z %%\zР%%\zУ%%\zБ%%\zИ%%\zН%%\z %%\z>%%\z-%%\z-%%\z-%%\z-%%\zд%%\zа%%\zн%%\zн%%\zы%%\zе%%\z-%%\z-%%\z-%%\z>%%\z+%%

.tr %%
.)l
.sh 2 "Подготовка программы на EQUEL"
.pp
Программа на EQUEL представлет собой смесь операторов и описаний EQUEL,
которые начинаются с двух символов "##", и обычных операторов языка Си,
и размещается в одном или нескольких файлах с расширением ".q".
Трансляция осуществляется в несколько этапов.
Сначала программа обрабатывается
прекомпилятором
\fBequel\fR, который заменяет конструкции языка EQUEL на обращения к
соответствующим библиотечным функциям и переписывает остальные строки
программы без изменения:
.(l
 \fBequel\fR [\fIфлаги\fR] \fIfile1\fR.q [\fIфлаги\fR] [\fIfile2\fR.q] ...
.)l
(флаги описаны в справочном руководстве по СУБД РУБИН,
раздел \fBequel(demos)\fR).
Результат записывается в файлы \fIfile1\fR.c, \fIfile2\fR.c ...
Затем они компилируются транслятором языка Си с использованием
библиотеки языка EQUEL:
.(l
 \fBcc\fR [\fIфлаги\fR] \fIfile1\fR.c ... \fB-lq\fR
.)l
(возможна отдельная трансляция и редактирование связей, но в любом случае
должна быть подключена библиотека \fB-lq\fR или заменяющая ее.)
.pp
При программировании на EQUEL некоторые ограничения налагаются и на
всю программу на языке Си, которая должна вполне определенным
образом обрабатывать прерывания с терминала и ошибки,
возникающие при выполнении операторов EQUEL. Кроме
того, глобальные переменные и служебные программы EQUEL начинаются с
символов II..., и такие имена не должны применяться пользователем EQUEL.
.sh 2 "Простой пример"
.pp
Ниже будет рассмотрена простейшая программа на языке EQUEL.
.(l
/*
*  Это простой пример программы на EQUEL.
*  Она работает с отношением СЛУЖАЩИЕ в
*  базе данных "demo".
*  После вызова программы введите фамилию
*  служащего, и программа либо
*  выдаст его оклад, либо сообщение о том,
*  что такого служащего нет.
*  Список служащих можно получить, набрав
*  "?" в ответ на запрос имени.
*
*  Для выхода введите CTRL/D.
*
*  Трансляция и запуск этой программы на
*  счет осуществляются
*  командами:
*
*  equel equeldemo.q
*  cc    equeldemo.c -lq
*  a.out
*/
main(ac,av)
int ac;
/* 1.!Это пометка для данной инструкции!*/
##char *av[];
{
##  char    NAME[20];
##  int     SAL;
    char    flag;
    if ( ac != 2)
/* 2. */
##  rubin demo
    else
/* 3. */
##  rubin av[1]
/* 4. */
##  range of e is служащие
    while (eread(NAME))
    {
      if(NAME[0] == '?')
      {
/* 5. */
##       print СЛУЖАЩИЕ
       continue;
       }
       flag = 0;
/* 6. */
##   retrieve (SAL = e.оклад) where
/* 7. */
##    e.имя = NAME
/* 8. */
##    {
printf("Тов. %s имеет оклад %d руб.\en",NAME,SAL);
	 flag = 1;
/* 9. */
##    }
    if(!flag)
printf("Тов. %s неизвестен системе\en",NAME);
    }
/* 10. */
##  exit
}

eread(p)
char	*p;
{
  int    c;
  printf("Введите имя служащего:");
  while((c = getchar()) > 0)
  {
	  if(c == '\en')
	  {
		  *p = 0;
		  return(1);
	  }
	  *p++ = c;
  }
  return(0);
}
.)l
.pp
На примере данной программы рассмотрим простейшие операторы EQUEL.
Все строки, относящиеся к EQUEL, начинаются с "##". Первой такой
строкой является строка, следующая за комментарием /* 1. */
Это пример оператора описания - он сообщает прекомпилятору о том, что
описанная в нем переменная является переменной EQUEL и
может встречаться в последующих операторах языка.
.pp
Номером /* 2. */ помечен первый исполняемый оператор EQUEL.
Как и следовало ожидать, этот оператор вызывает СУБД
и открывает базу данных \fBdemo\fR.
В данном случае оператор просто записан в строке и выполняется без
всяких подстановок. А как же быть, если что-то в нем неизвестно заранее
(например, это может быть имя базы данных)? В этом случае как раз и
используются описанные ранее переменные, что иллюстрирует строка /* 3. */:
в качестве имени базы данных здесь используется имя символьной переменной
EQUEL, и при выполнении происходит подстановка значения этой переменной
(в данном случае оно подставляется в качестве имени базы данных).
.pp
Строки /* 4. */ и /* 5. */ еще раз иллюстрируют принцип языка EQUEL -
большинство операторов QUEL может быть просто записано в EQUEL вслед за
двумя символами "##" в начале строки. При этом имена переменных EQUEL
будут, как правило, заменяться их текущим значением.
.pp
Но как же программа получает информацию из базы? Это иллюстрируется
оператором в строках /* 6. */ - /* 9. */ - оператором выборки \fBretrieve\fR
без результирующего отношения (эквивалентным выводу на экран при
работе в мониторе). Такой оператор состоит из запроса (строки 6, 7) и
блока операторов языка Си, взятого в скобки "##{", "##}" (строки 8 - 9).
Для каждого выбранного в операторе кортежа производится присваивание
полученных значений переменным из списка результатов
(в данном случае значение присваивается переменной
\fBSAL\fR, см. строку 6) и выполняется блок Си-программы между
скобками. Можно заметить также, что в строке
7 в начале выполнения запроса в него подставляется значение
переменной \fBNAME\fR.
.pp
И, наконец, работа СУБД завершается оператором "##exit" (строка 10).
Конечно, такой пример крайне примитивен, но он все-таки позволяет
получить некоторое представление о том, что же такое EQUEL.
.sh 1 "ОСНОВНЫЕ ПОНЯТИЯ"
.sh 2 "Программа на языке EQUEL"
.pp
Программа на языке EQUEL состоит из смеси произвольных операторов языка Си,
которые просто переписываются прекомпилятором без изменений, и
операторов EQUEL, начинающихся с символов "##" в начале строки.
При этом EQUEL не анализирует синтаксическую правильность строк
на Си, и любые ошибки в ней выявляются на этапе трансляции.
.pp
Операторы EQUEL делятся на следующие группы:
.jp
Операторы описания переменных EQUEL;
.jp
Выполняемые операторы;
часть этих операторов просто повторяет соответствующие конструкции
языка QUEL, имеются также операторы вызова и окончания работы СУБД,
операторы выбора данных и параметрические операторы, отличающиеся от
обычных другим механизмом подстановки значений переменных;
.jp
Операторы начала и конца блока Си, которые используются для ограничения
области действия переменных и выделения Си-блока в операторах выбора.
.sh 2 "Базовые конструкции языка"
.pp
Предложения языка (кроме описаний переменных)
состоят из ключевых слов и символов пунктуации языка
QUEL,
имен (не совпадающих с именами переменных либо замаскированных),
имен переменных и констант.
Ниже будут разобраны все эти понятия.
.sh 3 "Переменные, их типы и описания"
.pp
Все переменные Си, значения которых используются в операторах EQUEL,
должны быть предварительно описаны.
Описание представляет собой
обычный оператор описания языка Си, перед которым (с начала строки)
вставлен префикс "\fB##\fR".
Возможны следующие варианты:
.(l
 \fB## char   	\fIсписок_описаний\fB;\fR
 \fB## short  	\fIсписок_описаний\fB;\fR
 \fB## int    	\fIсписок_описаний\fB;\fR
 \fB## long   	\fIсписок_описаний\fB;\fR
 \fB## float  	\fIсписок_описаний\fB;\fR
 \fB## double 	\fIсписок_описаний\fB;\fR
.)l
Приведенные операторы определяют переменные целого и
плавающего типов. \fIСписок_описаний\fR составляется по правилам языка Си,
но возможность образования сложных типов (массивов, указателей и т.п.)
ограничена. Возможны следующие сложные типы данных:
.(l
\fB  \fIимя\fR  \fR   - простой (скалярный) тип;
\fB *\fIимя\fR  \fR   - указатель;
\fB  \fIимя\fB[]\fR   - массив, длина массива может быть опущена;
\fB *\fIимя\fB[]\fR   - массив указателей
	    а также простейшие комбинации вида **имя,
	    **имя[] и т.п...
.)l
Все остальные варианты запрещены, а переменные типа char не могут
быть скалярными переменными, так как этот тип используется для хранения
строк. Не существует также никакого способа описать переменную,
аналогичную формату i1 СУБД РУБИН.
.pp
Кроме того, могут быть описаны структуры:
.(l
 \fB## struct \fR[\fIимя_структуры\fR]\fB {\fR
 \fB## \fIописания элементов структуры  \fR
 ...
 \fB## }\fI список_описаний\fB;\fR
.)l
Ограничения на сложные формы описаний аналогичны вышеперечисленным.
Вложенные структуры не допускаются.
.pp
Допустимы описания размещения объектов: extern, auto, static.
Инициализируемые переменные описываются следующим образом:
.(l
 \fB## \fIтип список_описаний \fB=\fR
 \fI инициализация\fB;\fR
.)l
Заметим, что вторая и последующие строки здесь не обрабатываются
прекомпилятором. Помещение списка инициализаций в одну строку с
описанием переменной, равно как и вынос знака "="
на следующую строку, \fBзапрещены\fR.
.pp
Все операторы описания прекомпилятор после обработки и удаления
начальных "##" помещает в выходной файл на Си.
.pp
Данные типа дата и время хранятся в переменных типа long,
а для их ввода и вывода в библиотеку EQUEL включены специальные функции
преобразования (см. ниже раздел "Функции преобразования. Работа с
датой и временем").
.pp
Для лучшего соответствия между описаниями в EQUEL и в базе,
в стандартный файл вставок " # include <rubin/equel.h>"
и в прекомпилятор EQUEL включены следующие описания типов:
.(l
 typedef short  EQ_i2;
 typedef long   EQ_i4;
 typedef float  EQ_f4;
 typedef double EQ_f8;
 typedef long   EQ_date;
 typedef long   EQ_time;
.)l
Эти типы могут использоваться в программе наряду со стандартными
(если включен файл вставок "<rubin/equel.h>").
.pp
Следует иметь в виду следующие ограничения:
.jp
EQUEL не обрабатывает операторы CPP ( #define, #include, #ifdef ...)
.jp
Имена переменных не должны совпадать с ключевыми словами
языка QUEL (записанными строчными буквами);
.pp
Область действия переменных может быть ограничена блоком языка Си,
если этот блок ограничен скобками EQUEL:
.(l
 \fB##{\fR -- начало блока
 \fB##}\fR -- конец  блока
.)l
Такие скобки обрабатываются прекомпилятором и затем транслируются
в обычные скобки языка Си: "{" и "}".
.pp
Формальные параметры могут быть описаны, как и обычные переменные,
но они будут иметь в EQUEL глобальную область действия, поскольку не
существует способа
взять их в скобки.
.pp
Примеры корректных описаний:
.(l
 ## extern long YEAR;
 ## static char NAME[MAXLEN], *myptr;
 ## char *av[];
 ## struct xxx { char nm[41];
 ## double fff;
 ## int num; } **ps;
 ## char *base =
 "mybase";
.)l
Примеры некоректных описаний:
.(l
 ## char l; -- Не допускается простой тип char
 ## long *fun();  -- Не допускаются функции
 ## int len = 10; -- Инициализация прямо в строке
 ## new_type xx;  -- не допускаются неизвестные типы
 ## struct { struct dir *d; } ppl;
    -- Не допускаются вложенные структуры
.)l
.sh 3 "Константы"
.pp
Синтаксис констант EQUEL сходен с синтаксисом констант в языке QUEL.
Допускаются целые, вещественные и строковые константы.
Не допускаются константы типа ДАТА и ВРЕМЯ, а также
форматы констант, допустимые в Си и недопустимые в QUEL.
.sh 3 "Правила подстановки переменных"
.pp
Все выполняемые операторы EQUEL представляют собой некоторое
расширение операторов языка QUEL, записанных с префиксом "##".
Почти везде, где допускаются имена,
могут быть подставлены переменные либо простейшие выражения строкового
(char *)  типа из этих переменных. Везде, где в QUEL допускаются
константы, в EQUEL могут быть использованы простейшие выражения
строкового, целого или вещественного типа. Если в операторе нужно
явно указать имя, совпадающее с именем существующей переменной, перед
этим именем нужно добавить символ "#" (замаскировать имя).
.pp
Выражения могут содержать только имя_переменной, операторы (унарные)
"*" и "->", операцию индексации [целое_выражение]; запрещено использование
скобок "()" и других операций.
.pp
Например, пусть имеется следующее описание:
.(l
 ## char *p;
 ## struct xxx
 ## {
	int i;
 ##     char *px;
 ##     int *ip;
 ## }  **str_var;
.)l
Следующие операторы будут корректны:
.(l
 ## delete #p where #p.#ip = *str_var[0]->ip
 ## delete p  where p.name = str_var[i]->px
.)l
Заметим, что в первой строке оператор относится к кортеж-переменной p,
а во второй ее имя берется из переменной p.
А вот следующие конструкции будут некорректны:
.(l
 ## delete #p where #p.#ip = *(*str_var)->ip
 ## replace #p(ip = 10)
 ## delete #p where #p.#ip = (int)p;
.)l
В первом случае недопустимы скобки. Во втором операторе имя
(в скобках) задается переменной ip целого типа. В третьем - используется
оператор преобразования типа языка Си.
.pp
Сведем эти правила вместе.
В выполняемых операторах EQUEL встречаются следующие конструкции:
.jp
ключевые слова и символы пунктуации
должны быть записаны явно.
.jp
имена (базы данных, кортеж-переменных, отношений, атрибутов),
специальные ключевые слова ("into", "from), имена функций записываются
по одной из следующих форм:
.ba +4
.ip "\fB#\fIимя\fR"
подставляется само это имя;
.ip "\fIпростейшее выражение строкового типа\fR"
в качестве имени подставляется значение этого выражения;
правила составления выражения приведены выше;
.ip "\fIимя\fR"
если это имя не совпадает с именами описанных переменных,
то подставляется само это имя, иначе подставляется значение
соответствующей переменной.
.ba -4
.jp
константы могут быть либо записаны явно (в синтаксисе QUEL,
за исключением типа дата/время), либо в виде простейшего
выражения из переменных EQUEL, которое подставляется во время
выполнения как константа соответствующего типа.
.jp
в некоторых конструкциях языка выражение текстового типа заменяет
целиком все условие выборки.
.jp
каждый элемент списка атрибутов в операторе выборки (retrieve без
результирующего отношения, подробнее см. ниже) имеет вид:

 \fIлевое_значение\fB =\fI выражение_QUEL\fR

где левое_значение - это либо имя_переменной, либо выражение, которое
пригодно для левой части оператора присваивания языка Си
(правила составления выражений - стандартные).
Численные значения преобразуются по обычным правилам, а для
преобразования в текстовый формат и обратно нужно использовать
соответствующие функции QUEL.
.pp
Заметим, что переменные и выражения символьного типа (char *) могут в
зависимости от контекста трактоваться одним из трех способов:
.jp имя
там, где может появиться имя;
.jp строка
там, где может появиться текстовая константа;
.jp "переменная для присваивания
в списке результата операторов выборки.
.sh 1 "ОПЕРАТОРЫ EQUEL"
.pp
Выполняемые операторы можно условно поделить на четыре группы:
.ip
 операторы управления системой;
 операторы манипулирования данными;
 операторы выборки;
 параметрические операторы.
.sh 2 "Операторы управления"
.pp
Для работы с базой данных программа, написанная на EQUEL, должна открыть
ее оператором:
.(l
 \fB## rubin \fR[\fB"\fIфлаги\fR" ...] \fIимя_базы\fR
.)l
И флаги, и имя базы могут быть заменены переменными.
Каждый флаг при явном указании должен быть заключен в кавычки.
В случае, если указанной базы данных не существует или СУБД
не может быть вызвана, происходит "системная ошибка" (см. ниже).
.pp
Завершить работу с базой данных можно, выполнив оператор
.(l
 \fB##exit\fR
.)l
Выдача оператора ##rubin при уже открытой базе данных,
либо выполнение любого другого оператора языка EQUEL без
предварительного открытия базы данных
диагностируется как "системная ошибка".
Перейти к работе с другой базой можно только, закончив работу со старой
базой оператором "##exit" и выполнив затем новый оператор "##rubin".
.pp
Примеры:
.(l
 1.
    ##rubin demo /* Откроем базу demo */

 2.
    ## char *name =
    "base";
    ## rubin "-rheap" "-dDD.MM.YY" name
    /* Откроем базу "base", установив формат для
       ввода/вывода даты по умолчанию */
     ...
    ## exit /* Закрытие базы данных */
.)l
.sh 2 "Операторы манипулирования данными"
.pp
Следующие операторы языка EQUEL записываются и выполняются
аналогично соответствующим операторам языка QUEL. Имена
(отношений, атрибутов, кортеж-переменных, функций, файлов) могут
заменяться на переменные или выражения символьного типа, то же
относится и к ключевым словам "from" и "into" в операторе "copy".
Везде, где в QUEL допустимы константы, могут использоваться выражения
соответствующего типа.
Кроме того, условие в конструкциях "where условие" может целиком
заменяться переменной символьного типа.
.pp
Операторы, производящие в QUEL выдачу на терминал, в EQUEL
также выдадут свою информацию в стандартный файл вывода; эти
операторы помечены в списке знаком ">".
Символом "!" помечены операторы, которые могут также быть записаны в
параметрической форме (см. ниже):
.(l
 ## append ...            !
 ## copy ...              !
 ## create ...            !
 ## define view ...
 ## define permit ...
 ## define integrity ...
 ## define переменная ...
 ## delete ...
 ## destroy
 ## help  ...            >
 ## help view ...        >
 ## help permit ...      >
 ## help integrity ...   >
 ## index ...
 ## modify ...
 ## print ...           >
 ## range ...
 ## replace ...         !
 ## retrieve [into] имя_отн ... !
 ## save    ...
.)l
Оператор retrieve без результирующего отношения
выполняется как оператор выборки (см. ниже).
.pp
Примеры:
.(l
 ## char file[] =
 "/mnt/archiv/out";
 ## char *s =
 "into";
 ## char *rel[10];
 ## int k;
 ...
 ...
 ## range of #s is rel[i]
 ## replace #s( #num = k) where #num = 0
 ...
 ## copy rel[i](p1=c0comma,p2=c0nl) s file[i]
 ...
.)l
.sh 2 "Оператор выборки"
.pp
Для получения информации из базы программа на EQUEL должна
использовать оператор "retrieve" без указания
результирующего отношения - оператор выборки.
Он имеет следующий вид:
.(l
 \fB## retrieve (\fIсписок_объектов\fB) \fR[\fBwhere\fI условие\fR]
 \fB##{\fR
 \fIБлок операторов на Си\fR
 \fB##}\fR
.)l
Список_объектов состоит из элементов вида:
.(l
 \fIпеременная \fB= \fIвыражение_QUEL\fR
.)l
перечисленных через запятую (аналогично QUEL), причем переменная
может быть и выражением, допустимым в левой части оператора
присваивания и составленным по правилам EQUEL. Выражение_QUEL -
это обычное выражение языка QUEL, переменные в нем подставляются
по обычным правилам.
.pp
Оператор выборки выполняется следующим образом:
.ip \fB1)\fR
Выполняются подстановки переменных в условия и в левые части
в списке объектов;
.ip \fB2)\fR
В базе данных выполняется поиск перечисленных в списке значений;
.ip \fB3)\fR
Для каждого найденного кортежа найденные значения
присваиваются указанным в списке объектов переменным, и
выполняется Си-блоком.
.pp
Таким образом, оператор ##retrieve аналогичен оператору retrieve языка QUEL,
но если в QUEL результатом его работы является выводимая таблица с данными,
то в EQUEL
таблица не выводится, а для каждой строки таблицы
значения колонок присваиваются
EQUEL-переменным и
выполняется Си-блок.
.pp
\fBОграничения\fR на Си-блок:
.jp
В нем не должно содержаться операторов EQUEL;
.jp
Запрещен вход в него снаружи по метке;
.jp
Выйти из блока раньше времени (не обрабатывая все
найденные кортежи)
можно только по оператору "break",
перейти к следующему кортежу - только по оператору "continue".
.jp
Подстановка значений Си-переменных в запрос (в условии и в
правых частях списка объектов) производится в начале
выполнения всего запроса, и их изменение в Си-блоке не влияет
на запрос.
.pp
Фактически оператор выборки заменяется таким циклом языка Си:
.(l
 <Инициализация запроса>
 while ( <Есть еще кортежи>)
 {
    <Присваивание переменным найденных значений>
     Си-блок
 }
 <Пропуск оставшихся кортежей>
.)l
.pp
При присваивании найденных значений переменным,
численные значения преобразуются к нужному типу по обычным
правилам преобразования. Дата и время передаются как переменные
типа i4. Данные символьного типа передаются без проверки длины
соответствующей Си-переменной: если длина результата равна N,
то соответствующая символьная Си-переменная должна иметь длину
не меньше N+1 (один символ занимает признак конца строки - 0).
Преобразование числовых значений в текстовый вид не производится:
для этого нужно использовать функции "ascii", "from_date",
"from_time" языка QUEL.
.pp
Примеры. Сначала напишем фрагмент программы, который печатает
фамилии служащих 5-го отдела и их оклад, а затем подводит итог
(предполагаем, что база данных уже открыта и существует отношение
служащие с доменами фио(с20), отдел(i2)  и оклад(i2) (здесь приводятся
только фрагменты программы, полный пример можно найти в \fBПриложении\fR):
.(l
  ## char fio[21];
  ## int oklad;
  int summa;
  ... Открытие базы
  ## range of ss is служащие
  printf("     Фамилия         Оклад\en")
  printf("    -------------   --------\en");
  summa = 0;
  ## retrieve (fio=ss.фио, orlad=ss.оклад)
  ## where  (ss.отдел = 5)
  ##{
  printf(".20s   %d\en",fio, oklad);
  summa += oklad;
  ##}
  printf("     Итого:          %d   \en",summa);
  ...
.)l
.pp
Следующий пример посложнее. Узнаем номера отделов,
и будем проводить выдачу небольшими порциями, запрашивая подтверждение
продолжения выдачи:
.(l
  ## char fio[21];
  ## int oklad;
  ## int otdel;
  int summa;
  int nline;
  char inbuf[80];
  ... Открытие базы
  /* Чтение номера отдела */
in_otd:
  printf("Введите номер отдела:_");
  gets(inbuf);
  if(sscanf(inbuf,"%d", &otdel) != 1)
	{
		printf("Повторите\en");
		goto in_otd;
	}
  ## range of ss is служащие
/* Обнуляем номер строки и сумму всех окладов */
  nline = 0;
  summa = 0;
/* Начинаем цикл выборки */
  ## retrieve (fio=ss.фио, oklad=ss.оклад)
  ## where  (ss.отдел = otdel)
  ##{
/* Проверяем, не кончилась ли страница */
  if ( nline > 24) {
	nline = 0;
	printf("Еще? (q - кончить)");
	gets(inbuf);
/* Чтобы пропустить остаток, нужно выйти по
   оператору break из основного цикла */
	if(inbuf[0] == 'q') break;
  }
  if (nline == 0)
  {
      printf("     Фамилия         Оклад\en")
      printf("    -------------   --------\en");
      nline += 2;
  }
  printf(".20s   %d\en",fio, oklad);
  summa += oklad;
  nline++;
  ##}
  printf("    -------------   --------\en");
  printf("     Итого:          %d   \en",summa);
  ...
.)l
.sh 2 "Параметрические операторы"
.pp
В обычных операторах EQUEL могут использоваться только переменные Си,
описанные в EQUEL-описаниях.
Обойти это ограничение позволяют параметрические операторы, признаком
которых является слово "param" перед оператором.
Параметрическим может быть условие поиска "where param (f,v)"
(обратите внимание, что здесь "param" пишется после "where").
Параметрическими могут быть почти все операторы, имеющие объектный
список (append, retrieve, replace, copy, create, define view - все эти
операторы содержат список вида (a1=v1, a2=v2, ...)). В параметрических
операторах такой список формируется с помощью следующей
конструкции:
.(l
 \fB(\fItl_form\fB,\fI argv\fB)\fR
.)l
где \fItl_form\fR - формат преобразования, являющийся
указателем на строку (строковая константа, либо
выражение типа (char *)), а \fIargv\fR - массив ссылок на аргументы оператора
(типа char *argv[]).
.pp
Формат содержит произвольный текст и форматы подстановки вида "%формат",
которые описывают тип соответствующей переменной из массива ссылок.
При выполнении оператора манипуляции данными
текст из формата просто переписывается в запрос, а форматы подстановки
заменяются на значение соответствующей переменной (начиная с argv[0]), на
которую показывает очередной элемент массива ссылок, при этом тип
его должен быть согласован с форматом подстановки.
Правильность получившейся конструкции компилятором EQUEL не
проверяется. Полученные в результате замены значения трактуются
как константы (то есть таким образом нельзя подставить, например, имя
переменной).
.pp
Напротив, в операторах выборки форматы подстановки могут встречаться
только в левой части элемента списка (%формат = значение).
Соответствующий элемент массива argv в этом случае определяет адрес
переменной для записи найденного значения, а формат определяет тип этой
переменной.
.pp
Допустимы следующие форматы подстановки:
.jp \fB%i1\fR
переменная типа char, используемая как целое;
.jp \fB%i2\fR
переменная типа short;
.jp \fB%i4\fR
переменная типа long;
.jp \fB%f4\fR
переменная float;
.jp \fB%f8\fR
переменная double;
.jp \fB%c\fR
массив символов (char []).
.pp
Для записи самого символа % используется %%.
.pp
В операторах  "param append", "param replace", "param copy"
может производиться замена правой части элементов списка:
.(l
 double ff;
 long l;
 int iok;
 char *tl_av[] =
 { "New_s", (char *)&ff, (char *)&l };
 char *tl_av1[] =
 {  (char *)&iok };
 char *tl_av2[] =
 {  "c0,", "c5" };
 char *f = "оклад=%i2";
 ## param append new("s=%c, ff=%f8, cnt=%i4",tl_av)
 ## param replace служащие (f,tl_av1)
 ## param copy("s1=%c, s2=%c,d3=nl",tl_av2)
.)l
Заметим, что подстановка применяется только там, где в QUEL может
встретиться константа соответствующего типа.
.pp
В условии "param where ..." параметрическим должно быть все условие:
.(l
 ## delete служащие
 ## param where ("отдел=%i2 and должность=%c", av)
.)l
.pp
В операторах "param create", "param define view" использование подстановки
практического смысла не имеет (за исключением констант в правой части
целевого списка оператора "define view"), но использование
параметрического оператора по прежнему позволяет сформировать
параметры оператора заранее в виде текстовой строки:
.(l
 char *f = "имя=c12, длина=i4";
 ## param create a(f,NULL)
.)l
.pp
В операторе "param retrieve" описатель подстановки "%формат" \fBдолжен\fR
присутствовать во всех левых частях списка объектов, например:
.(l
 ## param retrieve ("%c=a.name, %i4=a.date, %i2=a.cnt", tl_av)
 ##{
 <Си-блок>
 ##}
.)l
При этом формат должен быть строго согласован с типом переменной, на
которую указывает соответствующий указатель.
Использование формата в правой части или пропуск описателя формата в
очередном элементе списка приводят к непредсказуемым
ошибкам на этапе выполнения программы.
.pp
Пример использования параметрических операторов.
В примере используется отношение "служащие (имя=c20,оклад=i2)".
.(l
/* Описываем данные. Заметьте, что
 * все описания сделаны так, что
 * в операторах EQUEL информация о
 * структуре данных отстутствует, она
 * вся собрана здесь
 */
## char rel_name[] =
	"служащие";
 struct slug {
	char s_name[21];
	short s_okl;
	} s_slug;
 char *v_slug[] = {
       &s_slug.s_name,
       &s_slug.s_okl };
 char *ret_slug = "%c = s.имя, %i2 = s.оклад";
 /* Для операторов записи/обновления формат
   выглядел бы так:
   "имя=%c, оклад=%i2"
  */
 ... Начало программы. Здесь нет накакой зависимости
 ... от структуры отнешения и данных
 ## range of s is rel_name
 ## param retrieve(ret_slug, v_slug)
 ## {
 my_print( &s_slug);
 ## }
 ...
.)l
.pp
Итак, параметрические операторы при их правильном использовании
обеспечивают независимость
операторов EQUEL от структур данных, с которыми они оперируют.
Ниже перечислены наиболее \fBчастые ошибки\fR в использовании параметрических
операторов:
.ip 1)
Попытка использовать подстановку там, где требуется имя.
.ip 2)
Использование подстановки в правой части в операторе выбора.
.ip 3)
Использование ссылок на переменные типа "int", формат которых
зависит от типа ЭВМ.
.ip 4)
Несоответствие формата и типа переменной.
.ip 5)
Использование списка переменных вместо массива ссылок, либо
неправильная инициализация этого массива.
.pp
В \fBПриложении\fR имеется пример программы на EQUEL, использующей
параметрические операторы.
.sh 1 "БИБЛИОТЕЧНЫЕ ФУНКЦИИ"
.pp
Все предыдущее описание EQUEL шло в предположении, что все всегда
правильно, что не бывает ни ошибок, ни прерываний, не возникает
необходимости преобразовывать данные. В данной главе описаны
дополнительные возможности системы, которые реализуются в первую
очередь библиотечными функциями.
.pp
Для использования библиотеки EQUEL в программу должен быть включен файл
вставок "rubin/equel.h":
.(l
 # include <rubin/equel.h>
.)l
В дистрибутиве этот файл помещен в справочнике files: "files/equel.h".
.sh 2 "Коды ответа"
.pp
Программа на EQUEL может использовать следующие
информационные переменные (описанные в <rubin/equel.h>):
.ip IIerrflag
Признак ошибки. Устанавливается в 0 перед началом выполнения
очередного оператора; если при выполнении оператора возникли
какие-либо ошибки, то в переменную IIerrflag записывается код последней
ошибки (см. "Описание ошибок" в Справочном руководстве).
Подробно об обработке ошибок сказано с следующем параграфе.
.ip IItupcnt
После операций обновлений (replace, delete, append) в эту переменную
(типа long) записывается число измененных (замененных, добавленных,
исключенных) кортежей. Следует только иметь в виду, что, если при обновлении
кортежа его содержимое не изменилось, то он не попадает в число
измененных. Так, после операции "## replace a(dom=a.dom)", tupcnt всегда
будет равно 0.
.pp
Кроме того, для отладки можно использовать переменную:
.(l
 char *IImainpr;
.)l
которая определяет, какая команда будет выполнена для вызова
СУБД (по умолчанию это "rubin").
.sh 2 "Обработка ошибок и прерываний"
.pp
Обработка ошибок и прерываний является одним из тонких мест в программе
на EQUEL. Это связано с тем, что СУБД устанавливает свою реакцию на ошибки и
прерывания, которые не могут быть выключены, поскольку включают операции
восстановления связи процессов, входящих в СУБД.
При работе программы на EQUEL могут возникнуть три особых ситуации:
прерывание с терминала (сигнал SIG_INT), ошибка оператора EQUEL и
фатальная (системная) ошибка (хотя она не обязательно вызвана ошибкой
системы).
.sh 3 "Обработка прерываний"
.pp
Прерывания при работе программы на
EQUEL могут либо игнорироваться, либо обрабатываться
самой системой. Реакция на прерывания устанавливается системой при
выполнении оператора "#rubin", и ее отмена или изменение после открытия
базы данных приведет к
фатальным последствиям.
.pp
Во первых, до выполнения оператора "#rubin" программа может отменить
реакцию на прерывания с терминала. При этом ядро СУБД не будет прерываться
символом INTERRUPT (CTRL-C или DEL в зависимости от умолчаний), а
программа
после выполнения оператора "rubin" сможет распоряжаться этим
прерыванием по своему усмотрению (например, открыть его снова, но
теперь уже только для самой себя). При этом нужно помнить о том,
что из цикла выборки данных выйти можно только через оператор "continue".
.pp
Во вторых, программа может воспользоваться стандартной реакцией на
прерывание. При этом система восстанавливает программные каналы связи
с ядром СУБД, а затем анализирует переменную IIinterrupt, описанную в <rubin/equel.h>:
.(l
 extern int (*IIinterrupt)();
.)l
Если эта переменная не определена, система EQUEL завершает работу,
вызывая системную ошибку. Пользователь может задать собственную программу
обработки, записав ее адрес в IIinterrupt, и она будет вызвана таким
образом:
.(l
 (*IIinterrupt)(-1);
.)l
Пример использования:
.(l
 /*
  * Сначала напишем функцию для возврата из прерывания
  */
 # include <setjmp.h>

 static jmp_buf myjmp;
 myreset(val)
 {
   longjmp(myjmp, val);
 }
 myset()
 {
 return(setjmp(myjmp));
 }

 /* А теперь фрагмент головной программы */
 ...
 ## rubin base
 myset();
 IIinterrupt = myreset;
 while(1)
	 main_loop();
 ...
.)l
Теперь, если произойдет прерывание, программа после его обработки
выйдет на начало основного цикла.
.sh 3 "Диагностика ошибок"
.pp
Обработка ошибок РУБИН и EQUEL управляется следующими указателями
на функции (они описаны в include-файле):
.(l
 extern int (*IIprint_err)();
 extern int (*IIout_err)();
.)l
Реакция системы на ошибки RUBIN и EQUEL выглядит так:
.ip 1)
Приводятся в исходное состояние программные каналы связи с ядром СУБД
(за исключением тех ошибок, которые не обрывают текущий оператор);
код ошибки заносится в IIerrflag.
.ip 2)
Вызывается функция, на которую ссылается указатель IIprint_err:
.(l
       код_ошибки = (*IIprint_err)(код_ошибки)
.)l
.ip 3)
Анализируется возвращенный этой программой код. Если он равен 0 -
производится выход из программы диагностики.
.ip 4)
Если код отличен от нуля, вызывается программа печати диагностики.
Она находит сообщение об ошибке и выдает его, обращаясь с
каждой строкой диагностики к функции по указателю IIout_err:
.(l
 (*IIout_err)(строка_сообщения)
.)l
Если этот указатель равен 0, то выдача идет на стандартный вывод.
.pp
Для управления диагностикой используются следующие макро:
.jp EQ_ONERR
включить стандартную реакцию на ошибки;
.jp EQ_OFFERR
выключить диагностику ошибок;
.jp EQ_ERR
возвращает 1, если была ошибка, и 0, если- нет.
.pp
Кроме того, программа может записать в IIprint_err указатель на
свою функцию и сама анализировать ошибки.
.pp
Приведем пример использования упомянутых макро:
.(l
 # include <rubin/equel.h>
   ...
 EQ_OFFERR;
 ## delete temp
 EQ_ONERR;
 ## retrieve unique temp(name=otd.name) where otd.otd = 2
 if (EQ_ERR) IIsyserr("Не могу создать рабочее отношение `temp'");
   ...
.)l
(IIsyserr - функция для печати сообщения о фатальной ошибке
из библиотеки системы EQUEL).
.pp
Для печати диагностик в экранных программах используется функция IIerr_out.
Как правило, программа печати сообщения выводит очередную строку сообщения
в выделенную часть экрана и ждет нажатия любой клавиши для того, чтобы
продолжить работу. Например, при использовании экранного
пакета DIXY (разработки АЗЛК) она выглядит так:
.(l
err_print(s)
char *s;
{
 char buf[80];
 sprintf(buf,"!!!%.60s!!!Нажмите ВК",s);
 f_wto(buf,"s"); /* Вывод сообщения */
 s_get(fmswin);  /* Ожидание нажатия */
 return;
}
...
IIout_err = err_print;
.)l
.pp
Диагностику рекомендуется отменять в тех случаях,
когда ошибка может возникнуть по идее работы программы, например, при
уничтожении рабочих отношений (их может просто не оказаться).
.sh 3 "Системные ошибки"
.pp
Системными в EQUEL называются ошибки, не позволяющие
программе дальше работать с базой. Система выдает сообщение с префиксом
"SYSTEM ERROR" (СИСТЕМНАЯ ОШИБКА) и заканчивает работу.
Программа может перехватить управление, установив адрес собственной
функции обработки ошибок в переменную:
.(l
 extern (*IIabort)();
.)l
Если эта переменная не равна 0, то перед выдачей exit(-1)
система EQUEL вызовет указанную функцию:
.(l
 (*IIabort)(-1);
.)l
При работе экранных программ в IIabort обычно записывается ссылка на
функцию восстановления режимов терминала.
.pp
Печать сообщения об системной ошибке идет через указатель IIout_err
аналогично остальным сообщениям об ошибках.
Программа может сама инициировать системную ошибку,
обратившись к функции IIsyserr:
.(l
 IIsyserr(формат, параметры...)
.)l
параметры аналогичны функции "printf".
.sh 2 "Работа с датой и временем. Функции преобразования"
.pp
В СУБД РУБИН имеется два специальных типа данных: тип "date" предназначен
для хранения дат, а тип "time" - времени. Оба этих типа данных
занимают длинное целое число - long. Время хранится в секундах,
дата - в днях, прошедших с начала нашей эры. Во всех арифметических
операциях языка QUEL они ведут себя подобно числам формата i4, а при
выводе на терминал в языке QUEL автоматически преобразуются в текстовый
вид. Кроме того, в языке QUEL имеются функции преобразования даты и
времени в текстовое представление и обратно по заданному шаблону.
.pp
В операциях манипулирования данными языка EQUEL дата и время ведут
себя точно так же; например, при печати оператором "print" они
будут автоматически преобразовываться в текстовый вид. Отличия начинаются,
когда дату или время необходимо передать из задачи в базу или выбрать из
базы. Констант типа "date" и "time" в языке EQUEL не
предусмотрено, дата и время передаются в виде длинных чисел.
В стандартных описаниях EQUEL имеются специальные обозначения этих
типов: EQ_date и EQ_time (оба определены как long).
.pp
В языке EQUEL можно использовать два способа преобразования даты и
времени в текст и обратно. Во первых, это преобразование можно делать
непосредственно в операторах EQUEL, используя стандартные функции
преобразования - ascii, from_date, from_time - для получения
текстового представления при считывании из базы, и date4, time4, to_date,
to_time - при записи в базу. Это плохо только тем, что возможные
ошибки в дате или времени будут определяться непосредственно в
операторах взаимодействия с базой; кроме того, возможны ошибки в
определении длины результата преобразования, да и объем данных,
пересылаемых между базой и программой, несколько увеличивается.
.pp
Во вторых, обмен с базой можно вести в исходном формате (long), а
для преобразования использовать функции, записанные в библиотеку EQUEL.
Для использования этих функций в программу нужно включить файл
описаний:
.(l
 # include <rubin/datetime.h>
.)l
.pp
Преобразования даты и времени в текст и обратно проводятся по
шаблону преобразования, который задается явно, либо используется
по умолчанию. Шаблон - это строка, в которую могут входить идентификаторы
преобразования (определенные последовательности прописных букв, которые
обозначают подстановку той или иной компоненты даты), символы
пунктуации и произвольный текста, взятый в кавычки. Например,
"DD.MM.YY" или "DD МЕСЯЦА YYYY 'года'": DD, MM, YY, YYYY, МЕСЯЦА - это
идентификаторы преобразования, которые обозначают дату, номер месяца,
две или четыре цифры года, название месяца на русском языке.
Существуют следующие идентификаторы преобразования даты:
.jp DD
день месяца (1-31);
.jp MM
номер месяца (1-12);
.jp YY
две последние цифры года (при выводе); последние цифры 19YY года - при
вводе;
.jp YYYY
четыре цифры года;
.jp W
номер дня недели (0-6, воскресенье - 0);
.jp Н
(русское Н) - то же самое;
.jp MON
английское сокращенное название месяца, например, Jan;
.jp MONTH
английское полное название месяца;
.jp МЕС
русское сокращенное название месяца (Янв, Фев, Мар, Апр, Май, Июн, Июл,
Авг, Сен, Окт, Ноя, Дек);
.jp МЕСЯЦ
русское полное название месяца в именительном падеже;
.jp МЕСЯЦА
русское полное название месяца в дательном падеже;
.jp DAY
сокращенное английское название дня недели (San, Mon, ...);
.jp DAYWEEK
английское полное название дня недели;
.jp ДЕН
русское сокращенное название дня недели (Пон, Вто, Сре, Чет, Пят, Суб, Вос);
.jp ДЕНЬНЕД
русское полное название дня недели;
.pp
Преобразование времени проще:
.jp HH
число часов;
.jp MI
минут;
.jp SS
секунд.
.pp
При переводе даты/времени в текст идентификаторы преобразования заменяются
на соответствующую часть даты или времени, а все остальные символы просто
выводятся без изменений (при этом снимаются кавычки "'", а две
кавычки заменяются на одну). При вводе на месте идентификаторов
ожидается (и вводится) соответствующая часть даты или времени,
символ "?" означает "ЛЮБОЙ СИМВОЛ", а остальные символы в шаблоне и
строке ввода должны совпадать. При вводе полей, имеющих текстовое значение
(название месяца) идет поиск по всем возможным названиям месяца, а не только
по указанному в шаблоне.
Имеются умолчания: шаблон "DD-MON-YYYY" для даты и "HH:MI:SS" для времени.
Примеры вывода и ввода 12 апреля 1985 года (для времени аналогично)::
.jp @DD.MM.YY@
Вывод: "12.04.85";
Ввод: "12.04.85".
.jp @DD-MON-YYYY@
Вывод: "12-Apr-1985". Ввод: допустимы "12-Апр-1985", "12-Apr-1985" и
даже "12-Апреля-1985".
.jp "@'Сегодня' DD МЕСЯЦА YYYY 'года', ДЕНЬНЕД@
Получится "Сегодня 12 Апреля 1985 года, четверг". Ввод имеет
мало смысла, так как день недели не анализируется; однако выведенная
строка введется правильно.
.jp "@DD?MM?YY@"
Ввести по этому формату можно как "12.04.1985", так и "12 4 1985".
.pp
Все функции, входящие в библиотеку, можно разделить на следующие группы.
.ip 1)
Функции преобразования по шаблону из текстового представления
в формат даты или времени:
.(l

 EQ_date char_date(in,ss)
 char *in; /* Текстовое представление */
 char *ss; /* Шаблон преобразования   */

 EQ_time char_time(in,ss)
 char *in; /* Текстовое представление */
 char *ss; /* Шаблон преобразования   */
.)l
.ip
Эти функции преобразуют дату или время из текстового вида (in)
в числовой формат по шаблону (ss). Если вместо шаблона стоит NULL, то
используется шаблон по умолчанию.
В случае ошибки возвращается отрицательное значение.
.ip 2)
Функции преобразования из даты/времени в текст:
.(l

 char *date_char(date, ss)
 EQ_date date;  /* Дата   */
 char *ss;      /* Шаблон */

 char *time_char(time, ss)
 EQ_time time;  /* Время  */
 char *ss;      /* Шаблон */

.)l
При ошибке (она возможна в шаблоне) возвращается \fBNULL\fR.
Если шаблон не задан (NULL), используется умолчание.
Правильный результат возвращается в статической области памяти
(возвращается указатель на эту область), и затирается при следующем
обращении к любой из перечисленных функций.
.ip 3)
Запрос длины даты/времени, описанных в шаблоне.
.(l
 int date_len(ss)
 char *ss; /* Шаблон */
 int time_len(ss)
 char *ss; /* Шаблон */
.)l
Возвращается число символов, которые будут занимать дата или время,
полученные по указанному шаблону.
.ip 4)
Функции распаковки/запаковки даты и времени. В распакованной форме
дата и время записывается в следующие структуры, описанные в файле
вставок <equel/datetime.h>:
.(l
 /* Дата */
 struct cd_date {
 int cd_year; /*  Год */
 int cd_month; /* Месяц: 1-12 */
 int cd_day;   /* День месяца: 1-31 */
 int cd_2year; /* Год текущего века */
 int cd_week;  /* День недели, 1-7 */
 };
 struct cd_time {
 int cd_hh;     /* Часов */
 int cd_mm;     /* Минут*/
 int cd_ss;     /* Секунд */
 }
.)l
Программы преобразования переводят дату и время из формата длинного
целого в указанные структуры и обратно:
.(l
 /* Дату в структуру */
 date_cd(date, pcd)
 EQ_date date;
 struct cd_date *pcd;
 /* Время в структуру */
 time_cd (time, pcd)
 EQ_time time;
 struct cd_time *pcd;
 /* Структуру в дату */
 EQ_date cd_date(pcd)
 struct cd_date *pcd;
 /* Структуру во время */
 EQ_time cd_time(pcd)
 struct cd_time *pcd;
.)l
Для получения правильной даты должны быть указаны день, месяц и либо год,
либо (для 19ГГ года) 2 последние цифры года в cd_2year.
.ip 5)
Запрос текущих даты и времени:
.(l
 d = get_date() - запрос даты
 t = get_time() - запрос времени
 new_datime - обновление даты/времени
.)l
Это не функции, а макро. Выдается время и дата первого обращения
к указанным функциям после последнего обращения к new_datime, что
гарантирует согласованность даты и времени даже в момент смены даты (24 часа
00 минут).
.sh 2 "Функции для работы со строками"
.pp
В библиотеку EQUEL входят несколько функций для работы со строками,
которые используются самой системой, но могут быть полезны и программисту:
.(l

 Преобразование из текста в целое:
 IIatoi(s,i)
 char *s; int *i;
 Вводятся только |целые| < 32767
 Код ответа: 0 - преобразовано
	    -1 - ошибка
	    +1 - переполнение

 Перепись из s в d массива длиной l:
 IIbmove(s,d,l)
 char *s, *d;
 int l;

 Слияние нескольких строк:
 char *IIconcatv(buf, s1, s2,..., NULL)
 char *buf, *s1, s2...
 Все строки s1, s2 ... сливаются вместе
 и записываются в buf.
 Возвращается указатель на конец
 полученной строки.
 Последний аргументом должен быть
 NULL (то есть (char *)0)

 Преобразование целого в текстовый вид:
 char *IIitos(i)
 int i;
 Возвращается указатель на статическую
 область памяти.

 Определение длины строки
 int IIlength(s)
 char *s;
 Эта функция имеет особенность: если
 длина строки больше 255, возвращается ответ 255.

 Проверка равенства двух строк:
 IIsequal(s1, s2)
 char *s1, *s2;
 Ответ: 1 - равны, 0 - не равны.

.)l
.sh 1 "ПРИЕМЫ ПРОГРАММИРОВАНИЯ НА EQUEL"
.pp
При программировании на языке EQUEL у начинающих
обычно возникают одни и те же проблемы. Ниже делается
попытка систематизировать и разрешить некоторые из них.
.sh 2 "Использование tid для создания курсоров"
.pp
Одно из больных мест языка EQUEL (который в будущем будет
разрешен), это отсутствие встроенного механизма для последовательного
просмотра найденных записей с одновременным их изменением.
В некоторых языках манипулирования данными для этого
используются "курсоры" - указатели на найденную информацию,
которые позволяют сначала найти нужные записи, а потом просматривать и
обновлять их. В EQUEL это надо делать явно:
.ip 1)
Сначала организуется поиск требуемых записей. Для того, чтобы в
дальнейшем можно было обратиться к любой найденной записи (кортежу),
запрашиваются tid-ы (идентификаторы кортежей), которые
записываются в файл или, если предполагаемые объемы информации
небольшие, просто в массив.
.ip
tid - это внутренний номер кортежа в отношении. Он имеет формат i4,
уникален внутри данного отношения и позволяет найти любой
кортеж в отношении без какого-либо поиска. Цикл поиска
будет выглядеть примерно так. Допустим, у нас есть отношение
"служащие(имя=с20, отдел=i2, оклад=i2, принят=date)".
Имеется запрос (он сделан параметрическим, чтобы выделить всю конкретную
информацию):
.(l
  /* Описания данных для считывания и поиска */
  struct { char name[21]; short okl;} s_in;
  struct { short otd; EQ_date datein; }w_wh;
  char *v_in[] =    { s_in.name, &s_in.okl };
  char *v_where[] = { &w_wh.otd, &w_wh.datein };
 ... Запрос ...
 ## range of s is служащие
 ## param retrieve ("%c=s.имя, %i2 = s.оклад", v_in)
 ## param where ("s.отдел = %i4 and s.принят > %i4", v_where)
 ##{
   что_то_делаем(&s_in);
 ##}
.)l
Все хорошо, но в "что_то_делаем( &s_in) " мы не можем ничего делать
с базой данных. Перепишем теперь запрос с использованием tid
(для имитации курсора).
.(l
  /* Описания данных для считывания и поиска */
  struct { char name[21]; short okl;} s_in;
  struct { short otd; EQ_date datein; }w_wh;
  char *v_in[] =    { s_in.name, &s_in.okl };
  char *v_where[] = { &w_wh.otd, &w_wh.datein };

 /* Опишем переменные для записи tid */
 ## long tid_s;
 int nfind; /* Счетчик найденных записей */
 /* А это описатель файла для записи tid */
 FILE *fd;
 /* Естественно, файл нужно открыть */
     fd = fopen("TEMP1", "w+");

 ... Запрос ...
 nfind = 0;
 ## range of s is служащие
 ## retrieve (tid_s = s.tid)
 ## param where ("s.отдел=%i4 and s.принят>%i4",v_where)
 ##{
   /* Теперь мы пишем tid в файл */
   fwrite(fd, &tid_s, 4,1);
   nfind++;
 ##}
 /* Переходим к началу файла.         */
 /* В nfind - число найденных записей */
 fseek(fd, 0l, 0);
 /* А вместо запроса теперь будет цикл по массиву */
 for(i=0; i<nfind; i++)
 {
	fread(fd, &tid_s, 4, 1);
  ## param retrieve ("%c=s.имя, %i2 = s.оклад", v_in)
  ## where s.tid = tid_s
  ##{
  /* Нет, мы еще ничего не делаем. Этот поиск пройдет
   * ровно один раз, так как s.tid указан точно   */
  ##}
  /* А теперь можно делать все что угодно */
  что_то_делаем(&s_in, tid_s);
 }
 fclose(fd);
 unlink("TEMP1");
.)l
Теперь в программе "что_то_делаем" мы можем обращаться к базе
данных, например, изменить выбранный кортеж. Для его точной
идентификации достаточно указать в условии "where s.tid = tid_s"
(для того его туда и передали в качестве параметра).
.pp
В этом примере не затрагивается проблема блокировки от одновременного
обновления. Решение ее зависит от конкретного случая; можно,
например, в условие "s.tid=s_tid" добавить и проверку остальных
условий с тем, чтобы при изменении данного кортежа он просто
не был бы выбран.
.sh 2 "Генерация уникальных значений"
.pp
При добавлении новой информации в базу данных часто
возникает необходимость присвоить какому-либо полю уникальное
значение. Например, при записи нового служащего ему нужно обычно
присвоить номер, на который можно будет ссылатьсся в дальнейшем.
Для этого используется аппарат переменных QUEL. Переменная QUEL -
это именованное длинное (i4) число,
доступное всем, работающим с данной базой. Над переменными
в языке QUEL определены
две основные операции:
.jp "ser_next(@имя@)
получить текущее значение переменной, а затем увеличить значение
переменной в базе на 1 (аналогично оператору v++ языка Си);
.jp "ser_last(@имя@)
выдается только после ser_next и возвращает повторно значение
переменной, полученное в последней операции "ser_next".
.pp
Имеется еще оператор инициализации "define" и функция присваивания
"ser_set".
.pp
Например, в программе на EQUEL нужно записать информацию об
эксперименте в три отношения: `эксперимент', `значения', `комментарий'.
Во всех трех есть поле `номер', содержащее номер данного эксперимента.
Заведем в базе при ее создании переменную `num_ex' и присвоим ей значение
1:
.(l
 /* Это программа создания базы */
 ## define num_ex 1
.)l
Фрагмент программы записи будет выглядеть так:
.(l

 ## append to эксперимент
 ##       (номер=ser_next("num_ex"), ..........)

 ## append to значения
 ##       (номер=ser_last("num_ex"), ..........)

 ## append to комментарий
 ##       (номер=ser_last("num_ex"), ..........)

.)l
.sh 2 "Использование copy для массового ввода данных"
.pp
Еще одной проблемой является ввод в систему больших объемов данных.
Дело в том, что вводить данные оператором "append" можно только при
небольших их количествах, поскольку он довольно медленно работает.
Лучший способ ввода при больших объемах - использовать "copy".
Тогда ввод состоит из следующих этапов:
.ip 1)
Программа готовит данные и записывает их в файл.
.ip 2)
Программа вызывает оператор "copy" и считывает их во временное отношение.
.ip 3)
Программа добавляет данные из временного в основное отношение,
используя "append".
.ip 4)
Рабочее отношение уничтожается.
.pp
Если данных очень много, есть смысл выполнять все эти действия через
несколько сотен записей, тогда объемы рабочих файлов будут не очень
большими.
Рабочее отношение не нужно, если основное не имеет вторичных
индексов и модифицировано в "heap" или "shash".
.sh 1 "СЛУЖЕБНЫЕ ФУНКЦИИ EQUEL. ПРЯМАЯ ВЫДАЧА КОМАНД QUEL"
.pp
В некоторых случаях возможностей языка EQUEL может не хватать.
Так, например, он не позволяет выполнить произвольную команду
языка QUEL, введенную, например, с терминала. Поскольку все
операторы EQUEL переводятся прекомпилятором в конце концов в
вызовы функций, возникает соблазн использовать для работы
сами эти функции.
.pp
Функции системы EQUEL достаточно сложны и системнозависимы для
того, чтобы все их можно было использовать в пользовательских
программах (пусть даже это сложный терминальный монитор). Однако
можно отобрать несколько функций, которые позволяют простыми средствами
выполнить произвольную команду QUEL из программы на Си и тем самым
при необходимости обойти любые ограничения языка EQUEL.
Единственное, чего нельзя сделать - это выполнить оператор "retrieve"
c выводом результата на терминал - в EQUEL такой оператор работает как
оператор выборки.
.pp
Рассмотрим простейший запрос на EQUEL:
.(l
 ## print rel1, rel2
.)l
Он транслируется  так:
.(l
 IIwrite("print rel1, rel2"); IIsync();
.)l
При этом IIwrite просто переписывает свой аргумент в запрос, а
IIsync означает конец ввода и начинает выполнение оператора QUEL.
Несколько вызовов IIwrite можно ставить подряд.
Единственное, что нужно помнить - что оператор не может быть
оператором "retrieve" без результирующего отношения.
.pp
Сложнее с оператором выборки и с подстановкой переменных. Подстановку в
общем-то можно сделать при формировании строки запроса, а функции EQUEL
использовать нежелательно, так как код типа переменной зависит и от
версии системы, и от машины. Довольно легко можно воспользоваться
параметрической подстановкой. Рассмотрим два оператора:
.(l
 ## param replace a(f,v) where s
 ## param retrieve (ff,vv)
 ##{
  fun();
 ##}
.)l
Результат будет такой:
.(l
char*s;
{
	IIwrite("replace a(");
	IIw_right(f,v);
	IIwrite(")where");
	IIwrite(s);
	IIsync(0);
}
{
	IIwrite("retrieve(");
	IIw_left(ff,vv);
	IIwrite(")");
	IIsetup();
	while(IIgettup(0)){
		fun();
	}
	IIflushtup(0);
}
.)l
Функция IIw_right(f,v) осуществляет параметрическую подстановку
параметров "v" в шаблон "f" (правила такие же, как у параметрического оператора).
Скобки она сама не ставит, и может быть легко использована для
формирования строки запроса (подробнее см. Справочное руководство).
.pp
Функция IIw_left(ff,vv) работает аналогично, но она не подставляет аргументы в
шаблон, а запоминает их для присваивания значений в цикле выборки.
Функция IIsetup() начинает выполнение цикла выборки, а функция
IIgettup(0) присваивает очередные значение переменным выборки, указанным ранее в
IIw_left(ff,vv). И, наконец, IIflushtup(0) служит для пропуска оставшихся
значений и начальных установок при завершении цикла выборки.
.pp
Сведем описания вместе:
.(l

 Передача строки запроса ядру СУБД:
 IIwrite(s) char *s;

 Выполнить оператор QUEL:
 IIsync(NULL)

 Передать строку f в качестве запроса,
 выполнив параметрическую подстановку
 из списка указателей v:
 IIw_right(f,v)
 char *f;
 char *v[];

 Передать строку ff в качестве запроса и запомнить
 аргументы для оператора выборки в соответствии
 с их форматом в ff:
 IIw_left(ff,vv)
 char *ff;
 char *vv[];

 Начать основной цикл оператора выборки:
 IIsetup();

 Выбрать очередной кортеж и присвоить
 значение переменным:
 IIgettup(NULL);

 Окончить оператор выборки:
 IIflushtup(NULL);

 Съимитировать прерывание:
 IIresync();

.)l
