		  MM:  ПРОСТЕЙШИЙ МАКРОПРОЦЕССОР

ВЫЗОВ:  mm  имя.макропрограммы  [ключи.отладки]


			   ВОЗМОЖНОСТИ

команда  'mm'  представляет собой интерпретатор простейшего языка
макрообработки строк. Он считывает указанную макропрограмму, и
интерпретируя ее, производит преобразование файла, считываемого со
стандартного ввода в файл, выдаваемый на стандартный вывод. Несмотря на
простоту реализованного макроязыка и миниатюрность самого
макропроцессора (меньше 7 Кбайт) 'mm' позволяет реализовывать достаточно
сложные препроцессоры, конверторы с одного языка в другой, а также
трансляторы простейших языков (с выдачей результата трансляции в виде
ассемблерного файла).


			 ОПИСАНИЕ МАКРОЯЗЫКА

	  Общее описание процесса преобразования входного файла.

Макропрограмма состоит из последовательности образцов, с каждым из которых
связана группа шаблонов для генерации новых строк. Образец может содержать
как обычные символы, так и спецсимволы, сопоставляющиеся по особым
правилам. Макропроцессор последовательно считывает строки исходного файла.
К каждой входной строке слева приписывается пробел, после чего ее
последовательно сопоставляет со всеми образцами, до тех пор, пока
сопоставление не окончится успешно. При этом подстроки, сопоставившиеся со
спецсимволами образца присваиваются в качестве значения макропеременным.
После этого макропроцессор заменяет сопоставившуюся строку на группу новых
строк, сгенерированных по шаблонам, связанным с этим образцом. При
генерации новых строк могут использоваться значения макропеременных. Если
сгенерированная строка содержит точку в первой позиции, то она без
дальнейшей обработки выводится в выходной файл (но без точки). Иначе
процесс обработки повторяется, причем в качестве входной строки
используется первая из сгенерированных строк, затем 2-ая, и только когда
они исчерпаются, макропроцессор берет следующую строку из входного файла.


			Формат макропрограммы

Строки макропрограммы, начинающиеся с одного из символов "*", "#", "%", и
пустые строки являются строками коментария.

Если в первой позиции строки стоит символ "/", то строка после этого
символа является образцом. Шаблоны генерируемых строк начинаются с пробела
в первой позиции (пробел в сам шаблон не входит). Шаблоны, относящиеся к
данному образцу, идут от образца до следующего образца (или до конца
файла).

Первый символ образца (т.е. следующий за "/" символ) называется маркером
образца и выполняет несколько особую роль. Образцы с одинаковым маркером
должны располагаться друг за другом.

Символы "\t" при считывании входного потока сразу же заменяются на пробелы.
На выходе свертывание пробелов в "\t" не производится.


		      Сравнение строки с образцом

Сравниваются 1-ые символы строки и образца. Если они различаются, то
сравнение неуспешно. Если совпадают - сравниваем 2-ые символы и т.д.
Если все символы совпали (и совпали длины), то сравнение успешно.

Кроме обычных символов, в образце могут встречаться т.н. спецсимволы:
! ? $ _ [ < \ . Сравнение с ними происходит следующим образом:

!       сравнивается с произвольным символом строки, т.е. сравнение образца
	"ab!d" со строкой "abcd" закончится успешно.

?       сравнивается с произвольным числом (даже с 0-ым) произвольных
	символов, т.е. успешно сравнится образец "a?d" со строкой "abcd".
	Самые левые знаки ? сравниваются с наиболее короткой частью строки,
	т.е. при сравнении образца "?+?" со строкой "a+b+c" первый ?
	сравнится с "a", а второй ? с "b+c".

$       работает также, как и символ "?", но сравнивается только с
	подстрокой, имеющей сбаланисрованную скобочную структуру (или не
	имеющей скобок вообще). Учитывается баланс скобок (...), [...],
	{...} и текстовых скобок "..." и '...' (внутри текстовых скобок
	сами символы ' или " могут быть изображены удвоением их или как \'
	и \"). Пример: при сравнении строки "(a+b)+c" с образцом "?+?"
	первый "?" сравнится с подстрокой "(a", а второй - с "b)+c". При
	сравнении той же строки с образцом "$+?", "$" сравнится с
	подстрокой "(a+b)", а "?" с "c". "$" может сопоставиться и с пустым
	набором символов.

_       сравнивается с максимальным (возможно нулевым) числом пробелов.
	Внимание: этот образец не рассматривает альтернативные варианты,
	поэтому сравнение строки "a    b" с образцом "a_ b" будет
	неуспешным, т.к. "_" "вберет" в себя все пробелы.

[abc]   сравнивается с одним из перечисленых в скобках символов. Внутри
	скобок можно использовать тире "[a-zA-Z]". Если внутри скобок надо
	поставить сам символ "-", то его надо поместить в позицию, в
	которой его нельзя опознать как тире (например, "[-ab]" "[a-z-]").
	В первой позиции внутри скобок можно использовать и сами символы
	"[" и "]".

<abc>   сравнивается с любым количеством (возможно нулевым) символов из
	перечисленных в скобках (работают те же соглашения, что и для [...]
	скобок). Образец пытается сопоставиться с максимальным количеством
	таких символов. Например, образец, сопоставляющийся с
	идентификаторами, будет: "[a-z_]<a-z0-9_>" .

\       Является "escape"-символом, т.е. сам он игнорируется, а стоящий
	после него символ считается обычным. Можно использовать также
	символы: \n \t \f \b \r \v \012 ... (как в C).

Сопоставление происходит слева направо. Подстрока исходной строки,
сопоставившаяся с первым спецсимволом образца присваивается макропеременной
~1, сопоставившаяся со 2-ым - макропеременной ~2 и т.д. Всего в образце
может быть до 9 спецсимволов.

Значения макропеременных можно использовать даже в самом образце. Так,
например, образец "?=~1+?" сопоставится со строкой "a=a+2" и не
сопоставится со строкой "a=b+2".


		      Генерация новых строк

При успешном сопоставлении с образцом исходная строка изчезает, но вместо
нее формируется 0 или более новых строк по шаблонам, связанным с этим
образцом. В шаблоне могут быть как обычные символы, так и спецсимволы:
~ \ / = . Каждый обычный символ просто переносится в генерируемую строку.

Особые символы:

~(цифра)        заменяется на значение соответствующей макропеременной.

~z              заменяется на число (4 десятичные цифры с ведущими нулями).
		После каждого успешного сопоставления значение этого числа
		увеличивается на 1, т.е. его можно использовать для
		генерации уникальных меток, имен ...

~s              заменяется на значение верхнего элемента стека
		макропроцессора (см. ниже). Сам элемент при этом удаляется
		из стека. Каждое использование этой переменной приводит к
		извлечению очередного элемента стека.

~n              заменяется на номер последней строки входного файла.

~l(символ)      заменяется на текстовое представление длины макропеременной
		~(символ). Для символов ~ls извлечение верхнего элемента
		стека не происходит.

\t \n \r \f \b \v \0 \(три восьмеричные цифры)
		заменяются на один символ (так же, как и в C).

\(любой символ) заменяется на этот символ.

/(образец)/     в стеке макропроцессора (см. ниже) ищется образец вида
		/?/(образец)  после чего вместо указанной конструкции в
		генерируемую строку подставляется значение макропеременной
		~1 (для поиска) или пусто, если образец в стеке не найден.
		Затем восстанавливаются значения макропеременных,
		сформированных при основном сравнении. Эта конструкция
		используется, в основном, для организации таблиц (т.е.
		массивов, индексируемых не числом, а строкой).

=(выражение)=   вычисляется значение арифметического (выражения) и
		заменяется на текстовое представление результата. В
		выражении можно использовать следующие операции (понимаются
		как в языке C, вычисление происходит в long ячейке):
		бинарные:  + - * / % & | ^ && || > < >= <= == != >> << **
		и унарные: - ! ~
		Числа в выражении могут быть десятичными, восьмеричными,
		шестнадцатеричными или символьными константами, по синтаксису
		C: 123 0145 0x45f6 'ab'. Результат всегда представляется в
		десятичной системе счисления.
		Вычисление происходит слева направо, без учета приоритета
		операций, можно использовать круглые скобки (..) и пробелы.


			 Маркеры строк

Первый символ как образца так и генерируемой строки используется несколько
особо (маркер строки или образца). Для ускорения работы макропроцессор
сравнивает очередную строку только с той группой макросов, которая имеет
тот же маркер, что и строка. Ко всем строкам, считанным из файла спереди
добавляется маркер " ". В генерируемых строках несколько маркеров
обрабатываются особо.

Особые маркеры строк:

.       Строка без дальнейшей обработки выводится на стандартный вывод
	(но без маркера).

,       То же, но строка выводится без '\n'.

>       Строка (без маркера) помещается в стек макропроцессора. Извлечь
	строку из стека можно использую переменную ~s в шаблоне.

"       Строка без маркера выводится на стандартный вывод ошибок.

!       Строка с номером строки исходного файла выводится на стандартный
	вывод ошибок и макропроцессор завершает работу. Используется для
	сообщений об ошибках при обработке входного файла.


		Начало и конец работы макропроцессора

Для того, чтобы в макропрограмме можно было производить инициализирующие и
завершающие действия предусмотрены 2 специальных маркера. В начале работы
макропрограммы, до считывания 1-ой строки входного файла, на вход
сопоставителей макропроцессора подается строка "." . В конце работы, после
считывании символа "конец файла" на сопоставление подается строка ">". В
отличие от обычных строк, неуспешное сопоставление этих спецстрок не
приводит к прекращению работы макропроцессора.


		     ВВОД С ЭКРАНА И ОТЛАДКА

При вводе с экрана макропроцессор выдает приглашение вида
"(номер строки) > ". Буферизация вывода при этом отключена.

Для отладки макропроцессору можно задать второй параметр - список маркеров.
Генерируя строки с такими маркерами, макропроцессор будет показывать это на
экране в виде =>(строка).


		   ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ

Если макропроцессору не задана макропрограмма, или вмести имени
макропрограммы стоит символ "-", то макропроцессор берет и макропрограмму и
обрабатываемый файл из входного потока. При этом макропрограмма может быть
"вклинена" во входной поток в нескольких местах. Каждая часть
макропрограммы должна начинаться и кончаться строкой "%%". Таким образом,
указанный макропроцессору файл может содержать перемежающиеся куски
(разделенные строками "%%") макропрограммы и обрабатываемого текста.


			   ПРИМЕРЫ

* === Программа, печатающая входной текст через строчку и с номерами строк

/ ?
 .~n\t~1
 .


* === Программа, преобразующая выражение в польскую запись. Обрабатываются
*     символы бинарных операций:  + - * / **  и скобки (...)

/.
 .\t\t>>> НАЧАЛО РАБОТЫ <<<\n

/>
 .\n\t\t<<< КОНЕЦ РАБОТЫ >>>

/ $**$
  ~1^~2

/ $[+-]$
  ~1
  ~3
 .~2

/ $[*/]$
  ~1
  ~3
 .~2

/ $^$
  ~1
  ~2
 .**

/ ($)
  ~1

/ ?
 .~1



АВТОР:          ФЛЕРОВ М.Н.     ИПК Минавтопрома, 1985 г.
