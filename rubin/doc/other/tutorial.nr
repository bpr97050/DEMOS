.de @h
'sp 4
'tl ''''
'sp 2
.ns
..
.t0
У Ч Е Б Н О Е   В В Е Д Е Н И Е    В
\*(SU
.t1
.de @f
'sp 3
'tl 'Учебное введение в \*(RU''Стр. %'
'bp
..
.de L+
.nf
..
.de L-
.fi
..
.rs
.ce 1
Учебное введение в \*(RU
.sp 5
Это пособие описывает использование системы управления базой данных \*(RU.
Вы должны иметь возможность выполнять приведенные здесь примеры и
наблюдать те же самые результаты.

Язык манипуляции данными, предоставляемый \*(RU,
называется QUEL (QUEry Language - язык запросов).
Полную информацию по QUEL и по \*(RU
можно найти в "Справочном руководстве по \*(RU".
Этот учебник не имеет своей целью охватить все детали \*(RU.

Начнем с входа в \*(DM - систему разделения времени, под управлением которой
работает \*(RU. Если это возможно, то используйте терминал со строчными
и прописными буквами, в противном случае вам будет довольно тяжело.
Если вы все-таки будете использовать терминал только с прописными
буквами, набирайте "\\\\" везде, где в тексте встречается "\\".

На вашем терминале сейчас должно быть напечатано приглашение системы.
Чтобы начать работать с \*(RU, наберите команду:
.nf

% \*(rN demo

.fi
Эта команда означает, что нужно запустить \*(RU с использованием
базы данных под именем "demo".
После нескольких секунд на терминале появится текст:
.nf

СУБД \*(RU
Пят ноя 14 16:27:53 1988

Версия для 16/32 битных машин

Ready
*

.fi
В первых трех строчках указан номер версии \*(RU (в данном случае
май 1986) и текущая дата. Дальше следует т.н. "dayfile" - файл
ежедневных сообщений, в котором находятся сообщения, относящиеся к
системе \*(RU.
"Ready" показывает, что \*(RU готова к работе с вами.

Монитор \*(RU печатает звездочку ("*") в начале каждой строки, как
напоминание о том,что \*(RU ждет ваших команд.

Наберите команду:
.nf

* print части
* \\g
Executing . . .

.fi
Строчка "print части" запрашивает распечатку некоторых данных,
хранящихся в базе данных. Команда "\\g" означает "go".
Сообщение "Executing . . ." показывает, что \*(RU выполняет ваш запрос.
Далее появляется следующее:
.nf

Отношение части


.L+
!номер !имя                 !цвет    !вес   !кол-во!
!--------------------------------------------------!
!     1!центр. процессор    !розовый !    10!     1!
!     2!память              !серый   !    20!    32!
!     3!дисковод            !черный  !   685!     2!
!     4!контроллер лент     !черный  !   450!     4!
!     5!магнитофон          !серый   !     1!   250!
!     6!печатающее у-во     !желтый  !   578!     3!
!     7!бумага АЦПУ         !белый   !    15!    95!
!     8!терминалы           !голубой !    19!    15!
!    13!счит. с перфолент   !черный  !   107!     0!
!    14!ленточный перфоратор!черный  !   147!     0!
!     9!терминальная бумага !белый   !     2!   350!
!    10!байтовое мыло       !прозрач.!     0!   143!
!    11!счит. с перфокарт   !серый   !   327!     0!
!    12!карточный перфоратор!серый   !   427!     0!
!--------------------------------------------------!
.L-

Continue
*

.fi
На вашем терминале распечаталось "отношение части".
Интуитивно, отношение - это не что иное, как таблица из строчек и столбцов.

В данном случае отношение называется "части".
В нем пять столбцов (будем называть их доменами), озаглавленных
номер(номер части), имя(имя части), цвет, вес
и кол-во(количество).
Каждая строчка отношения (называется кортеж) это один
вход в таблице, который представляет собой часть оборудования вычислительного
центра. В отношении может быть до 49 доменов и практически неограниченное
число кортежей.

Обратите внимание, что после того, как запрос выполнен, \*(RU
печатает "Continue", тогда как в начале работы \*(RU
напечатал "Ready".
Когда вы вводите запрос, \*(RU сохраняет то, что вы набрали в
"рабочей области". Если вы ошиблись в своем запросе, то напечатав
"\\r" вы "сбросите" (т.е. очистите) свою рабочую область (позже
мы покажем, как редактировать ошибки, не перепечатывая весь запрос).

В любой момент вы можете посмотреть, что находится в вашей рабочей области,
набрав "\\p".
Давайте сделаем это:
.nf

* \\p
print части
Continue
*

.fi
Распечатывается текущее содержание рабочей области. Теперь напечатаем
"\\r":
.nf

* \\r
Ready
*

.fi
Теперь рабочая область пуста.
Маленькое правило: когда \*(RU печатает "Continue", то рабочая область
не пуста, когда же она печатает "Ready" - рабочая область пуста.

После выполнения запроса \*(RU обычно печатает "Continue".
Если вы наберете новый запрос,
\*(RU сотрет предыдущий,
так что вам не нужно печатать
"\\r" после каждого запроса.
Мы объясним все это немного позже.

Используя команду "retrieve" (выдать),
мы можем составлять детальные запросы об отношениях.
В качестве примера давайте заставим \*(RU печатать
только домен имя  отношения части.
Наберите команду:
.nf

* range of p is части
* retrieve (p.имя )
* \\g
Executing . . .


.L+
!имя                 !
!--------------------!
!центр. процессор    !
!память              !
!дисковод            !
!контроллер лент     !
!магнитофон          !
!печатающее у-во     !
!бумага АЦПУ         !
!терминалы           !
!счит. с перфолент   !
!ленточный перфоратор!
!терминальная бумага !
!байтовое мыло       !
!счит. с перфокарт   !
!карточный перфоратор!
!--------------------!
.L-

Continue
*

.fi
Мы получили только домен имя из отношения части.
Для этого нам потребовалось сделать две вещи.
Сначала мы объявили то, что называется "кортеж-переменной"
и предписали ей действовать на отношении части.
.nf

range of p is части

.fi
Это значит, что буква p представляет отношение части.
Ее можно можно считать указателем, который движется по отношению
части, показывая, с каким именно элементом
мы сейчас работаем.
\*(RU запоминает это соответствие так, что если p
объявляется
действующей на части, нам не нужно будет повторять объявление
области действия в дальнейшем.
Это полезно,
когда мы работаем более,
чем с одним отношением.
Такой пример мы приведем немного позднее.

Далее мы использовали команду retrieve.
Она имеет следующий вид:
.nf

retrieve ( перечислите здесь то, что вы хотите получить )

.fi
"p" сама по себе обозначает (ссылается) на
отношение части.
"p.имя  " ссылается на домен имя
в этом отношении,
так что команда
.nf

retrieve (p.имя  )

.fi
обозначает: получить домен имя   отношения части.

Теперь попробуем получить имя и цвет :
.nf

* retrieve p.имя  , p.цвет
* \\g
Executing . . .

2500: Синтаксическая ошибка в строке 1. Последний прочитанный символ: .

Continue
*

.fi
К сожалению, мы сделали ошибку.
\*(RU сообщает, что она нашла
синтаксическую ошибку в 1 строке запроса.
Такое мсообщение означает,
что мы набрали что-то,что \*(RU
не может разобрать. Эта ошибка была найдена
в строчке 1. \*(RU делает иногда полезные,
а иногда и не очень, попытки распознать
ошибку. Если это возможно, \*(RU сообщает
нам последнее, что она прочла перед тем,
как испытать затруднение.

В данном случае ошибкой является отсутствие
скобок вокруг списка того, что мы хотим получить.
(Это называется целевым списком). Правильным
запросом будет :
.nf

* retrieve (p.имя, p.цвет)
* \\g
Executing . . .


.L+
!имя                 !цвет    !
!-----------------------------!
!центр. процессор    !розовый !
!память              !серый   !
!дисководve          !черный  !
!контроллер лент     !черный  !
!магнитофон          !серый   !
!печатающее у-во     !желтый  !
!бумага АЦПУ         !белый   !
!терминалы           !голубой !
!счит. с перфолент   !черный  !
!ленточный перфоратор!черный  !
!терминальная бумага !белый   !
!байтовое мыло       !прозрач.!
!счит. с перфокарт   !серый   !
!карточный перфоратор!серый   !
!-----------------------------!
.L-

Continue
*

.fi
Вы можете ограничить набор выдаваемых кортежей,
добавив к запросу "квалификации". Например,
чтобы получить имя и цвет только серых частей
допечатайте
.nf

* retrieve (p.имя, p.цвет)
* where p.цвет  = "серый"
* \\g
Executing . . .


.L+
!имя                 !цвет    !
!-----------------------------!
!память              !серый   !
!магнитофон          !серый   !
!счит. с перфолент   !серый   !
!карточный перфоратор!серый   !
!-----------------------------!
.L-

Continue
*

.fi
Обратите внимание,что \*(RU печатает только
те части, у которых p.цвет   -  серый
Так же обратите внимание на то, что слово
серый должно быть в "". Это необходимо,
т.к. единственный признак, с помощью
которого \*(RU различает символьные
строчки (например, слова), это
наличие вокруг них кавычек.

А что, если нам нужны имена частей серого или
розового цвета ? Для этого нам надо добавить
к предыдущему запросу следующую фразу
.nf

or p.цвет  = "розовый"

.fi
Но при это помните, что если следующая
вводимая строчка начинает новый
запрос, \*(RU автоматически
сбрасывает рабочую область.
Рабочая область будет сохранена,
если только следующая строчка
начинается с таких команд, как
"\ep" или "\eg"( есть еще подобные
команды, о которых будет упомянуто ниже ).
Если напечатать такую команду,
предыдущий запрос будет сохранен,
и все дальнейшее будет присоединено
к нему. Т.о., допечатав
.ul

.nf

* \\p
retrieve (p.имя, p.цвет)
where p.цвет  = "серый"
*

.fi
вы сможете посмотреть предыдущий
запрос. Теперь напечатайте :
.nf

* or p.цвет  = "розовый"
*

.fi
\*(RU добавит эту строчку в конец запроса.
Вы можете проверить это, распечатав
рабочую область.
.nf

* \\p
retrieve (p.имя  , p.цвет )
where p.цвет  = "серый"
or p.цвет  = "розовый"
*

.fi
Теперь запустите этот запрос :
.nf

* \\g
Executing . . .


.L+
!имя                 !цвет    !
!-----------------------------!
!центр.процессор     !розовый !
!память              !серый   !
!магнитофон          !серый   !
!счит. с перфолент   !серый   !
!карточный перфоратор!серый   !
!-----------------------------!
.L-

Continue
*

.fi
Может быть, правила о сбросе рабочей области
могут показаться вначале очень сложными.
В общем,
\*(RU делает именно то, что
Вы хотите, не заставляя Вас особенно
задумываться над этим.

Мы использовали "квалификации" с "or" и "=".
Кроме этого, можно использовать :
.nf

	and
	or
	not
	=       (равно)
	!=      (не равно)
	>       (больше )
	>=      (больше или равно)
	<       (меньше)
	<=      (меньнше или равно)

.fi

Вычисление этих квалификаций производится
в том порядке, в котором Вы их
печатаете (слева направо), для
изменения порядка вычислений
используются скобки.

\*(RU может производить вычисления над
данными, хранящимися в отношении.
Например, в отношении части указаны
количество и вес для каждой части.
Мы хотим узнать общий вес для каждой
части. Мы хотим узнать общий вес для
каждой группы частей ( т.е. вес * количество ).

Чтобы получить имя, номер и общий вес
для каждой части, наберите запрос :
.nf

* retrieve (p.имя, p.номер, p.колич * p.вес)
* \\g
Executing . . .

2500: Синтаксическая ошибка в строке 1. Последний прочитанный символ: *.


Continue
*

.fi
Опять ошибка. Проблема состоит в том,
что когда умножение выполнено, \*(RU
не знает, как озаглавить домен в распечатке.
Для простых доменов \*(RU использует
в качестве заголовка имя домена.
Для всеь остальных, вы должны создать новый
Заголовок домена, указав:
.nf

	общ = p.колич * p.вес

.fi
Или в более общем виде:
.nf

	заголовок = выражение

.fi
Например:
.nf

	имя = p.имя
	вычисление = p.вес / 2000 * (p.колич + 2)

.fi
Исправим ошибку, перепечатав запрос.
Т.к. первая строка после запроса не начиналась
с  "\\p" или "\\g" , то
\*(RU автоматически стирает рабочую область,
удаляя предыдущий запрос.
.nf

* retrieve (p.имя, p.номер, общ =p.колич * p.вес)
* \\g
Executing . . .


.L+
!имя                 !номер !общ   !
!----------------------------------!
!центр.процессор     !     1!    10!
!память              !     2!   640!
!дисковод            !     3!  1370!
!контроллер лент     !     4!  1800!
!магнитофон          !     5!   250!
!печатающее у-во     !     6!  1734!
!бумага АЦПУ         !     7!  1425!
!терминалы           !     8!   285!
!счит. с перфолент   !    13!     0!
!ленточный перфоратор!    14!     0!
!терминальная бумага !     9!   700!
!байтовое мыло       !    10!     0!
!счит. с перфокарт   !    11!     0!
!карточный перфоратор!    12!     0!
!----------------------------------!
.L-

Continue
*

.fi
Кроме умножения \*(RU умеет делать
.in +8

+   сложение
.br
-   вычитание ( и смена знака )
.br
/   деление
.br
*   умножение
.br
**  возведение в степень ( например 3**10 )
.br
abs абсолютное значение
.br
mod  деление по модулю
.br

.in -8
и многое другое.
Краткое, но полное описание арифметических
возможностей  смотрите в справочном руководстве \*(RU.

Если мы хотим получить части с номерами от 2 до 10,
то мы должны добавить квалификации:
.nf
	where p.номер = 2 or p.номер = 10
.fi
ПРЕДУПРЕЖДЕНИЕ: если мы начнем печатать
"where p.номер.... "
\*(RU поймет это, как начало нового запроса,
и очистит рабочую область. Для предотвращения
этого надо напечатать сначала
"\\p" и заставить \*(RU
распечатать рабочую область,
или вы можете напечатать
"\\a" (append-добавить).
Команда "append" гарантирует, что все, что вы
будете печатать, будет добавлено к тому, что уже есть
в рабочей области.
Эта команда особенно необходима после выполнения
запроса.
В других случаях добавление происходит автоматически.
Попробуйте сделать следующее:
.nf

* \\a
* where p.номер= 2 or p.номер= 10
* \\g
Executing . . .


.L+
|имя                 |номер |общ   |
|----------------------------------|
|память              |     2|   640|
|байтовое мыло       |    10|     0|
|----------------------------------|
.L-

Continue
*

.fi
Для получения всех частей, номера которых больше 2 и меньше или
равны 10:
.nf

* retrieve (p.имя, p.номер, общ =p.колич * p.вес)
* where p.номер> 2 and p.номер<= 10
* \\g
Executing . . .


.L+
!имя                 !номер !общ   !
!----------------------------------!
!дисковод            !     3!  1370!
!контроллер лент     !     4!  1800!
!магнитофон          !     5!   250!
!печатающее у-во     !     6!  1734!
!бумага АЦПУ         !     7!  1425!
!терминалы           !     8!   285!
!терминальная бумага !     9!   700!
!байтовое мыло       !    10!     0!
!----------------------------------!
.L-

Continue
*

.fi
Предположим, что мы хотим изменить
предыдущий запрос для получения частей с номерами
от 5 до 10 вместо от 2 до 10.
Вам, вероятно, уже наскучило перепечатывать весь запрос
для исменения всего одного символа.
Поэтому \*(RU позволяет вам использовать
текстовый редактор \*(DM для внесения
исправлений и/или
добавлений в вашу рабочую область.
Как только вы напечатаете "\\e", монитор
\*(RU запишет вашу рабочую область в файл
и вызовет программу
"red" - экранный редактор текстов \*(DM.
(строго говоря, это зависит от настройки макро в стартовом файле \*(RU,
и вы можете изменить имя редактора в своем стартовом файле, см. раздел
MACRO(QUEL) в справоном руководстве).
Например:
.nf

* \\e
>>red

.fi
На экран выдастся рамка и изображение файла - буфера запросов \*(RU.

Теперь вы можете редактировать запрос, изменять в нем
2 на 5.
Начальные сведения об исользовании редактора "red" включены
в документацию по \*(DM.

В запросе

.nf
  retrieve (p.имя, p.номер, общ = p.колич * p.вес)
  where p.номер> 2 and p.номер<= 10
.fi

заменим во второй строке 2 на 5:

.nf
  where p.номер> 5 and p.номер<= 10
.fi

и выйдем из редактора с записью изменений.

.nf
Continue
*

.fi
В редакторе вы можете использовать все его команды.

Когда вы выходите из редактора (команда "q"),
монитор \*(RU печатает "Continue", сообщая вам,
что вы опять вернулись в \*(RU.

Для проверки правильности и выполнения запроса, печатайте:
.nf

* \\p\\g
retrieve (p.имя, p.номер, общ = p.колич * p.вес)
where p.номер> 5 and p.номер<= 10
Executing . . .


.L+
|имя                 |номер |общ   |
|----------------------------------|
|печатающее у-во     |     6|  1734|
|бумага АЦПУ         |     7|  1425|
|терминалы           |     8|   285|
|терминальная бумага |     9|   700|
|байтовое мыло       |    10|     0|
|----------------------------------|
.L-

Continue
*

.fi

Исчерпав интересующие нас запросы, связанные с отношением
"части", давайте теперь перейдем к рассмотрению другого отношения,
называемого "поставки".
Печатайте:
.nf

* print поставки
* \\g
Executing . . .


Отношение поставки

.L+
|nпост |nчасти|nакта |дата_пос|размер|
|------------------------------------|
|   475|     1|  1001|73-12-31|     1|
|   475|     2|  1002|74-05-31|    32|
|   475|     3|  1001|73-12-31|     2|
|   475|     4|  1002|74-05-31|     1|
|   122|     7|  1003|75-02-01|   144|
|   122|     7|  1004|75-02-01|    48|
|   122|     9|  1004|75-02-01|   144|
|   440|     6|  1001|74-10-10|     2|
|   241|     4|  1001|73-12-31|     1|
|    62|     3|  1002|74-06-18|     3|
|   475|     2|  1001|73-12-31|    32|
|   475|     1|  1002|74-07-01|     1|
|     5|     4|  1003|74-11-15|     3|
|     5|     4|  1004|75-01-22|     6|
|    20|     5|  1001|75-01-10|    20|
|    20|     5|  1002|75-01-10|    75|
|   241|     1|  1005|75-06-01|     1|
|   241|     2|  1005|75-06-01|    32|
|   241|     3|  1005|75-06-01|     1|
|    67|     4|  1005|75-07-01|     1|
|   999|    10|  1006|76-01-01|   144|
|   241|     8|  1005|75-07-01|     1|
|   241|     9|  1005|75-07-01|   144|
|------------------------------------|
.L-

Continue
*

.fi
Отношение "поставки" содержит nпост (номер поставщика),
nчасти (номер части, поставляемой поставщиком),
nакта (номер акта о поставке),
дата_пос (дата отгрузки),
и размер (размер поставки).

Для поиска частей, поставляемых оставщиком номер 122 печатайте:
.nf

* retrieve (s.nчасти) where s.nпост =122
* \\g
Executing . . .

2109: СТРОКА 1, Переменная 's' не объявлена
в операторе RANGE.

Continue
*

.fi
Мы сослались на кортеж-переменную "s"
(т.е. s.nчасти без объявления \*(RU, что
она представляет.)
Мы ошиблись в декларации "range".
Перепечатаем запрос следующим образом:
.nf

* range of s is поставки
* retrieve (s.nчасти)where s.nпост =122
* \\g
Executing . . .


.L+
|nчасти|
|------|
|     7|
|     7|
|     9|
|------|
.L-

Continue
*

.fi
Поставщик номер 122 поставляет части с номерами
7, 7 и 9.
Обратите внимание, что
7 повторяется дважды.
При выдаче результата запроса на терминал для \*(RU
более эффективно не проверять дублирование кортежей.
Но \*(RU можно принудить удалять повторяющиеся кортежи.
Мы придем к этому позже.
Сейчас мы знаем, что поставщик номер 122
поставляет части 7 и 9.
Если вы не запускали этот запрос довольно долго,
вы можете не знать какие названия частей соответствуют
частям с номерами 7 и 9.
Мы можем это узнать просто выдав запрос:
.nf

* retrieve (p.имя) where p.номер= 7 or
* p.номер= 9
* \\g
Executing . . .


.L+
|имя                 |
|--------------------|
|бумага АЦПУ         |
|терминальная бумага |
|--------------------|
.L-

Continue
*

.fi
После выполнения этих двух запросов мы знаем названия частей
поставляемыь поставщиком номер 122.
Мы могли получить этот же результат в одном запросе:
.nf

* retrieve (p.имя) where p.номер= s.nчасти
* and s.nпост  122
* \\g
Executing . . .


.L+
|имя                 |
|--------------------|
|бумага АЦПУ         |
|бумага АЦПУ         |
|терминальная бумага |
|--------------------|
.L-

Continue
*

.fi
Снова заметим, что "бумага АЦПУ" повторяется дважды.
Посмотрим внимательно на этот запрос.
Заметим, что домен номер существует в обоих
отношениях "части" и "поставки".
Сказав, p.номер= s.nчасти, мы логически объединим
эти два отношения.

Предположим, мы захотели найти всех поставщиков,
которые поставляют центральный процессор.
Мы знаем, что мы должны выдать s.nпост (номер поставщика).
Но мы хотим выдать только те s.nпост, где
соответствующий s.nчасти (номер части)
означает часть с названием "центр.процессор".

Если мы найдем p.имя, которое равно "центр.процессор",
то у этой части интересующий нас p.номер.
Окончательно мы хотим : s.nчасти=p.номер
Запрос будет:
.nf

* retrieve (s.nпост) where
* s.nчасти=p.номер and p.имя = "центр.процессор"
* \\g
Executing . . .


.L+
|nпост |
|------|
|   475|
|   475|
|   241|
|------|
.L-

Continue
*

.fi
Давайте оставим отношения "части" и "поставки" и перейдем к
другим.
Для начала мы посмотрим, какие другие отношения имеются
в базе данных, напечатав:
.nf

* help \\g
*Executing . . .


 имя отношения     владелец отношения

 relation          \*(rN
 attribute         \*(rN
 indexes           \*(rN
 integrity         \*(rN
 constraint        \*(rN
 товары            \*(rN
 сбыт              \*(rN
 служащие          \*(rN
 снабжение         \*(rN
 части             \*(rN
 поставки          \*(rN
 отделы            \*(rN
 поставщики        \*(rN


Continue
*

.fi
Давайте рассмотрим отношение "служащие".
Однако, мы ничего не знаем об этом отношении,
но мы можем использовать команду "help"
для получения информации о нем.
Печатайте:
.nf

* help служащие
* \\g
Executing . . .


Отношение:              служащие
Владелец:               \*(rN
Ширина кортежа:         30
Сохранять до:           Сре Ноя 19 11:01:30 1986
Число кортежей:         25
Структура файла:        листованная куча
Тип отношения:          отношение пользователя

 имя атрибута     тип   длина    ключ.

 номер              i       2
 имя                c      20
 оклад              i       2
 управл             i       2
 дата_рожд          i       2
 нач_раб            i       2


Continue
*

.fi
Команда "help" выдает общую информацию
об отношении вместе с каждым
атрибутом, его типом и длиной.

\*(RU поддерживает 3 типа данных:
целые числа, числа с плавающей точкой и
строки символов.
Символьные домены могут быть длиной
от 1 до 255 символов. Целые домены
могут быть длиной 1,2 и 4 байта.
Это значит, что целые могут принимать
значения до 127, 32.767 и 2.147.483.647
соответственно.
Числа с плавающей точкой могут быть
длиной 4 или 8 байтов. Числа обоих
типов могут принимать значения
до 10**38 с точностью 7 или 17 знаков
соответсвенно.
Чтобы  просмотреть все домены, мы должны использовать
команду "print" или использовать команду "retrieve",
где указан каждый домен в запросе.
\*(RU предоставляет наикратчайший путь.
Попробуйте следующее:
.nf

* range of e is служащие
* retrieve (e.all)
* \\g
Executing . . .


.L+
|номер |имя                 |оклад |управл|дата_р|нач_ра|
|-------------------------------------------------------|
|  157 | Петрыкин, Михаил   | 140  | 199  |1961  | 1983 |
| 1110 | Петров, Михаил     | 300  |  33  |1955  | 1978 |
|   35 | Никифоров, Михаил  | 300  |  32  |1961  | 1983 |
|  129 | Васильева, Ирина   | 160  | 199  |1961  | 1983 |
|   13 | Артуров, Игорь     | 135  | 199  |1964  | 1983 |
|  215 | Артурова, Галина   | 135  |  10  |1964  | 1983 |
|   55 | Сергеев, Дмитрий   | 135  | 199  |1964  | 1984 |
|   26 | Ильина, Елена      | 140  | 199  |1959  | 1981 |
|   98 | Петин, Александр   | 280  | 199  |1949  | 1971 |
|   32 | Веселый, Сергей    | 280  | 199  |1956  | 1979 |
|   33 | Скучный, Евгений   | 100  | 199  |1966  | 1982 |
|  199 | Семенов, Андрей    | 160  |   0  |1956  | 1979 |
| 4901 | Простакова, Елена  | 250  |  32  |1956  | 1979 |
|  843 | Рашидов, Надим     | 320  |  26  |1950  | 1972 |
| 2398 | Васильева, Наталья | 160  |  26  |1961  | 1983 |
| 1639 | Охта, Ольга        | 145  |  55  |1956  | 1979 |
| 5119 | Пупырев, Михаил В. | 180  |  55  |1961  | 1983 |
|   37 | Пантеров, Андрей   | 135  |  26  |1961  | 1983 |
| 5219 | Медведев, Андрей   | 220  |  33  |1961  | 1981 |
| 1523 | Лисина, Евгения    | 140  | 129  |1963  | 1980 |
|  430 | Соболев, М.И.      | 420  | 129  |1941  | 1964 |
|  994 | Андриянов, Николай | 120  | 129  |1961  | 1983 |
| 1330 | Зеленов, Игорь     | 190  |  13  |1966  | 1986 |
|   10 | Зеленов, Иван      | 120  | 199  |1965  | 1984 |
|   11 | Яблочков, Максим   | 300  |   0  |1964  | 1986 |
---------------------------------------------------------
.L-

Continue
*
.fi

"all" - это ключевое слово, которое
\*(RU разворачивает в список всех доменов.
Не существует обязательного порядка
в котором перечисляются домены.
Предыдущий запрос эквивалентен следующему:
.nf

	range of e is служащие
	retrieve (e.номер, e.имя, e.оклад, e.управл,
		e.дата_рожд, e.нач_раб)

.fi
Давайте выдадим оклад Зеленова Вани.
В этом месте нам нужно будет печатать
буквы как верхнего, так и нижнего регистров.
Если на Вашем терминале только прописные буквы,
напечатайте "\\" перед буквой, которая должна
быть заглавной. Т.о. на терминалах только
с верхним регистром печатайте т.о.
"\\ЛОБАНОВ, \\ВАНЯ"
Если же у Вас на терминале есть как
прописные, так и строчные буквы, то
используйте соответствующие клавиши
переключения регистров.

Выдайте запрос:
.nf

* retrieve (e.имя,e.оклад)
* where e.name = "Зеленов, Ваня"
* \\g
Executing . . .


.L+
!имя                 !оклад !
!---------------------------!
!---------------------------!
.L-

Continue
*

.fi
Результат пуст.
Нет такого e.имя, которое
соответствует заданной квалификации.
Это странно, т.к. мы знаем, что
у нас есть Зеленов Ваня, но \*(RU
тем не менее, не знает, что "Ваня"
и "Иван" семантически одно и то же.

Чтобы получить правильный ответ в
этой ситуации, Вы можете использовать
поиск по образцу, который предоставляет \*(RU.

Одним из специальных символов,
служащих для этой цели, является "*".
Она соответствует любой строке длиной
0 и более символов.
Выдайте запрос:
.nf

* retrieve (e.имя,e.оклад)
* where e.name = "Зеленов, И*"
* \\g
Executing . . .


.L+
!имя                 !оклад !
!---------------------------!
!Зеленов, Игорь      ! 190  !
!Зеленов, Иван       ! 120  !
!---------------------------!
.L-

Continue
*

.fi
В первом случае "*" соответствует "горь",
а во втором "ван".

Пожалуйста, еще один пример, выдать
оклады всех людей, которых зовут "Михаил".
.nf

* retrieve (e.имя,e.оклад)
* where e.имя = "*,Михаил*"
* \\g
Executing . . .


.L+
!имя                 !оклад !
!---------------------------!
| Петрыкин, Михаил   | 140  |
| Петров, Михаил     | 300  |
| Никифоров, Михаил  | 300  |
| Пупырев, Михаил В. | 180  |
!---------------------------!
.L-

Continue
*

.fi
Обратите внимание, что если бы мы задали
e.имя = "*, Михаил", мы не получили бы
четвертый кортеж. Кроме того, \*(RU
игнорирует пробелы в любом символьном
сравнении, независимо от того, используется
ли поиск по образцу или нет.
Это значит, что
.nf

	e.имя = "Петров,Михаил"
	e.имя = "Петров,  Михаил   "
	e.имя = "П е т р о в, Михаил"

.fi
дает один и тот же результат.
Отдельные символы или диапазоны символов
могут заключаться в квадратные скобки ( [,] ).
Например, выдать тех, чьи имена начинаются с букв
от А до О.
.nf

* retrieve (e.имя,e.оклад)
* where e.name = "[А-О]*"
* \\g
Executing . . .


.L+
!name                !salary!
!---------------------------!
| Петрыкин, Михаил   | 140  |
| Никифоров, Михаил  | 300  |
| Васильева, Ирина   | 160  |
| Артуров, Игорь     | 135  |
| Артурова, Галина   | 135  |
| Сергеев, Дмитрий   | 135  |
| Ильина, Елена      | 140  |
| Петин, Александр   | 280  |
| Веселый, Сергей    | 280  |
| Скучный, Евгений   | 100  |
| Семенов, Андрей    | 160  |
| Простакова, Елена  | 250  |
| Рашидов, Надим     | 320  |
| Васильева, Наталья | 160  |
| Охта, Ольга        | 145  |
| Медведев, Андрей   | 220  |
| Соболев, М.И.      | 420  |
| Андриянов, Николай | 120  |
| Зеленов, Игорь     | 190  |
| Зеленов, Иван      | 120  |
-----------------------------
.L-

Continue
*

.fi
Обратите внимание, что этот запрос можно было
задать по другому.
.nf

* retrieve (e.имя,e.оклад)
* where e.имя >"А*" and e.имя <"П*"
* \\g
Executing . . .


.L+
!имя                 !оклад !
!---------------------------!
| Петрыкин, Михаил   | 140  |
| Никифоров, Михаил  | 300  |
| Васильева, Ирина   | 160  |
| Артуров, Игорь     | 135  |
| Артурова, Галина   | 135  |
| Сергеев, Дмитрий   | 135  |
| Ильина, Елена      | 140  |
| Петин, Александр   | 280  |
| Веселый, Сергей    | 280  |
| Скучный, Евгений   | 100  |
| Семенов, Андрей    | 160  |
| Простакова, Елена  | 250  |
| Рашидов, Надим     | 320  |
| Васильева, Наталья | 160  |
| Охта, Ольга        | 145  |
| Медведев, Андрей   | 220  |
| Соболев, М.И.      | 420  |
| Андриянов, Николай | 120  |
| Зеленов, Игорь     | 190  |
| Зеленов, Иван      | 120  |
-----------------------------
.L-

Continue
*

.fi
Результаты совпадают.
Тем не менее, второй способ более эффективен
при работе с \*(RU.

.in +8
.ti -4
Есть три типа конструкций для поиска по образцу:
*  -  соответствует строке любой длины
.ti -4
?  -  соответствует 1 символу ( отличному от пробела )
.ti -4
[] -  соответствует любому символу, перечисленному
в скобках. Если два символа разделены знаком минус
( "-" ), то они соответствуют любому символу,
попадающему в диапазон между ними.

.in -8

Чтобы спецсимвол воспринимался, как
обычный, перед ним надо поставить "\\".
Так "\\*" означает символ "*".

Теперь мы переходим к описанию групповых
действий, поддерживаемых \*(RU.
Эти действия позволяют пользователю производить
вычисления по целым доменам отношения.
Например, таким действием является
"найти среднее" ( avg ).
Чтобы посчитать средний оклад всех
сотрудников, мы даем запрос:
.nf

* retrieve (сроклад=avg(e.оклад))
* \\g
Executing . . .


.L+
!сроклад   !
!----------!
!   198.600!
!----------!
.L-

Continue
*

.fi
Заголовок можно выбрать любой,
обязательно только его присутствие.
\*(RU требует заголовок для любого
выражения ( отличного от простого домена )
в целевом списке.
.ul

Мы также можем найти самый маленький
и самый большой оклад:
.nf

* retrieve (minокл=min(e.оклад),maxокл=max(e.оклад))
* \\g
Executing . . .


.L+
!minокл!maxокл!
!-------------!
!  100 ! 420  !
!-------------!
.L-

Continue
*

.fi
Если мы хотим узнать имена сотрудников,
получающих самый маленький и самый большой
оклады, то запрос должен иметь вид:
.nf

* retrieve (e.имя, e.оклад)
* where e.оклад = min(e.оклад) or e.оклад = max(e.оклад)
* \\g
Executing . . .

.L+
!имя                 !оклад !
!---------------------------!
!Скучный, Евгений    !  100 !
!Соболев, М.И.       !  420 !
!---------------------------!
.L-

Continue
*

.fi
В \*(RU есть следующие групповые действия:
.nf

	count
	min
	max
	avg
	sum
	any

.fi
Теперь давайте посмотрим на запрос,
который выдает имя каждого сотрудника
вместе со средним окладом:
.nf

* retrieve (e.имя,сроклад=avg(e.оклад))
* \\g
Executing . . .


.L+
!имя                 !сроклад   !
!-------------------------------!
| Петрыкин, Михаил   | 198.600  |
| Петров, Михаил     | 198.600  |
| Никифоров, Михаил  | 198.600  |
| Васильева, Ирина   | 198.600  |
| Артуров, Игорь     | 198.600  |
| Артурова, Галина   | 198.600  |
| Сергеев, Дмитрий   | 198.600  |
| Ильина, Елена      | 198.600  |
| Петин, Александр   | 198.600  |
| Веселый, Сергей    | 198.600  |
| Скучный, Евгений   | 198.600  |
| Семенов, Андрей    | 198.600  |
| Простакова, Елена  | 198.600  |
| Рашидов, Надим     | 198.600  |
| Васильева, Наталья | 198.600  |
| Охта, Ольга        | 198.600  |
| Розовый, Михаил    | 198.600  |
| Пантеров, Андрей   | 198.600  |
| Медведев, Андрей   | 198.600  |
| Лисина, Евгения    | 198.600  |
| Соболев, М.И.      | 198.600  |
| Андриянов, Николай | 198.600  |
| Зеленов, Игорь     | 198.600  |
| Зеленов, Иван      | 198.600  |
| Яблочков, Максим   | 198.600  |
---------------------------------
.L-

Continue
*

.fi
Групповое действие всегда выдает одно значение.
Обрабатывая последний запрос, \*(RU
повторила средний оклад после каждого
e.имя.

Групповые действия могут иметь свою собственную
квалификацию. Например, мы можем получить список
из имен всех сотрудников, плюс средний
оклад для всех сотрудников старше 30 лет.
.nf

* retrieve (e.имя,сроклад=
* avg(e.оклад where 1986-e.дата_рожд > 30)
* \\g
Executing . . .


.L+
!имя                 !сроклад   !
!-------------------------------!
| Петрыкин, Михаил   | 330.000  |
| Петров, Михаил     | 330.000  |
| Никифоров, Михаил  | 330.000  |
| Васильева, Ирина   | 330.000  |
| Артуров, Игорь     | 330.000  |
| Артурова, Галина   | 330.000  |
| Сергеев, Дмитрий   | 330.000  |
| Ильина, Елена      | 330.000  |
| Петин, Александр   | 330.000  |
| Веселый, Сергей    | 330.000  |
| Скучный, Евгений   | 330.000  |
| Семенов, Андрей    | 330.000  |
| Простакова, Елена  | 330.000  |
| Рашидов, Надим     | 330.000  |
| Васильева, Наталья | 330.000  |
| Охта, Ольга        | 330.000  |
| Розовый, Михаил    | 330.000  |
| Пантеров, Андрей   | 330.000  |
| Медведев, Андрей   | 330.000  |
| Лисина, Евгения    | 330.000  |
| Соболев, М.И.      | 330.000  |
| Андриянов, Николай | 330.000  |
| Зеленов, Игорь     | 330.000  |
| Зеленов, Иван      | 330.000  |
| Яблочков, Максим   | 330.000  |
---------------------------------
.L-

 Continue
 *

.fi
Предыдущий запрос отличается от следующего.
Мы получим имена тех служащих, которым за 30 среднюю зарплату
для всех служащих.
.nf

* retrieve (e.имя,сроклад=avg(e.оклад))
* where 1986-e.дата_рожд > 30
* \\g
Executing . . .


.L+
|имя                 |сроклад   |
|-------------------------------|
| Петров, Михаил     | 198.600  |
| Петин, Александр   | 198.600  |
| Рашидов, Надим     | 198.600  |
| Соболев, М.И.      | 198.600  |
|-------------------------------|
.L-

Continue
*

.fi
Имеется очень важное отличие между последующими двумя запросами.
Групповые функции полностью самостоятельны.
На них не влияют квалификации
всего запроса.

В первом случае средний оклад получен только
для сотрудников старше 30 лет и
выдаются все сотрудники.
Во втором случае средний оклад
считается для всех сотрудников,
но выдаются только те, которые старше 30 лет.

Если мы хотим получить список всех сотрудников
старше 30 лет вместе с их средним окладом,
то мы должны объединить 2 предыдущих
запроса в 1.
Получится вот что:
.nf

* retrieve (e.имя, сроклад=
* avg(e.оклад where 1986 - e.дата_рожд > 30))
* where 1986 - e.дата_рожд > 30
* \\g
Executing . . .


.L+
!имя                 !сроклад   !
!-------------------------------!
| Петров, Михаил     | 330.000  |
| Петин, Александр   | 330.000  |
| Рашидов, Надим     | 330.000  |
| Соболев, М.И.      | 330.000  |
!-------------------------------!
.L-

Continue
*

.fi
Иногда бывает полезно убрать
повторяющиеся значения
перед выполнением группового
действия.
Например, если нам нужно узнать
сколько у нас управляющих,
следующий запрос не даст нам
правильного ответа.
.nf

* retrieve (руков = count(e.управл))
* \\g
*Executing . . .


.L+
!руков        !
!-------------!
!           25!
!-------------!
.L-

Continue
*

.fi
Обратите внимание, что нам выдалось количество кортежей
в отношении. Нам же нужно узнать сколько неповторяющихся
e.manager есть в нем.

В \*(RU есть 3 особые формы групповых действий:


 	countu	 посчитать неповторяющиеся значения
 	avgu	вычислить среднее для неповторяющихся значений
 	sumu	суммировать неповторяющиеся значения


Интересно заметить, что minu, maxu и anyu не нужны.
Их значения не зависят от того, есть неповторяющиеся
значения или нет.

Правильным запросом для выяснения количества
управляющих будет следующий:
.nf

* retrieve (руков=countu(e.управл))
* \\g
Executing . . .


.L+
!руков        !
!-------------!
!            9!
!-------------!
.L-

Continue
*

.fi
В \*(RU также есть т.н. групповые
функции. Групповые функции разбивают данные
на категории и выполняют отдельные
групповые действия для каждой категории.

Например, чтобы получть имя каждого сотрудника,
средний оклад для всех сотрудников с одинаковыми
управляющими, нужно набрать
запрос:
.nf

* retrieve (e.имя,ср_по_упр=avg(e.оклад by e.управл))
* \\g
Executing . . .


.L+
!имя                 !ср_по_упр !
!-------------------------------!
|Артурова, Галина    |   135.000|
|Семенов, Андрей     |   230.000|
|Яблочков, Максим    |   230.000|
|Простакова, Елена   |   275.000|
|Никифоров, Михаил   |   275.000|
|Медведев, Андрей    |   260.000|
|Петров, Михаил      |   260.000|
|Зеленов, Игорь      |   190.000|
|Охта, Ольга         |   162.500|
|Розовый, Михаил     |   162.500|
|Васильева, Наталья  |   205.000|
|Рашидов, Надим      |   205.000|
|Пантеров, Андрей    |   205.000|
|Артуров, Игорь      |   165.556|
|Сергеев, Дмитрий    |   165.556|
|Скучный, Евгений    |   165.556|
|Веселый, Сергей     |   165.556|
|Петрыкин, Михаил    |   165.556|
|Петин, Александр    |   165.556|
|Зеленов, Иван       |   165.556|
|Васильева, Ирина    |   165.556|
|Ильина, Елена       |   165.556|
|Андриянов, Николай  |   226.667|
|Соболев, М.И.       |   226.667|
|Лисина, Евгения     |   226.667|
---------------------------------
.L-

Continue
*

.fi
Первый  человек работает под руководством
одного и того же управляющего, и их
оклад составляет 135.000 рублей.
Следующие 2 человека тоже работают
под руководством одного и того же
управляющего, и их оклад - 162.500 рублей.

Еще раз, если мы хотим получить список
сотрудников старше 30 лет, то
запрос будет иметь следующий вид:
.nf

* retrieve (e.имя,ср_по_упр=
  avg(e.оклад by e.управл))
* where 1986-e.дата_рожд > 30
* \\g
Executing . . .


.L+
!имя                 !ср_по_упр !
!-------------------------------!
| Петров, Михаил     | 260.000  |
| Петин, Александр   | 165.556  |
| Рашидов, Надим     | 205.000  |
| Соболев, М.И.      | 226.000  |
!-------------------------------!
.L-

Continue
*

.fi
Групповые функции ( в отличие от
групповых действий ) не замкнуты в себе.
Домены, по которым разбиваются
данные ( называемые "список-by")
логически присоединяются ко всем
остальным доменам в запросе.

В последних примерах
"e.управл" в by-списке относится
к тому же кортежу, что
и "e.имя" в целевом списке.

Если мы хотим посчитать средний
оклад тех, кто работает
под руководством управляющих
33 и 199, то запрос будет таким:
.nf

* retrieve (e.имя,ср_по_упр=
* avg(e.оклад by e.управл)
* where e.управл = 199 or e.управл = 33
* \\g
Executing . . .


.L+
!имя                 !ср_по_упр !
!-------------------------------!
|Петров, Михаил      |   260.000|
|Медведев, Андрей    |   260.000|
|Петрыкин, Михаил    |   165.556|
|Васильева, Ирина    |   165.556|
|Артуров, Игорь      |   165.556|
|Сергеев, Дмитрий    |   165.556|
|Ильина, Елена       |   165.556|
|Петин, Александр    |   165.556|
|Веселый, Сергей     |   165.556|
|Скучный, Евгений    |   165.556|
|Зеленов, Иван       |   165.556|
---------------------------------
.L-

Continue
*

.fi
Теперь предположим, что нам нужно выяснить
сколько человек работает под
руководством каждого управляющего,
причем учитывая только тех сотрудников,
кто проработал минимум 7 лет:
.nf

* retrieve (e.управл,человек=
 count(e.имя by e.управл where
* e.нач_раб < 1979))
* \\g
Executing . . .


.L+
!управл!человек      !
!--------------------!
!     0!            0!
!    10!            0!
!    13!            0!
!    26!            1!
!    32!            0!
!    33!            0!
!    55!            0!
!   129!            1!
!   199!            1!
!--------------------!
.L-

Continue
*

.fi
Обратите внимание, что управляющие 0, 10, 13, 32, 33, 55
не имеют сотрудников, кто работал до 79 года.
Теперь, скажем, нам нужно узнать средний
оклад для этих сотрудников.
Просто поменяем "count" на "avg".
.nf

* retrieve (e.управл,человек=
 avg(e.оклад by e.управл where
* e.нач_раб < 1979))
* \\g
Executing . . .


.L+
!управл!человек   !
!-----------------!
!     0!     0.000!
!    10!     0.000!
!    13!     0.000!
!    26!   320.000!
!    32!     0.000!
!    33!   300.000!
!    55!     0.000!
!   129!   420.000!
!   199!   280.000!
!-----------------!
.L-

Continue
*

.fi
Обратите внимание, что
\*(RU делает для управляющих
0, 10, 13, 32, 55.
Средний оклад для сотрудников
этих управляющих не определен,
т.к. у них нет сотрудников,
работавших раньше 1979 г.
В гупповых действиях \*(RU
всегда считает неопределенные значения
равными нулю.

Если Вы хотите удалить нулевые значения из
вывода, то к запросу надо
добавить соответствующую квалификацию.
Следующий запрос выдает средние оклады,
только если они больше 0.
.nf

* retrieve (e.управл,человек=
*  avg(e.оклад by e.управл where e.нач_раб < 1979))
*  where
*  avg(e.оклад by e.управл where e.нач_раб < 1979) > 0
* \\g
Executing . . .


.L+
!управл!человек   !
!-----------------!
!    26!   320.000!
!    33!   300.000!
!   129!   420.000!
!   199!   280.000!
!-----------------!
.L-

Continue
*

.fi
До сих пор мы выдавали результаты прямо на
терминал. Также можно сохранить результаты
в новом отношении.
Это выполняется такой командой:
.nf

	retrieve into newrel ( ... )
	where . . .

.fi
Все правила будут точно такими же, как и для
выдачи на терминал. \*(RU создаст новое
отношение с соответствующими доменами
и
поместит результат запроса в новое отношение.

Например, создадим новое отношение,
которое называется "начальство",
в котором будут только те сотрудники,
которые зарабатывают больше 250 рублей.
.nf

* retrieve into начальство (e.all)
* where e.оклад > 250
* print начальство
* \\g
Executing . . .


Отношение начальство

.L+
!номер !имя                 !оклад !управл!день_р!нач_ра!
!-------------------------------------------------------!
|   11 | Яблочков, Максим   | 300  |   0  |1964  | 1986 |
|   32 | Веселый, Сергей    | 280  | 199  |1956  | 1979 |
|   35 | Никифоров, Михаил  | 300  |  32  |1961  | 1983 |
|   98 | Петин, Александр   | 280  | 199  |1949  | 1971 |
|  430 | Соболев, М.И.      | 420  | 129  |1941  | 1964 |
|  843 | Рашидов, Надим     | 320  |  26  |1950  | 1972 |
| 1110 | Петров, Михаил     | 300  |  33  |1955  | 1978 |
---------------------------------------------------------
.L-

Continue
*

.fi
По команде "retrive into" ничего не печатается.
Мы должны включить команду "print" в запрос,
чтобы выдать результат.
Кроме того, отношения с таким именем не
должно существовать.
Например, если мы запустим еще
раз этот запрос, то получим сообщение об
ошибке.
.nf

* \\g
Executing . . .

5102: CREATE: нельзя дублировать имя отношения

Continue
*

.fi
У "retrive into" есть две особенности. Во-первых,
новое отношение автоматически сортируется и
повторяющиеся кортежи удаляются.
Во-вторых, отношение становится частью
базы данных, и Вы являетесь его владельцем.
Если Вы не хотите сохранить это отношение,
то Вам нужно его разрушить. Как это
делается, мы рассмотрим чуть-чуть позже.

До сих пор мы только выдавали данные,
но не изменяли их.
В \*(RU есть 3 команды изменения:
append( добавить ), replace( заменить ) и delete( уничтожить ).

Например, чтобы добавить Игоря Алексеева
к списку очень хорошо получающих с
окладом 320 рублей надо сделать запрос:
.nf

* append to начальство(имя = "Алексеев, Игорь", оклад = 320)
* \\g
Executing . . .


Continue
*

.fi
Обратите внимание, что мы задали значение только
для 2 из 6 доменов. Это
правильно. \*(RU автоматически установит
численные домены в 0 и символьные домены в пробел,
если они не заданы.

Кроме того \*(RU ничего не напечатал после
выполнения запроса. Все команды изменения ничего не печатают.

Давайте дадим всем, кто хорошо получает,
10% надбавку:
.nf

* range of o is начальники
* replace o(оклад = o.оклад * 1.1)
* \\g
Executing . . .


Continue
*

.fi
Команде "append" требуется имя отношения
( например: append to начальники ),
тогда как командам "replace" и "delete"
требуется кортеж-переменная.
Т.е. команда будет иметь вид:
.nf

	replace o ( . . . )
		where . . .

а не:

	replace начальство ( . . . )
		where . . .

.fi
Напечатаем результаты двух
последних изменений:
.nf

* print начальство
* \\g
Executing . . .


Отношение начальство

.L+
!номер !имя                 !оклад !управл!день_р!нач_ра!
!-------------------------------------------------------!
|   11 | Яблочков, Максим   | 330  |   0  |1964  | 1986 |
|   32 | Веселый, Сергей    | 308  | 199  |1956  | 1979 |
|   35 | Никифоров, Михаил  | 330  |  32  |1961  | 1983 |
|   98 | Петин, Александр   | 308  | 199  |1949  | 1971 |
|  430 | Соболев, М.И.      | 462  | 129  |1941  | 1964 |
|  843 | Рашидов, Надим     | 352  |  26  |1950  | 1972 |
| 1110 | Петров, Михаил     | 330  |  33  |1955  | 1978 |
|    0 | Алексеев, Игорь    | 352  |   0  |   0  |    0 |
!-------------------------------------------------------!
.L-

Continue
*

.fi
Давайте уволим тех, у кого самый
маленький оклад:
.nf

* delete o where o.оклад = min(o.оклад) \\g
Executing . . .


Continue
*

.fi
Еще раз заметьте, что команда "delete"
требует кортеж-переменной (например : delete 0 ),
а не имя отношения.

Предположим, мы хотим узнать, кто
зарабатывает больше Игоря Алексеева ?
Рассмотрим, как создать такой запрос.
Сначала мы используем новую кортеж-переменную
"t" с областью действия "начальство"
которая указывать на Игоря.
"t.name" должно быть равным "Алексеев, Игорь"
Далее мы используем
кортеж-переменную "о", которая
будет пробегать все отношение.
Если мы найдем o.оклад > t.оклад,
то это значит, что o.name получает
больше, чем Игорь.

Итак, запрос выглядит следующим образом:
.nf

* range of t is начальство
* retrieve (o.имя, оокл=o.оклад, иоклад = t.оклад)
* where o.оклад > t.оклад
* and t.name = "Алексеев, Игорь"
* \\g
*Executing . . .


.L+
!имя                 !оокл  !иоклад!
!----------------------------------!
| Соболев, М.И.      | 462  |  352 |
!----------------------------------!
.L-

Continue
*

.fi
Если мы хотим, чтобы Игорь Алексеев получал
на 50 рублей больше, чем
кто бы то ни был, мы должны сделать запрос:
.nf

* replace o(оклад = max(o.оклад) + 50)
* where o.имя = "Алексеев, Игорь"
* \\g
Executing . . .


Continue
*

.fi
Наконец, чтобы разрушить отношение,
владельцем которого Вы являетесь,
напечатайте команду:
.nf

* destroy начальство
* \\g
Executing . . .


Continue
*

.fi
Теперь можно и закончить работу в \*(RU.
Это можно сделать, набрав символ
"CNTRL-D"  или командой "\\q":
.nf

* \\q

СУБД \*(RU,  конец работы
Пят ноя 14 16:27:53 1986
До свидания, \*(rN
приходите еще.
.fi
.ne 10


  ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ ОБ ИСПОЛЬЗОВАНИИ \*(RU


На самом деле \*(RU значительно больше, чем описано в
приведенных выше примерах. Если вы собираетесь создавать и сопровождать
базы данных, вам совершенно необходимо изучить документ "Создание и
поддержка базы данных с использованием \*(RU" - в нем описана вся
"подводная" часть СУБД, которая не нужна начинающему пользователю для
общения с уже существующей базой, но необходима администратору баз данных.
Кроме того, вам очень скоро будет не хватать описанных выше
возможностей. Для того, чтобы готовить отчеты сложной формы,
организовывать диалог с пользователем, обрабатывать данные
из базы используется язык EQUEL - расширение языка Си для
взаимодействия с СУБД \*(RU. Подробное описание языка EQUEL
имеется в справочном руководстве, а здесь приведем простой пример
программы на языке EQUEL и прокомментируем его:
.nf

  #include <stdio.h>
  ## char pname[21];
  ## char col[9];
  main(argc, argv)
  int     argc;
  char    *argv[];

  {
  ##      \*(rN "-i210" demo
  ##      print части
  ##      range of p is части     /*
  ##      retrieve (pname = p.#пимя)
  ##      {
		  printf("%s\n", pname);
  ##      }
  ##   exit
  }

.fi
Как можно заметить, операторы QUEL просто записываются в программе на
языке Си, используя символы ## в качестве признака оператора EQUEL.
При этом Си переменные могут использоваться для формирования значений,
имен, условия поиска. В операторе RETRIEVE происходит передача
найденных значений в переменные языка Си.

Полный текст примера с комментариями можно найти в справочнике
"doc/Examples" (считая от корневого справочника \*(Ru), все
примеры на EQUEL кончаются суффиксом .q\ . На самом деле язык EQUEL
содержит ряд расширений по отношению к QUEL, связанных с
взаимодействием СУБД и программы на Си; все они описаны в
справочном руководстве по \*(RU.

В ряде простых применений можно обойтись без EQUEL, воспользовавшись
возможностями встроенного в QUEL макроязыка. Так, для того, чтобы
вводить новые данные в отношение "части", можно написать такое
задание для QUEL (оно записывается в отдельный файл, например, "newp.mac"):

.nf

 \er
 {type Вводим новую часть. }
 retrieve (макс_номер=max(части.номер))
 \eg\er
 \emark start
 append to части
 (номер={read Номер? },
 имя="{read Имя? }",
 цвет="{read Цвет? }",
 вес= {read Вес? },
 колич={read Колич? })
 \ev\ea
 \ebranch ?{read ЕЩЕ (1 - да, 0 - нет)? }=1 start
 {type Проверьте результат и введите команду \e\e g}
 \ev\ea
 \ee

.fi

Этот пример записан в справочнике "demo" под именем "newp.mac".
Для ввода новых данных в отношение "части" остается только набрать:

 \ei demo/newp.mac

(если, конечно, вы находитесь в корневом справочнике \*(RU), и ввести
требуемую информацию. Подробное описание макро можно найти в разделе
MACRO(QUEL) справочного руководства, а примеры сложных заданий на макро -
в справочнике doc/Examples/ (суффикс *.mac); здесь заметим только, что в
данном примере после ввода информации перед ее записью в базу пользователю
дается возможность отредактировать ее редактором "red".

Еще одним средством, облегчающим работу с \*(RU, является система
управления экраном и экранными формами "DIXY" (разработка АЗЛК, Москва).
Она не входит в комплект поставки \*(RU, но в него включен
демонстрационный пример программы на DIXY: перейдите в справочник "demodixy"
и вызовите программу "pred":

 cd ~\*(rN/demodixy
 pred demo

Теперь вы получили начальные знания о системе \*(RU и
можете начинать с ней работать.
