
            дддд   ееееее   м     м    oooo     сссс
           д   д   е        мм   мм   o    o   с    с
          д    д   е        м м м м   o    o   с    с
          д    д   еееее    м  м  м   o    o   с
          д    д   е        м     м   o    o   с
          д    д   е        м     м   o    o   с    с
         дддддддд  ееееее   м     м    oooo     сссс



          демосдемосдемосдемосдемосдемосдемосдемосде
          емосдемосдемосдемосдемосдемосдемосдемосдем
          мо                                      мо
          ос                                      ос
          сд        ОПЕРАЦИОННАЯ СИСТЕМА          сд
          де                                      де
          ем               ДЕМОС                  ем
          мо                                      мо
          ос                                      ос
          сд                                      сд
          де             Версия 1.0               де
          ем                                      ем
          мо                                      мо
          сдемосдемосдемосдемосдемосдемосдемосдемосд
          демосдемосдемосдемосдемосдемосдемосдемосде







                  ОПИСАНИЕ ЯЗЫКА АССЕМБЛЕР







                 Усиков Сергей Анатольевич












                       МОСКВА - 1985









                                                           1







   В данном документе описывается язык AS операционной  сис-
темы ДЕМОС.

























































2




                        1. ВВЕДЕНИЕ


   Язык AS представляет  собой  ассемблер  без  возможностей
макрорасширения.  Он  используется  при  создании  выходного
файла, содержащего словарь перемещений и полную таблицу сим-
волов.  Таким  образом,  выходной  файл является стандартным
файлом ввода для программы редактирования  связей.  Выходной
формат  ассемблера  спроектирован  таким  образом,  что если
программа не содержит неразрешенных внешних ссылок,  то  она
может быть выполнена без дополнительной обработки редактором
связей.




                    2. ВЫЗОВ КОМПИЛЯТОРА


Формат вызова компилятора AS:

                as [-u] [-o output] file ...

Если указан ключ "-u", то все неопределенные символы  в  ас-
семблируемой программе будут считаться неопределенными внеш-
ними символами.

   Остальные параметры указывают файлы, которые об'единяются
и ассемблируются. Таким образом, программа может состоять из
нескольких частей, ассемблируемых вместе.

   Результат работы ассемблера  по  умолчанию  помещается  в
файл  "a.out"  в  текущем каталоге. Ключ "-o" указывает, что
результат следует поместить в названный файл. Если  нет  не-
разрешенных  внешних ссылок и не было обнаружено ошибок, вы-
ходной файл помечается как выполняемый; иначе, если он вооб-
ще  создается, он помечается как файл, который нельзя выпол-
нить.




                         3. ЛЕКСЕМЫ


   Лексемы ассемблера включают в себя идентификаторы (иногда
называемые  "символами"  или  "именами"), временные символы,
константы и операции.


   3.1. Идентификаторы


   Идентификатор - это  последовательность  из  букв,  цифр,
точки,  знака  подчеркивания  и  тильды,  не  начинающаяся с
цифры. Значимыми являются  только  первые  восемь  символов.
Если идентификатор начинается с тильды, то при его обработке
компилятором ассемблера эта тильда отбрасывается, а в табли-
це  символов  появляется уникальная запись, не совпадающая с


                                                           3

записями, порожденными другими вхождениями этого идентифика-
тора.  Эта особенность используется компилятором Си, который
помещает имена локальных переменных в выходную таблицу  сим-
волов, не делая их уникальными.


   3.2. Временные символы


   "Временным символом" называют цифру, за  которой  следует
одна  из  букв:  "f"  или  "b".  Подробно  временные символы
рассматриваются в разделе 8.1.


   3.3. Константы


   Восьмеричная константа  -  это  последовательность  цифр.
Цифры  "8" и "9" используются для представления восьмеричных
значений 10 и  11.  Константа  укорачивается  до  16  бит  и
рассматривается как двоичное число в дополнительном коде.

   Десятичная константа - это последовательность  цифр,  за-
канчивающаяся  десятичной  точкой ".". Ее величина не должна
быть более, чем 32768.

   Однолитерная константа состоит из одиночной  кавычки,  за
которой  следует любой символ КОИ-8, за исключением перевода
строки. Кроме того, в однолитерных константах допустимы  не-
которые двухсимвольные ESC-последовательности, к которым от-
носятся знак табуляции, символ новой строки и другие не име-
ющие графического изображения символы (см. раздел 8.5). Зна-
чением константы является код данного символа, помещенный  в
младший байт слова и дополненный нулями слева.

   Двухлитерная константа состоит из двойной кавычки, за ко-
торой  следует пара любых знаков КОИ-8, кроме перевода стро-
ки. Вместо каждого из знаков допускается употреблять некото-
рые ESC-последовательности, к которым относится символ новнй
строки и другие символы, не имеющие  графического  изображе-
ния.  Значением  константы  является  код  первого символа в
младшем байте слова и код второго - в старшем байте слова.


   3.4. Операции


   В ассемблере существует несколько однолитерных и  двухли-
терных операций. Подробно они рассмотрены в разделе 9.1.




                         4. ПРОБЕЛЫ


   Пробелы и знаки табуляции могут быть  свободно  вставлены
между  лексемами, но не должны использоваться внутри лексем;
исключение составляют литерные константы. Пробелы или  знаки
табуляции  необходимы  в  тех  случаях, когда нужно отделить
друг от друга стоящие рядом идентификаторы или константы.



4




                       5. КОММЕНТАРИИ


   Знак "/" указывает, что за ним следует комментарий,  про-
должающийся до конца строки, в которой этот знак встретился.
Комментарии игнорируются ассемблером.




                        6. СЕГМЕНТЫ


   Ассемблируемые коды и данные распределяются по трем  сег-
ментам:  текстовый  сегмент,  сегмент  данных и сегмент bss.
Ассемблерная программа начинается с текстового  сегмента,  в
который обычно помещаются выполняемые команды. Система ДЕМОС
может, если надо, обеспечить целостность текстового  сегмен-
та,  вылавливая  все  операции,  производящие  запись внутрь
него. Чтобы текстовый сегмент был таким образом  защищен  от
записи, выданные ассемблером об'ектные программы должны быть
обработаны редактором связей ld с использованием  его  ключа
"-n".  Все  процессы  выполнения  одной  программы разделяют
единственную копию текстового сегмента.

   Сегмент данных доступен для размещения в нем  данных  или
команд, изменяющихся во время выполнения программы. Все, что
может быть помещено в текстовый сегмент, можно помещать и  в
сегмент  данных.  В  программах с разделяемым, защищенным от
записи текстовым сегментом, сегмент данных  содержит  иници-
ализированные, но изменяемые части программы. Если текстовый
сегмент не защищен, сегмент данных следует за ним; если  за-
щищен, сегмент данных начинается с ближайшей после его конца
границы 8К байтов.

   Сегмент bss не может содержать никаких явно инициализиро-
ванных  команд  или  данных.  Длина сегмента bss, так же как
текстового сегмента и сегмента данных, определяется маркером
максимального  значения  счетчика адреса внутри его. Сегмент
bss на самом деле - расширение сегмента данных и  начинается
сразу  после него. В начале выполнения программы сегмент bss
устанавливается в 0. Обычно сегмент bss создается оператора-
ми, примером которых может служить:

                         lab:.=.+10

Выгода от использования сегмента bss для участков памяти, не
нуждающихся  в  инициализации, состоит в том, что в выходной
файл нет необходимости помещать информацию  о  их  начальных
значениях.




                     7. СЧЕТЧИК АДРЕСА


   Специальный символ ".", используется как счетчик  адреса.
Его  величина  в  любой  момент  равна смещению внутри соот-


                                                           5

ветствующего сегмента начала того оператора,  в  котором  он
появился.  Ему  можно  присваивать значения при условии, что
текущий сегмент не может измениться на другой.  Кроме  того,
значение  "."  не  может  быть  уменьшено. Если в результате
присвоения значение счетчика адреса увеличивается, то созда-
ется необходимое число нулевых байтов.




                    8. ОПЕРАТОРЫ И МЕТКИ


   Исходная программа состоит из последовательности операто-
ров.  Операторы  разделяются переводами строки или точками с
запятой. Операторы  бывают  пяти  видов:  пустые  операторы,
операторы-выражения,   операторы   присваивания,  операторы-
строки и операторы с ключевыми словами.

   Перед оператором любого вида может стоять одна  или  нес-
колько меток.


   8.1. Метки


   Есть два  вида  меток:  метки-идентификаторы  и  цифровые
метки.  Метка-идентификатор  -  это  имя, за которым следует
двоеточие. В  результате  употребления  метки-идентификатора
этому  имени  присваиваются  текущие тип и значение счетчика
адреса. Если это имя уже определено, то первый проход фикси-
рует  ошибку. Если присвоенное значение "." изменяет опреде-
ление метки, то при втором проходе будет зафиксирована ошиб-
ка.

   Цифровая метка - это цифра от 0 до 9, за которой  следует
двоеточие. Такие метки служат для определения временных сим-
волов вида "nb" и "nf" , где n-цифра метки. Как и  в  случае
меток-идентификаторов  цифровые  метки вызывают присваивание
текущих типа и значения счетчика адреса "." временному  сим-
волу. Однако в одной и той же программе могут появиться нес-
колько цифровых меток с одной и той же цифрой.  Ссылки  вида
"nf"  указывают на ближайшую цифровую метку "n:" после места
ссылки. Ссылка вида "nb" указывает на ближайшую  метку  "n:"
перед  местом ссылки. Они предназначены для экономии места в
таблице символов ассемблера.


   8.2. Пустые операторы


   Пустые операторы не содержат ничего, кроме предшествующих
им меток. Обычными примерами пустых операторов служат пустые
строки или строки, содержащие только метку. Ассемблер  игно-
рирует пустые операторы.


   8.3. Операторы-выражения


   Операторы-выражения - это арифметические выражения, перед
которыми нет ключевого слова. Ассемблер вычисляет 16-битовое


6

значение выражения и помещает его в выходной поток вместе  с
соответствующими битами смещения.


   8.4. Операторы присваивания


   Оператор присваивания состоит  из  идентификатора,  знака
равенства и выражения. Значение и тип выражения присваивают-
ся идентификатору. При этом не требуется, чтобы тип или зна-
чение  при  втором  проходе  были  бы  такими  же, как и при
первом. Переопределение любого символа посредством оператора
присваивания не является ошибкой.

   При присваивании любой внешний атрибут выражения  теряет-
ся.  Это  означает,  что  невозможно  определить  глобальный
символ посредством присваивания к нему и невозможно  опреде-
лить  символ  как  смещение от нелокально определенного гло-
бального символа.

   Допускается присваивание счетчику адреса. При этом, одна-
ко, требуется, чтобы тип присваиваемого выражения и "." сов-
падали. Запрещается уменьшать значение ".". На практике  на-
иболее  распространенное  присваивание  к  "."  имеет  форму
".=.+n", где n - некоторое число. результатом такого присва-
ивания является генерация n нулевых байтов.


   8.5. Операторы-строки


   Оператор-строка генерирует последовательность байтов, со-
держащих  символы  в  коде КОИ-8. Оператор-строка состоит из
левой  строчной  кавычки  "<",  последовательности  символов
КОИ-8,  которая  не  включает символа новой строки, и правой
строчной кавычки ">". Любой из символов КОИ-8 может быть за-
менен  двухсимвольной  ESC-последовательностью, служащей для
представления некоторых неграфических символов, так, как это
показано ниже:

      \n nl  (012)
      \s sp  (040)
      \t ht  (011)
      \e eot (004)
      \o nul (000)
      \r cr  (015)
      \a ack (006)
      \р pfx (033)
      \\ \
      \> >

Последние две последовательности включены  для  того,  чтобы
можно  было представить сам ESC-символ и правую строчную ка-
вычку. ESC-последовательности можно также использовать в од-
носимвольных и двухсимвольных константах.


   8.6. Операторы с ключевыми словами


   В  численном  отношении  операторы  с  ключевыми  словами
представляют  собой наиболее распространенный тип, поскольку


                                                           7

большинство машинных команд имеют именно такую форму. Опера-
тор  с ключевым словом начинается с одного из многих заранее
определенных ключевых слов ассемблера.  Синтаксис  остальной
части оператора определяется этим ключевым словом.




                        9. ВЫРАЖЕНИЯ


   Выражение - это последовательность символов,  представля-
ющих  значение.  Оно  строится из идентификаторов, констант,
временных символов, знаков операций и скобок. Каждое выраже-
ние имеет тип.

   Все операции в выражениях по своей природе  являются  би-
нарными: если левый операнд отсутствует, то предполагается 0
абсолютного типа. Используется арифметика  в  дополнительном
коде  с  16  битами  точности. Все операции имеют одинаковое
старшинство и выражения вычисляются строго слева направо  за
исключением эффекта, определяемого наличием скобок.


   9.1. Операции в выражениях


В выражениях употребляются следующие операции:

(пробел)
     если между операндами нет знака операции, это то же са-
     мое, что и появление знака "+";

+    сложение;

-    вычитание;

*    умножение;

\/   деление;

&    побитовое "и";

|    побитовое "или";

\>   логический сдвиг вправо;

\<   логический сдвиг влево;

%    деление нацело;

!    a!b Значит (a или (не b)), то есть операция "или" между
     первым  операндом  и дополнением ко второму. Чаще всего
     используется как унарная операция;

^    результат получает значение первого операнда и тип вто-
     рого. Чаще всего используется для определения новых ма-
     шинных команд с синтаксисом, идентичным синтаксису  су-
     ществующих команд.

   Выражения могут группироваться с помощью квадратных  ско-
бок.  Круглые  скобки  зарезервированы для обозначения типов


8

адресации.


   9.2. Типы выражений


   Ассемблер имеет дело с некоторым количеством типов  выра-
жений. Большая часть типов связана с ключевыми словами и ис-
пользуется для выбора подпрограммы, обрабатывающей это  клю-
чевое слово. В явном виде могут встретиться типы:

неопределенный
   - при первом появлении каждый символ  является  неопреде-
     ленным.  Символ  может  стать  неопределенным, если ему
     присваивается значение неопределенного  выражения.  При
     втором  проходе  попытка  ассемблировать неопределенное
     выражение вызовет ошибку, при первом - нет (за исключе-
     нием  того, что некоторые ключевые слова требуют, чтобы
     операнды не являлись неопределенными);

неопределенный внешний
   - символ, об'явленный как ".globl",  но  не  определенный
     при текущем ассемблировании, получает тип "неопределен-
     ный внешний". Если в программе есть  такой  символ,  то
     перед  загрузкой выход ассемблера должен быть об'единен
     с другим модулем, содержащим определение этого символа,
     с помощью редактора связей ld;

абсолютный
   - абсолютные символы в конечном счете определяются  через
     константы. На их значение не влияют никакие последующие
     применения редактора связей к результату  ассемблирова-
     ния;

текстовый
   - значения символов текстового типа соотносятся с началь-
     ным адресом текстового сегмента программы. Если резуль-
     тат ассемблирования  компонуется  с  другими  модулями,
     значения его символов текстового типа могут измениться,
     так как этот модуль не обязательно будет первым  в  вы-
     ходном  файле  редактора  связей.  Большинство символов
     текстового типа получают значения, когда  появляются  в
     качестве  меток.  В начале ассемблирования значение "."
     есть текстовый 0;

данные
   - величина символа типа данных соотносится с началом сег-
     мента  данных программы. Как и символы текстового типа,
     символы типа данных могут поменять  значение  во  время
     последующего применения редактора связей, так как поме-
     щаемые в память раньше программы  могут  иметь  сегмент
     данных. После появления первого оператора

             .data величина

     значение "." равно 0, а тип - данные;

bss
   - величина символа типа bss отсчитывается от начала  сег-
     мента  bss программы. Величина символов типа bss, как и
     символов текстового типа и типа данных, может изменить-
     ся при последующем применении редактора связей, так как


                                                           9

     программы, помещенные в память раньше, могут иметь сег-
     менты bss. После первого оператора

             .bss

     значение "." равно 0, а тип - bss;

внешние абсолютный, текстовый, данных или bss
   - символы, об'явленные как ".globl", но получившие значе-
     ние  при  ассемблировании как символы абсолютного типа,
     текстового типа, типа данных или типа bss,  могут  быть
     использованы  точно  так  же,  как  если бы они не были
     об'явлены как ".globl". Однако их тип и  значение  дос-
     тупны  редактору  связей,  так что программа может быть
     загружена вместе с другими программами, в  которых  со-
     держатся ссылки на эти символы;

регистровый
   - символы r0,...,r5, fr0,...,fr5, sp, pc определены зара-
     нее  как символы регистров. Они или символы, определен-
     ные через них, используются для обращения к  шести  ре-
     гистрам  общего назначения, шести регистрам с плавающей
     точкой  и  двум  регистрам   специального   назначения.
     Использование  имен  регистров  с плавающей точкой пол-
     ностью идентично использованию  имен  регистров  общего
     назначения. Они предусмотрены для целей мнемоники;

прочие типы
   - каждое из ключевых слов,  известных  ассемблеру,  имеет
     свой тип, который используется для выбора подпрограммы,
     обрабатывающей оператор с соответствующим ключевым сло-
     вом.  Если  те  же символы используются не как ключевые
     слова, то они рассматриваются ассемблером как  абсолют-
     ные.


   9.3. Присваивание типов при вычислении выражений


   Если операнды об'единены знаком операции в выражение, ре-
зультат  имеет тип, зависящий от типов операндов и от опера-
ции. С точки зрения вычисления  выражений  важными  являются
типы:

        неопределенный;
        абсолютный;
        текстовый;
        данных;
        неопределенный внешний;
        прочие.

Если один из операндов неопределен,  результат  неопределен-
ный.  Если  оба  операнда  абсолютные, результат абсолютный.
Если абсолютный тип сочетается с одним  из  "прочих"  типов,
упоминающихся выше, или с регистровым типом, результат будет
иметь "прочий" или регистровый  тип.  Как  следствие,  можно
ссылаться на r3 как на "r0+3". Если сочетаются операнды двух
"прочих" типов, результат будет иметь тип с большим номером.
"Прочий  " тип в сочетании с явно упомянутыми в списке типа-
ми, за исключением абсолютного, действует как абсолютный.




10

   Правила применения конкретных операций таковы:

+    если один операнд имеет текстовый, данных, bss или  не-
     определенный  внешний тип, результат будет иметь тот же
     тип, а второй операнд должен быть абсолютным;

-    если первый операнд -  переместимый  символ  текстового
     сегмента,  сегмента  данных или сегмента bss, то второй
     операнд должен быть либо абсолютным (при этом результат
     будет  иметь  тип  первого операнда), либо иметь тот же
     тип, что и первый (при этом результат будет абсолютного
     типа). Остальные сочетания типов запрещены;

^    эта операция подчиняется только одному правилу, а имен-
     но:  результат получает значение первого операнда и тип
     второго;

прочие операции
     запрещено применять  эти  операции  к  операндам  любых
     типов, кроме абсолютных.




                     10. ПСЕВДООПЕРАЦИИ


   Перечисленные ниже ключевые слова вводят операторы, кото-
рые либо оперируют данные необычного формата, либо управляют
дальнейшими действиями ассемблера. Метаобозначение:

                        [что-то]...

Свидетельствует, что в указанном месте  "что-то"  может  по-
явиться ноль или более раз.

               .byte Выражение [,выражение]...

Значения выражений из разделенного запятыми списка усекаются
до  8 бит и размещаются в последовательных байтах. Этот опе-
ратор и оператор-строка, упомянутый выше, единственные,  ас-
семблирующие данные побайтно.

                            .even

Если счетчик адреса "." имеет нечетное значение, он увеличи-
вается  на  единицу,  так  что  следующий оператор будет ас-
семблироваться, начиная с границы слова.

                        .if Выражение

Выражение должно быть абсолютным  и  получить  значение  при
первом  проходе. Если это значение отлично от нуля, оператор
игнорируется. Если оно равно нулю, то операторы, заключенные
между  if  и  соответствующим ему ".endif" игнорируются. Эти
условные операторы могут быть вложенными. Действие условного
оператора  не  распространяется  за  пределы  того  входного
файла, в котором он встретился.

   Операторы игнорируются не полностью: они  просматриваются
и  все  встречающиеся в них имена заносятся в таблицу симво-
лов. Таким образом, имена, встречающиеся только  внутри  ус-


                                                          11

ловного  оператора,  будут появляться в таблице символов при
ее распечатке как неопределенные.

                           .endif

Этот оператор отмечает конец условно ассемблируемого участка
программы.

                    .globl имя [,имя] ...

Этот оператор об'являет упомянутые  в  нем  имена  внешними.
Если  они  в  то же время определены оператором присваивания
или как метки, то внутри программы  они  обрабатываются  ас-
семблером  точно  так  же, как если бы оператора ".globl" не
было. Однако редактор связей ld может соединить эту програм-
му с другими, ссылающимися на эти символы.

   И наоборот, если эти символы не определены в  ассемблиру-
емой  программе,  редактор связей может об'единить результат
текущего ассемблирования с модулями, в которых  определяются
значения данных символов. Есть возможность об'явить все сим-
волы, каким-либо образом оказавшиеся неопределенными,  внеш-
ними.

        .text
        .data
        .bss

Эти три псевдооперации заставляют  ассемблер  помещать  свои
результаты  в  текстовый  раздел, раздел данных или в раздел
bss соответственно. Ассемблирование начинается с  текстового
сегмента.  Запрещено  помещать  какие-либо коды или данные в
раздел bss, но в нем можно  определять  символы  и  сдвигать
счетчик адреса "." посредством присваивания.

        .comm имя, выражение

При условии, что указанное имя не  определено  где-нибудь  в
другом месте, этот оператор эквивалентен следующим:

        .globl имя

        имя = выражение ^ имя

то есть имя получает тип "неопределенное внешнее" и значение
выражения.  На  самом  деле  при текущем ассемблировании имя
ведет себя как неопределенное внешнее, однако редактор  свя-
зей  ld  рассматривает  такой случай как особый, так что все
внешние символы, не определенные никаким другим  способом  и
имеющие  ненулевое  значение,  помещаются в сегмент bss, где
оставляется  достаточное  для  размещения  выражения   число
байтов. Все символы, определенные таким способом, размешают-
ся раньше всех других ячеек сегмента bss.




                    11. МАШИННЫЕ КОМАНДЫ


   Из-за довольно сложной структуры команд и типов адресации
СМ-4,  синтаксис  операторов,  порождающих машинные команды,


12

весьма разнообразен.


   11.1. Адреса исходных данных и результатов  выполнения
         команд


   Синтаксисадресов исходных данных и результатов выполнения
команд  одинаков.  Каждый из них должен иметь одну из следу-
ющих форм, где reg - символ регистра, а  expr  -  какое-либо
выражение.

        Синтаксис   к-во   режим
                    слов   адресации
        reg          0     00+reg
        (reg)+       0     20+reg
        -(reg)       0     40+reg
        expr(reg)    1     60+reg
        (reg)        0     10+reg
        *reg         0     10+reg
        *(reg)+      0     30+reg
        *-(reg)      0     50+reg
        *(reg)       1     70+reg
        *expr(reg)   1     70+reg
        expr         1     67
        $expr        1     27
        *expr        1     77
        *$expr       1     37

колонка "к-во слов" содержит количество порождаемых адресных
слов.  Колонка  "режим  адресации" содержит восьмеричный код
режима адресации. Обратите внимание: режим "*reg" эквивален-
тен "(reg)"; "*(reg)" порождает индексирующее слово, а имен-
но 0; адреса, состоящие  только  из  одного  выражения,  ас-
семблируются  как ссылки относительно счетчика команд рс не-
зависимо от типа выражения. Для того, чтобы  сделать  ссылку
абсолютной,  используется форма "*$ expr", однако дальнейшая
косвенная адресация невозможна.


   11.2. Простые машинные команды


   Следующие команды определяются как абсолютные символы:

        clc    sec
        clv    sen
        clz    sev
        cln    sez

и, таким образом, не требуют никакого специального синтакси-
са.  Аппаратные  средства СМ-4 позволяют об'единять вместе с
помощью операции "или" несколько  команд  класса  "очистить"
или несколько команд класса "установить". Это может быть вы-
ражено следующим образом:

                          clc|clv







                                                          13

   11.3. Переходы


   Команды перехода в качестве операнда принимают выражение.
Оно  должно  находиться  в  том же сегменте, что и ссылки на
него. Оно не может быть неопределенным внешним и его  значе-
ние  не  может более чем на 254 байта отличаться от текущего
положения счетчика адреса.

        br      blos
        bne     bvc
        beg     bvs
        bge     bhis
        blt     bec   (=bcc)
        bgt     bcc
        ble     blo
        bpl     bcs
        bmi     bes   (=bcs)
        bhi

Команды bes ("переход при ошибке") и bec ("переход  при  от-
сутствии  ошибки")  предназначены  для проверки бита ошибки,
возвращаемого после обращения к системе, то  есть  на  самом
деле бита с.


   11.4. Расширенные команды перехода


   За  следующими  символами  должно  следовать   выражение,
представляющее адрес из того же сегмента, в котором находит-
ся ".". Если адрес перехода достаточно  близок,  порождается
команда типа branch, если адрес слишком далеко, используется
команда jmp:

        jbr     jlos
        jne     jvc
        jeg     jvs
        jge     jhis
        jlt     jec
        jgt     jcc
        jle     jlo
        jpl     jcs
        jmi     jes
        jhi



   11.5. Команды с одним операндом


   Следующие символы -  это  имена  однооперандных  машинных
команд:

clr, clrb, com, comb, inc, incb, dec, decb, neg, negb,  adc,
adcb, sbc, sbcb, ror, rorb, rol, rolb, asr, asrb, asl, aslb,
jmp, swab, tst, tstb.







14

   11.6. Команды с двумя операндами


   Следующие команды принимают в качестве  операндов  адреса
исходного  данного и результата общего вида, разделенные за-
пятой:

mov, movb, cmp, cmpb, bit, bitb, bic, bicb, bis, bisb,  add,
sub.


   11.7. Разные команды


   Синтаксис следующих команд более специальный.  Здесь  reg
обозначает имя регистра, src и dst - адреса исходного данно-
го и результата общего вида, а expr - выражение:

        jsr  reg, dst
        rts  reg
        sys  expr
        ash  src, reg (=als)
        ashc src, reg (=alsc)
        mul  src, reg (=mpy)
        div  src, reg (=dvd)
        xor  reg, dst
        sxt  dst
        mark expr
        sob  reg, expr

Sys - это другое имя для команды trap. Оно используется  при
кодировани обращений к системе. Значение его операнда должно
помещаться в 6 битов. Выражение в команде mark должно  поме-
щаться  в 6 битов, а в команде sob - быть из того же сегмен-
та, что и ".", не должно быть внешним неопределенным, должно
быть  меньше  "." и находиться не далее, чем в 510 байтах от
".".


   11.8. Команды процессора с плавающей точкой


   Определяются следующие команды с плавающей  точкой,  име-
ющие такой синтаксис:

        cfce
        setf
        setd
        seti
        setl
        clrf  fdst
        ncgf  fdst
        absf  fdst
        tstf  fsrc
        movf  fsrc, freg  (=ldf)
        movf  freg, fdst  (=stf)
        movif src,  freg  (=ldcif)
        movfi freg, dst   (=stcfi)
        movof fsrc, freg  (=ldcdf)
        movfo freg, fdstr (=stcfd)
        movie src,  freg  (=ldexp)
        movei freg, dst   (=stexp)


                                                          15

        addf  fsrc, freg
        subf  fsrc, freg
        mulf  fsrc, freg
        divi  fsrc, freg
        cmpf  fsrc, freg
        modf  fsrc, freg
        ldfps src
        stfps dst
        stst  dst

fsre, fdst и freg обозначают адрес  исходного  данного,  ре-
зультата  и  регистр  с  плавающей точкой соответственно. Их
синтаксис идентичен синтаксису соответствующих  элементов  с
фиксированной  точкой, однако следует обратить внимание, что
freg может быть лишь плавающим регистром с номером от  0  до
3.

   Имена некоторых операций изменены для того, чтобы достичь
аналогии   с  соответствующими  операциями  с  фиксированной
точкой. Единственно необычной является команда movf, которая
превращается  либо  в stf, либо в ldf в зависимости от того,
является ли первый операнд регистром. Надо заметить, что ldf
устанавливает  признаки  условий  для  операций  с плавающей
точкой, а stf - нет.




                     12. СИМВОЛ ''..''


   Символ ".." - это счетчик  перемещения.  Перед  тем,  как
каждое  порожденное  ассемблером  слово  попадает в выходной
поток, текущее значение этого символа прибавляется  к  нему,
если  это  слово  ссылается  на ячейку в текстовом сегменте,
сегменте данных или сегменте bss. Если выходное слово  явля-
ется  адресуемым относительно счетчика команд рс словом, ко-
торое ссылается на абсолютную ячейку, то из него  вычитается
значение ".."

   Таким образом, значение ".." можно  считать  адресом  на-
чальной точки программы. Его начальное значение равно нулю.

   Значение символа ".." можно изменить с помощью присваива-
ния.  Такого  рода действия иногда необходимы. Однако риско-
ванно было бы менять значение ".."  посреди  ассемблируемого
модуля  или  поступать так с программой, которая потом будет
загружаться загрузчиком, имеющим  собственные  предположения
относительно "..".




                  13. ОБРАЩЕНИЯ К СИСТЕМЕ


   Имена операторов обращения к системе не являются  заранее
опрeделенными. Их можно найти в файле

                       /usr/include/sys.s




16




                      14. ДИАГНОСТИКА


   Если входной файл не может быть прочитан, его имя, за ко-
торым  следует  знак  вопроса,  выводится  и ассемблирование
прекращается. Если обнаружена синтаксическая или семантичес-
кая  ошибка,  печатается признак ошибки, состоящий из одного
знака, номер строки и имя входного файла, в котором встрети-
лась ошибка. Ошибки, обнаруженные на первом проходе, вызыва-
ют отмену второго прохода. Возможны следующие ошибки:

)  - неправильная расстановка скобок;

]  - неправильная расстановка скобок;

>  - строка неверно заканчивается;

*  - неправильное применение косвенной адресации;

.  - неверное присвоение значения символу ".";

a  - ошибка адресации;

b  - адрес перехода нечетен или слишком удален;

e  - ошибка в выражении;

f  - ошибка в локальном символе типа "f" или "в";

g  - неизвестный ассемблеру знак во входном потоке;

i  - посредине условного оператора встретился конец файла;

m  - неоднократно определенный символ в качестве метки;

o  - слово размещается по нечетному адресу;

p  - ошибка в фазе - значение "." различно на первом и  вто-
     ром проходе;

r  - ошибка перемещения;

u  - неопределенный символ;

x  - синтаксическая ошибка.
















                                                          17



                           СОДЕРЖАНИЕ



1.  ВВЕДЕНИЕ...........................................    3

2.  ВЫЗОВ КОМПИЛЯТОРА..................................    3

3.  ЛЕКСЕМЫ............................................    3
    3.1. Идентификаторы................................    3
    3.2. Временные символы.............................    4
    3.3. Константы.....................................    4
    3.4. Операции......................................    4

4.  ПРОБЕЛЫ............................................    4

5.  КОММЕНТАРИИ........................................    5

6.  СЕГМЕНТЫ...........................................    5

7.  СЧЕТЧИК АДРЕСА.....................................    5

8.  ОПЕРАТОРЫ И МЕТКИ..................................    6
    8.1. Метки.........................................    6
    8.2. Пустые операторы..............................    6
    8.3. Операторы-выражения...........................    6
    8.4. Операторы присваивания........................    7
    8.5. Операторы-строки..............................    7
    8.6. Операторы с ключевыми словами.................    7

9.  ВЫРАЖЕНИЯ..........................................    8
    9.1. Операции в выражениях.........................    8
    9.2. Типы выражений................................    9
    9.3. Присваивание типов при вычислении выражений...   10

10. ПСЕВДООПЕРАЦИИ.....................................   11

11. МАШИННЫЕ КОМАНДЫ...................................   12
    11.1.Адреса исходных данных и результатов  выполне-
         ния команд....................................   13
    11.2.Простые машинные команды......................   13
    11.3.Переходы......................................   14
    11.4.Расширенные команды перехода..................   14
    11.5.Команды с одним операндом.....................   14
    11.6.Команды с двумя операндами....................   15
    11.7.Разные команды................................   15
    11.8.Команды процессора с плавающей точкой.........   15

12. СИМВОЛ ''..''  ....................................   16

13. ОБРАЩЕНИЯ К СИСТЕМЕ................................   16

14. ДИАГНОСТИКА........................................   17









18

