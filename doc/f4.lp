
            дддд   ееееее   м     м    oooo     сссс
           д   д   е        мм   мм   o    o   с    с
          д    д   е        м м м м   o    o   с    с
          д    д   еееее    м  м  м   o    o   с
          д    д   е        м     м   o    o   с
          д    д   е        м     м   o    o   с    с
         дддддддд  ееееее   м     м    oooo     сссс



          демосдемосдемосдемосдемосдемосдемосдемосде
          емосдемосдемосдемосдемосдемосдемосдемосдем
          мо                                      мо
          ос                                      ос
          сд        ОПЕРАЦИОННАЯ СИСТЕМА          сд
          де                                      де
          ем               ДЕМОС                  ем
          мо                                      мо
          ос                                      ос
          сд                                      сд
          де             Версия 1.0               де
          ем                                      ем
          мо                                      мо
          сдемосдемосдемосдемосдемосдемосдемосдемосд
          демосдемосдемосдемосдемосдемосдемосдемосде







                  ОПИСАНИЕ ЯЗЫКА ФОРТРАН-4







                  Руднев Алексей Петрович












                       МОСКВА - 1985









                                                           1



   Данный документ содержит описание языка ФОРТРАН-4  опера-
ционной  системы  ДЕМОС. Описаны элементы языка, операторы и
структура программ на ФОРТРАНЕ, а также правила вызова  ком-
пилятора.



























































2




         1. ОБЩИЕ СВЕДЕНИЯ И СПОСОБ ОПИСАНИЯ ЯЗЫКА



   1.1. Компоненты программы на ФОРТРАНЕ


   Программа,написанная на языке ФОРТРАН-4 (в дальнейшем на-
зываемом  просто  ФОРТРАН), состоит из операторов ФОРТРАНА и
необязательных комментариев. Операторы об'единяются в  логи-
ческие  блоки, называемые программными модулями. Программный
модуль является последовательностью операторов, определяющей
некоторую  процедуру  вычисления. Эта последовательность за-
канчивается оператором "end". Программный модуль может  быть
или  основной  программой,  или  подпрограммой.  Выполняемая
программа состоит из одной основной программы и любого коли-
чества подпрограмм.


   1.1.1. Операторы


   Все операторы делятся на два класса: выполняемые и  невы-
полняемые  операторы. Невыполняемые операторы описывают раз-
мещение и характеристики данных, а также  содержат  информа-
цию, необходимую для редактирования и преобразования данных.

   Оператор состоит из одной или нескольких  строк.  Строкой
называется  последовательность символов до 72 знаков длиной.
Если размер оператора  превышает  допустимую  длину  строки,
оператор  может  быть  продолжен  на следующей строке или на
нескольких последующих строках, называемых строками  продол-
жения.  Строка  продолжения  идентифицируется символом "&" в
первой позиции строки.

   Оператор может иметь метку, по которой  другие  операторы
получат  возможность  обращаться к нему либо за информацией,
либо для передачи ему управления. Метка  оператора  является
целым числом, записанным с первой позиции первой строки опе-
ратора. Оператор без метки должен начинаться  с  одного  или
нескольких пробелов либо символов табуляции в начале строки.


   1.1.2. Комментарии


   Наличие комментария не влияет на выполнение программы; он
служит вспомогательной информацией для программиста. Коммен-
тарий используется для описания работы программы,  идентифи-
кации программных секций и процессов обработки, для удобства
чтения листинга программы на входном языке.

   Строчная буква "c" в первой позиции исходной строки  ука-
зывает, что эта строка является комментарием.







                                                           3




          2. ЭЛЕМЕНТЫ И ОСНОВНЫЕ КОНСТРУКЦИИ ЯЗЫКА



   2.1. Набор символов ФОРТРАН


   При записи программ на языке ФОРТРАН используются  следу-
ющие символы:

   - прописные буквы латинского алфавита от "a" до "z";

   - строчные буквы латинского алфавита от "A" до Z";

   - цифры от "0" до "9";

   - следующие специальные символы:

             пробел
    =        знак равенства
    +        плюс
    -        минус
    *        звездочка
    /        косая (дробная) черта
    (        открывающая скобка
    )        закрывающая скобка
    ,        запятая
    .        Десятичная точка
    '        апостроф
    "        кавычки

    В комментариях допускается использование любых  печатных
символов.


   2.1.1. Использование редактора текста


   Исходная программа может вводиться редактором  текстов  в
произвольномформате. Рекомендуется придерживаться следующего
правила:

   - метка  начинается с первой позиции и отделяется от опе-
     ратора символом табуляции;

   - оператору без метки предшествует символ табуляции;

   - символ "&" в первой позиции является признаком  продол-
     жения.

   Символ пробела может использоваться в операторе  ФОРТРАНА
для удобства чтения строки. Транслятор игнорирует все пробе-
лы в поле оператора за исключением пробелов внутри текстовых
констант  или  внутри  буквенно-цифровых  литералов.  Символ
"tab" в поле оператора воспринимается компилятором  так  же,
как и пробел.





4




                3. ЭЛЕМЕНТЫ ДАННЫХ ФОРТРАНА


   Основными элементами операторов ФОРТРАНА являются:

константа
   - представляет фиксированную величину, которая не меняет-
     ся в ходе выполнения программы;

переменная
   - символическое имя (идентификатор), представляющее неко-
     торую величину, хранящуюся в памяти;

массив
   - группа однотипных величин, расположенных в памяти  пос-
     ледовательно  друг  за другом; отдельные величины, сос-
     тавляющие массив, называются элементами массива;  можно
     обращаться  не  только  ко всему массиву, но и к любому
     его элементу;  для  обращения  к  массиву  используется
     идентификатор;

выражение
   - может быть простой  константой,  переменной,  элементом
     массива или обращением к функции; выражение также может
     быть комбинацией вышеперечисленных элементов и  элемен-
     тов, называемых операциями; операции определяют вид вы-
     числений, которые надо  выполнить  над  элементами  для
     того, чтобы получить значение выражения;

обращение к функции
   - идентификатор функции, за которым следует список  аргу-
     ментов  (параметров); появление в программе обращения к
     функции вызывает выполнение вычислений над  параметрами
     согласно определению функции.


   3.1. Идентификаторы


   Идентификатор - это последовательность латинских  букв  и
цифр,  начинающаяся обязательно с буквы. Идентификатор может
иметь любую длину, но символы после шестого игнорируются.

   Примеры правильных и неправильных идентификаторов:

 правильная  неправильная
 запись      запись
 number      5q    (начинается с цифры)
 k9          b.4   (содержит специальный
                    символ)

   В табл. 1 перечислены все об'екты,  которые  обозначаются
идентификаторами.  В пределах программной единицы один и тот
же идентификатор не может быть присвоен  более,  чем  одному
об'екту, за исключением специальных случаев.

   Внутри подпрограммы идентификаторы  могут  использоваться
также  в качестве формальных параметров. Формальный параметр
может  представлять  переменную,  массив,  элемент  массива,


                                                           5

константу, выражение или подпрограмму.

                                                  Таблица 1.

               Классификация идентификаторов

 +----------------------------------------+
 |                    !нали-!  количество |
 |        об'ект      !чие  !  об'ектов в |
 |                    !типа !  программе  |
 |--------------------!-----!-------------|
 |переменная          !имеет!  несколько  |
 |массив              !имеет!  несколько  |
 |библиотечная функция!имеет!       1     |
 |подпрограмма        ! нет !       1     |
 |общий блок          ! нет !       1     |
 |основная программа  ! нет !       1     |
 |блок данных         ! нет !       1     |
 +----------------------------------------+


   3.2. Типы данных


   Каждый основной элемент  представляет  данные  одного  из
нескольких  различных типов. Тип данных элемента может опре-
деляться самой конструкцией элемента,  может  задаваться  по
умолчанию, либо может быть задан явным образом.

   Типы данных, допустимые в ФОРТРАНЕ, следующие:

целый
   - целое число;

вещественный
   - число с десятичной точкой; это может быть целое  число,
     десятичная дробь или комбинация этих значений;

двойной точности
   - аналогично  вещественным,  но  с  повышенной  точностью
     представления числа;

комплексный
   - пара   вещественных   величин,   которая   представляет
     комплексное  число. Первая из этих величин представляет
     действительную часть комплексного  числа,  а  вторая  -
     мнимую часть;

логический
   - данное, принимающее логическое  значение  "истина"  или
     "ложь".

   Важной характеристикой каждого типа данных является об'ем
памяти, требующийся для хранения величины этого типа. Разли-
чия  внутри  основных  типов  выражаются  либо  в   точности
представления  величины,  либо в допустимом диапазоне значе-
ний.

   Текстовые константы и буквенно-цифровые литералы не имеют
типа  данных. Они принимают тип данных в зависимости от того
контекста, в котором они встречаются.



6

   Единица  памяти  -  это  об'ем  памяти,  необходимый  для
представления  вещественной,  целой или логической величины.
Величины с двойной точностью и комплексные величины занимают
две  единицы  памяти.  В языке ФОРТРАН  единица памяти соот-
ветствует четырем байтам (двум словам) памяти.

   Для более оптимального использования  памяти  допускается
использование дополнительных типов данных. Распределение па-
мяти по типам данных следующее:

 integer*2

   - занимает 2  байта памяти, диапазон значений  от  -32768
     до 32767;

 integer*1

   - занимает 1 байт памяти, диапазон значений  от  -127  до
     +127;

 integer

   - занимает 4 байта памяти, значения от -2**31 до 2**31-1;

 real

   - отводится 4 байта памяти; 8 значащих цифр;

 real*8
 double precision

   - занимает 8 байтов памяти; 16 значащих цифр;

 complex

   - отводится 8 байтов памяти;

 logical

   - отводится 2 байта памяти;

 logical*1

   - отводится 1 байт памяти.


   3.3. Константы


   Константа представляет неизменяемую величину: логическую,
числовое значение или последовательность символов.


   3.3.1. Целые константы


   Целая константа - это число, которое не имеет  десятичной
точки.  Константе  может  предшествовать  знак  числа. Целая
константа интерпретируется как десятичное число и имеет сле-
дующий вид:




                                                           7

         snn

 где

s  - знак числа;

nn
   - последовательность десятичных цифр.

   Левые незначащие нули (если они есть) игнорируются.

   Отрицательной целой константе должен предшествовать  знак
"минус";  знак "плюс" является необязательным символом. Если
константа не имеет знака, она считается положительной.

   В целую константу не должны входить никакие символы, кро-
ме цифр от 0 до 9 (знак числа ставится перед константой).

   Абсолютная величина целой константы не превышает 32767.

   Правильные записи целой константы:

         0
      -127
    +32123

   Неправильные записи целой константы:

  3.14    (не допускается использование
  32,767  десятичной точки и запятой)


   3.3.2. Вещественные константы


   Вещественнаяконстанта - это последовательность десятичных
цифр,  включающая одну десятичную точку. Допустимы следующие
записи вещественной константы:

   s.nn   Или  snn.nn   Или  snn.

 Где

s  - знак числа;

nn
   - последовательность цифровых символов.

   Десятичная точка может находиться в любом месте  последо-
вательности.  Число  цифр  не  ограничивается, но в качестве
значащих рассматриваются только восемь старших цифр.

   Вещественная  константа  может  быть  задана  как   целая
константа в экспоненциальной форме:

     esnn

 где

e  - идентификатор экспоненциальной формы;




8

s  - знак степени;

nn
   - однозначная или двузначная целая константа.

   Если степень положительна, знак "плюс" может быть опущен.
Перед  отрицательной степенью обязательно должен стоять знак
"минус".

   Эта запись изображает степень десяти, на  которую  должна
быть  умножена  предшествующая  ей  целая  или  вещественная
константа (например, 1е6 представляет величину 1.0*10**6).

   Вещественная константа занимает два  слова  (т.е.  четыре
байта  памяти  СМ-4)  и  интерпретируется  как  вещественное
число, имеющее степень точности немного больше, чем семь де-
сятичных цифр.

   За исключением алгебраических знаков, десятичной точки  и
буквы   "e"  (если  она  используется)  запись  вещественной
константы не должна содержать никаких символов,  кроме  цифр
от  0 до 9.

   Если в записи вещественной константы  присутствует  буква
"e",  то за ней обязательно должна следовать однозначная или
двузначная целая константа. Поле степени не может быть  про-
пущено,  но  может  быть  нулевым.  Абсолютная  величина ве-
щественной константы не может быть меньше  0.29*10**(-38)  и
не может быть больше 1.7*10**38.


   Примеры:

 правильная запись
 вещественных констант

   3.14159
   621712.
   -.00127
   +5.0e3
   2e-3

  неправильная запись
  вещественных констант

  1,234,567 (запятые запрещены)
  325e-75   (слишком мала)
  -47.e47   (слишком велика)
   100      (отсутствует деся-
             тичная точка)
   $25.00   (запрещены специа-
             льные символы)












                                                           9

   3.3.3. Константы с двойной точностью


   Константа с двойной точностью занимает четыре слова памя-
ти  и интерпретируется как вещественное число, имеющее до 17
значащих цифр.

   Константа с двойной  точностью  может  быть  представлена
также,  как  и  вещественная  константа,  в экспоненциальной
форме с буквой "d" вместо "e":

      dsnn

 где

nn
   - одно- или двузначная целая константа;

s  - знак степени.

   Число цифр, которые могут предшествовать указанию  степе-
ни,  не лимитировано, однако только 17 старших цифр являются
значащими.

   Отрицательной константе с двойной  точностью  обязательно
должен  предшествовать  знак  "минус".  Наличие знака "плюс"
перед положительной константой не является обязательным.

   Поле степени, следующее за буквой "d" не может быть  опу-
щено, но может быть нулевым.

   Абсолютная величина константы с  удвоенной  точностью  не
может  быть  меньше,  чем  0.29х10**(-38)  и  не  может быть
больше, чем 1.7х10**38.

   Примеры:

        1234567890d+5
        +2.71828182846182d00
        -72.5d-15
        1d0


   3.3.4. Комплексные константы


   Комплексная константа записывается в виде двух вешествен-
ных  констант,  разделенных  запятой и заключенных в скобки.
Первая вещественная  константа  представляет  действительную
часть комплексного числа, а вторая константа - мнимую часть.

   Комплексная константа имеет следующий вид:

      (rc,rc)

Где  rc - это вещественная константа.

   Скобки и запятая являются частью записи  константы  и  их
наличие обязательно.

   Комплексная константа  занимает  четыре  последовательных
слова памяти и интерпретируется как комплексное число.


10


   Примеры :

      (1.70391,-1.70391)
      (+12739e3,0.)


   3.3.5. Логические константы


   Логическая константа принимает логическое значение "исти-
на" или "ложь". Следовательно могут быть только две логичес-
кие константы, они имеют следующий вид:

  .true.  и  .false.

   Ограничивающие  точки  являются  обязательной   составной
частью каждой логической константы.


   3.3.6. Текстовые константы


   Текстовая константа -  это  последовательность  буквенно-
цифровых символов, которой предшествует указатель числа сим-
волов и буква "h".

   Текстовая константа имеет следующий вид:

            nhc1c2...cn

 Где

n  - константа, указывающая число символов в  последователь-
     ности  (включая пробелы и знаки табуляции); может иметь
     значение от 1 до 255. Каждая буква c1, c2,...cn Обозна-
     чает некоторый символ кода кои-8 без русских букв. Мак-
     симальное число символов равно 255.

   Текстовая константа запоминается  как  последовательность
байтов  по  одному  символу  на байт. Текстовые константы не
имеют определенного типа данных. Они принимают  тип  данных,
указанный в операторе format.

   Примеры правильной записи текстовых констант:

        14h сегодня дата:
        1hf

   Примеры неправильной записи текстовых констант:

        3habcd  (неверное число символов)
        2hb :1











                                                          11

   3.3.6.1. Буквенно-цифровые литералы


   Буквенно-цифровой  литерал  -  это  альтернативная  форма
текстовой  константы. Буквенно-цифровой литерал имеет следу-
ющий вид:

      "c1c2c3c4...cn"

где

c1,c2,c3,...,cn  - печатаемый символ кода КОИ-8 (за исключе-
нием русских букв).

   Присутствие обоих ограничивающих апострофов является обя-
зательным.  Максимальное  число символов в буквенно-цифровом
литерале равно 255.

   Внутри  буквенно-цифрового  литерала  символ   "апостроф"
обозначается двумя последовательными апострофами.

   Текстовые константы могут встречаться в операторе  "date"
и в форматах.


   3.4. Переменные


   Переменная -  это  величина,  обращение  к  которой  осу-
ществляется с помощью ее идентификатора. Идентификатор пере-
менной может превышать по размеру шесть знаков.  Однако  ис-
пользуются  только  первые шесть знаков, которые должны быть
уникальны среди имен переменных данного программного модуля.
Значение переменной может быть изменено присваиванием ей но-
вого значения. Переменные классифицируются  по  типу  данных
точно  так  же,  как и константы. Тип переменной определяет,
какой тип данных она представляет. Если  переменной  присва-
иваются  данные  другого  типа, то они преобразуются  к типу
переменной. Тип переменной может быть установлен операторами
описания типа, операторами "implicit", либо неявным заданием
типа.

   Если две или более переменных используют одну и ту же об-
ласть  памяти,  то  эти  переменные эквивалентны друг другу.
Эквивалентность может быть и частичной, когда часть  области
памяти  (но  не вся область), соответствующая одной перемен-
ной, является в то же время частью или всей областью памяти,
соответствуюшей  другой переменной. Эквивалентность устанав-
ливается операторами "common",  "equivalence" и при  исполь-
зовании  фактических  и формальных параметров в обращениях к
подпрограммам. О переменной говорится, что  она  определена,
если соответствующая ей область памяти содержит заданную ве-
личину того же типа, что и идентификатор.  Переменная  может
быть определена еще до выполнения программы посредством опе-
ратора "data" или во время выполнения программы  при  помощи
операторов присваивания или операторов ввода.

   Если одной и той же  области  памяти  соответствуют  (или
частично  соответствуют)  переменные  отличающихся типов, то
определение значения одной переменной (например,  присваива-
нием) приводит к тому, что значения других переменных перес-
тают быть определенными.


12

   3.4.1. Спецификация типа данных


   Операторы явного описания типа определяют, что переменные
будут представлять указанные типы данных.

Например:
      complex var1
      double precision var2

   Эти операторы указывают, что переменной "var1" должна со-
ответствовать область памяти длиной в 4 слова, которая будет
содержать комплексные данные, и что переменной "var2" должна
соответствовать  область  памяти  в  4  слова для размещения
данных с двойной точностью.

   Оператор  неявного описания типа  "implicit"  определяет,
что любая переменная с идентификатором, начинающимся с буквы
из некоторого набора, должна представлять  определенный  тип
данных  при  отсутствии операторов явного описания типа этой
переменной.

   Тип  переменной может быть определен явным образом только
один раз. Явная спецификация типа имеет приоритет над описа-
нием типа, заданным оператором "implicit".

   Если в программе нет операторов "implicit", все  перемен-
ные,  идентификаторы  которых начинаются с букв i,j,k,l,m,n,
представляют переменные целого типа. Переменные, идентифика-
торы  которых  начинаются с любой другой буквы, представляют
вещественные переменные. Например:


 вещественные    целые
 переменные      переменные

  alpha            kount
  beta             item
  totan            ntotal



   3.5. Массивы


   Массив - это множество последовательно расположенных яче-
ек памяти, имеющих общее название - идентификатор (имя) мас-
сива. Обращение к отдельным областям памяти, которые называ-
ются  элементами  массива,  осуществляется по идентификатору
массива, к которому добавляется список индексов.

   Массив имеет размерность в зависимости от количества  ин-
дексов. Индексов может быть от одного до семи. Примером мас-
сива, имеющего размерность единица, является столбец  чисел.
Несколько   столбцов   чисел  представляет  собой  двумерный
массив. Для обращения к определенной величине из этого  мас-
сива  должны указываться номер строки и номер столбца, в ко-
торых находится эта величина. Для обращения  к  величине  из
трехмерного  массива  должны быть заданы номер строки, номер
столбца и номер страницы.




                                                          13

   Массивы  описываются  при  помощи  следующих   операторов
ФОРТРАНА:

 - операторы описания типа переменной;
 - dimension;
 - common;

   Каждый из этих операторов содержит дескриптор  массива  и
указывает  идентификатор  массива,  его  размерность и число
элементов в каждом измерении.


   3.5.1. Дескрипторы массивов


   Дескриптор массива определяет идентификатор массива внут-
ри программного модуля и число позиций в каждом измерении.

   Дескриптор массива имеет следующий формат:

    a(d[,d...])
 где

a  - идентификатор массива;

d  - значение индекса.

   Число индексов определяет размерность массива.  Минималь-
ная  размерность  массива  равна  единице,  а максимальная -
семи.

   Значение индекса определяет число позиций в данном  изме-
рении.  Например, если значение индекса, равно 50, то данное
измерение содержит 50 позиций. Индексы могут быть константа-
ми  или переменными. Переменные индексы используются для оп-
ределения массивов с переменными границами. Число  элементов
в  массиве равно  произведению чисел позиций во всех измере-
ниях.

   Идентификатор массива может встречаться  только  в  одном
дескрипторе массива внутри программной единицы.


   3.5.2. Списки индексов


   Идентификатор массива может дополняться списком индексов.
Список  индексов представляет собой перечень индексных выра-
жений, заключенных в круглые скобки, который  определяет,  к
какому именно элементу массива выполняется обращение.

   Список индексов имеет следующий вид:

  (s[,s]...)

 где

s  - выражение индекса.

   В любом  обращении к индексированному массиву должно при-
сутствовать по одному индексному выражению для каждого изме-
рения.


14


   Индексное выражение записывается в виде одной  из  следу-
ющих конструкций:

 c*v+k   v+k
 c*v-k   v-k
 c*v      v

Где

'c' и 'k'
   - целые без знака,

v  - целая переменная.


   3.5.3. Расположение массивов в памяти


   Об измерениях массивов принято говорить как о  "строках",
"столбцах",  "страницах"  и т.д.. Однако исполняющая система
ФОРТРАНА всегда запоминает массив в памяти в виде  непрерыв-
ной последовательности значений. Многомерный массив хранится
в памяти таким образом, что чем левее индекс, тем быстрее он
изменяется от ячейки к ячейке.

   Пример расположения элементов одномерного массива  arc(6)
в ячейках памяти с условной нумерацией:

 номер ячейки     элемент массива
      1              arc(1)
      2              arc(2)
      3              arc(3)
      4              arc(4)
      5              arc(5)
      6              arc(6)


   Пример расположения элементов двумерного массива tan(3,4)
в ячейках памяти с условной нумерацией:

 номер ячейки     элемент массива
      1               tan(1,1)
      2               tan(2,1)
      3               tan(3,1)
      4               tan(1,2)
      5               tan(2,2)
      6               tan(3,2)
      7               tan(1,3)
      8               tan(2,3)
      9               tan(3,3)
     10               tan(1,4)
     11               tan(2,4)
     12               tan(3,4)

   Пример   расположения   элементов   трехмерного   массива
cos(3,3,3) в ячейках памяти с условной нумерацией:







                                                          15

 номер ячейки     элемент массива
      1                cos(1,1,1)
      2                cos(2,1,1)
      3                cos(3,1,1)
      4                cos(1,2,1)
      5                cos(2,2,1)
      6                cos(3,2,1)
      7                cos(1,3,1)
      8                cos(2,3,1)
      9                cos(3,3,1)
     10                cos(1,1,2)
     11                cos(2,1,2)
     12                cos(3,1,2)
     13                cos(1,2,2)
     14                cos(2,2,2)
     15                cos(3,2,2)
     16                cos(1,3,2)
     17                cos(2,3,2)
     18                cos(3,3,2)
     19                cos(1,1,3)
     20                cos(2,1,3)
     21                cos(3,1,3)
     22                cos(1,2,3)
     23                cos(2,2,3)
     24                cos(3,2,3)
     25                cos(1,3,3)
     26                cos(2,3,3)
     27                cos(3,3,3)



   3.5.4. Тип данных массива


   Тип данных массива определяется таким же образом,  как  и
тип  данных  переменной,  т.е. либо неявно - по первой букве
идентификатора, либо явным образом  -  с  помощью  оператора
описания типа.

   Все величины одного массива  имеют  один  и  тот  же  тип
данных. Любое значение, присвоенное элементу массива, преоб-
разуется к типу данных массива. Если, например, массив  опи-
сан  оператором double precision, компилятор резервирует для
каждого элемента массива 4 слова в памяти.  Если  любому  из
элементов этого массива присваивается значение какого-нибудь
другого типа, оно преобразуется к типу "с двойной  точность-
ю".

   Компилятор с ФОРТРАНА запоминает  элементы  массива  типа
"logical*1" и "integer*1" в смежных байтах.


   3.5.5. Обращения к массивам без  использования  списка
          индексов


   Ниже перечислены типы операторов, в которых идентификатор
массива  может  появляться  без списка индексов для указания
того, что должен быть использован или определен весь массив:





16


   - операторы описания типа;

   - common;

   - equivalence;

   - subroutine;

   - операторы ввода/вывода.

   Идентификаторы массива без списка  индексов  могут  также
использоваться  в качестве фактических параметров. Использо-
вание неиндексированных идентификаторов массивов во всех ос-
тальных типах операторов недопустимо.


   3.5.6. Массивы с переменными границами


   При составлении подпрограмм для обработки формальных мас-
сивов,  у  которых верхние значения индексов должны меняться
от одного обрашения к другому, удобно пользоваться так назы-
ваемыми массивами с переменными границами. Конкретные значе-
ния  индексных  границ  этих  массивов  устанавливаются  при
каждом  обращении к подпрограмме. Для этого в операторе опи-
сания размерностей верхние границы индексов задаются  целыми
переменными  (а не целыми константами). Эти целые переменные
должны быть формальными параметрами. Соответствующие им фак-
тические  параметры  должны  иметь  определенные  значения в
момент обращения к подпрограмме. Тогда при замене формальных
параметров  фактическими параметрами (в процессе вызова) оп-
ределяются фактические границы массивов.

   Значения формальных параметров, используемых в описателях
массивов с переменными границами, не должны изменяться внут-
ри данной подпрограммы.

   Для массива с переменными границами  должно  существовать
описание  этого  массива  в головной программе и фактический
размер массива, используемого в подпрограмме, не должен пре-
вышать размера, заданного в головной программе.

   Функция в следующем  примере  вычисляет  сумму  элементов
двумерного  массива. Следует обратить внимание на употребле-
ние параметров "m" и "n" для управления итерацией.

        subroutine plus(sum,a,m,n)
        dimension а(m,n)
        sum = 0.0
        do 10, i = 1,m
        do 10, j = 1,n
     10 sum = sum + а(i,j)
        return
        end

Ниже приведены примеры обращения к "plus":







                                                          17

        dimension a1(10,35), a2(3,56)
        call plus(sum1,a1,10,35)
        call plus(sum2,a2,3,56)
        call plus(sum3,a1,10,10)




























































18




                        4. ВЫРАЖЕНИЯ


   Выражение может быть константой или переменной, либо ком-
бинацией  из этих компонент и одного или более знаков опера-
ций.

   Знаки операций показывают, какие вычисления над основными
компонентами  должны быть выполнены для того, чтобы получить
значение выражения.

   В ФОРТРАНЕ различаются три класса выражений:

   - арифметические выражения;

   - выражения отношения;

   - логические выражения.

   Результатом вычисления арифметического выражения является
число. Выражения отношений и логические выражения могут быть
истинными или ложными (т.е. их результатом являются логичес-
кие величины).


   4.1. Арифметические выражения


   Арифметические выражения  формируются  из  арифметических
элементов и знаков арифметических операций. Значением такого
выражения является число.

   К арифметическим элементам относятся следующие:

   - числовая константа;

   - числовая переменная;

   - элемент числового массива;

   - арифметическое выражение в скобках;

   - обращение к арифметической функции.

   Знакиарифметических операций определяют, какие вычисления
надо  выполнить  над  значениями арифметических элементов; в
результате выполнения этих операций получается числовое зна-
чение. В ФОРТРАНЕ используются следующие арифметические опе-
рации:

      **     (возведение в степень)
      *      (умножение)
      /      (деление)
      +      (сложение и унарный плюс)
      -      (вычитание и унарный минус)

   Вышеперечисленные операции называются бинарными  операци-
ями,  так как каждая из них используется в сочетании с двумя
элементами. Символы "+" и "-" могут кроме того использовать-


                                                          19

ся  как  знаки унарных операций, когда они помещаются непос-
редственно перед арифметическим элементом.

   Любая арифметическая операция может быть  использована  в
сочетании  с  любым  допустимым арифметическим элементом, за
исключением некоторых ограничений, указанных ниже.

   Переменной или элементу  массива  должно  быть  присвоено
значение  перед  тем,  как их  использовать в арифметическом
выражении.

   Табл. 2 иллюстрирует допустимые  сочетания  типов  данных
основания  и  показателя  степени  (экспоненты) для операции
возведения в степень.


                                                   Таблица 2
 -----------------------------------------
 !               !  Показатель степени   !
 !Основание      !-----------------------!
 !               ! ц  !  в  ! дв  !  к   !
 !---------------!----!-----!-----!------!
 !целое  (ц)     ! да ! нет ! нет !  нет !
 !вещественное(в)! да ! да  ! да  !  нет !
 !с двойной точ- ! да ! да  ! да  !  нет !
 !ностью   (дв)  !    !     !     !      !
 !комплексное (к)! да ! нет ! нет !  нет !
 -----------------------------------------

   Отрицательный элемент можно возводить только в целую сте-
пень;  элемент, имеющий нулевое значение, нельзя возводить в
нулевую степень.

   В любом допустимом степенном  выражении  результат  имеет
всегда  такой же тип данных, что и основание, за исключением
случая операции с вещественным основанием и показателем сте-
пени, имеющим двойную точность. В этом случае результат име-
ет двойную точность.

   Арифметические выражения вычисляются в  порядке  убывания
приоритетности  операций: "**" имеет первый приоритет, "*" и
"/" - второй приоритет, "+" и "-" - третий приоритет.

   В тех случаях, когда имеется две  или  более  операций  с
одинаковым приоритетом (такие, например, как "+" и "-"), они
могут выполняться в любом порядке,  выбираемом  компилятором
(для обеспечения оптимальности вычисления). Экспоненциальные
выражения,  однако,  вычисляются  слева  направо.  Например,
"a**b**c" вычисляется, как "(a**b)**c".


   4.1.1. Применение скобок


   Для изменения обычного порядка вычислений могут использо-
ваться скобки. Выражение, заключенное в скобки, рассматрива-
ется как отдельный арифметический элемент. Это означает, что
вначале  вычисляется  его значение, а затем это значение ис-
пользуется в вычислении выражения.  Ниже  приведены  примеры
использования  скобок.  Цифры  под знаком операций указывают
порядок, в котором выполняются вычисления.



20

  4 + 3 * 2 - 6 / 2 = 7
    3   1   4   2
  (4 + 3) * 2 - 6 / 2 = 11
     1    2   4   3
  (4 + 3 * 2 - 6) / 2 = 2
     2   1   3    4
  ((4 + 3) * 2 - 6) / 2 = 4
      1    2   3    4

   Вычисление выражений, находящихся в скобках,  подчиняется
обычному порядку приоритетов.

   Несущественные скобки, такие как в выражении

 "4 + (3 * 2) - (6/2)"

не оказывают никакого влияния на вычисление выражения.

   Использование скобок для определения  порядка  вычислений
часто  оказывается важным в программах обработки чисел с вы-
сокой степенью точности. Последовательности вычислений,  ал-
гебраически  эквивалентные  друг другу, могут быть неэквива-
лентными по степени точности вычислений (вследствие  перено-
сов и потерь младших разрядов).


   4.1.2. Тип значения арифметического выражения


   Если все элементы арифметического выражения имеют один  и
тот  же тип, то результат выражения будет иметь этот же тип.
Если в выражении имеются элементы различных типов, то вычис-
ление  этого выражения и тип результирующей величины зависят
от ранга, соответствующего типу данных. Ранги  типов  данных
следующие:

          логический =1 (низкий);
               целый =2;
        вещественный =3;
 с двойной точностью =4;
         комплексный =5 (высокий).

   Тип результата операции над двумя арифметическими элемен-
тами  различного  типа такой же, как и у элемента с наиболее
высоким рангом. Тип значения выражения такой же, как  и  тип
результатапоследней операции в вычислении данного выражения.
Способ определения типа  значения  выражения  заключается  в
следующем:

Целые операции

   - целые операции выполняются только над целыми  элемента-
     ми; в арифметике целых чисел любая дробная часть, кото-
     рая может быть результатом деления отбрасывается, а  не
     округляется; например, значение выражения

      1/3 + 1/3 + 1/3

       равно нулю, а не единице.





                                                          21

 Вещественные операции

   - вещественные операции выполняются только над веществен-
     ными  элементами либо над комбинацией из вещественных и
     целых элементов; все присутствующие целые элементы пре-
     образуются  к  вещественному типу добавлением к каждому
     из них дробной части, равной  нулю;  однако  необходимо
     заметить,  что в операторе "y = (i/j)*x" над величинами
     "i" и "j" выполняется операция целого  деления,  а  над
     результатом  деления  и  переменной "x" выполняется ве-
     щественное умножение.

 Операции с двойной точностью

   - любой вещественный или целый элемент в операции с двой-
     ной точностью преобразуется к типу с двойной точностью,
     причем имеющийся элемент  становится  старшей  значащей
     частью  данных  с двойной точностью, а младшая значащая
     часть заполняется нулями; после этого  выполняется  вы-
     числение с двойной точностью.

П_Р_И_М_Е_Ч_А_Н_И_Е.
     Преобразование вещественного элемента  к  типу  двойной
     точности вовсе не увеличивает степень точности вычисле-
     ния  этого  элемента.  Например,   вещественное   число
     0.3333333    после    преобразования    станет   числом
     0.3333333000000000,  а  не  числом  0.3333333333333333.
     Нужно также отметить, что вещественные элементы с двой-
     ной   точностью   являются   только    приблизительными
     представлениями  фактических чисел. Результирующие зна-
     чения вещественных выражений или  выражений  с  двойной
     точностью в действительности точны лишь настолько, нас-
     колько позволяет степень точности этого типа данных.

 Комплексные операции

   - в операциях, содержащих любой комплексный элемент,  це-
     лые  элементы  преобразуются  к вещественному типу, как
     указано выше; элементы с двойной точностью преобразуют-
     ся  к  вещественному  типу округлением младшей значащей
     части;  после  этого  полученный  вещественный  элемент
     рассматривается  как  действительная часть комплексного
     числа; мнимая часть этого числа равна нулю; после этого
     выражение   вычисляется   с  использованием  арифметики
     комплексных чисел и результирующее значение будет также
     комплексного типа.


   4.2. Выражения отношений


   Выражение отношения состоит из двух арифметических  выра-
жений, разделенных операцией отношения. Значение данного вы-
ражения есть либо "истина", либо  "ложь"  в  зависимости  от
того, выполняется или нет указанное отношение.

   Операции отношения следующие:







22

  знак операции    отношение
    .lt.            меньше
    .le.            меньше или равно
    .eq.            равно
    .ne.            не равно
    .gt.            больше
    .ge.            больше или равно.

   Ограничивающие точки - это часть знака операции отношения
и их наличие в тексте обязательно.

   К комплексным выражениям применимы только отношения  .eq.
и  .ne.  .  Если присутствует одно комплексное выражение, то
второе  выражение   преобразуется   к   комплексному   типу.
Комплексные об'екты равны, если соответственно равны их дей-
ствительные и мнимые части.

   В выражении отношения прежде всего  вычисляется  значение
арифметических  выражений.  Затем  эти величины сравниваются
для проверки того, выполняется ли отношение, заданное опера-
цией. Например, выражение:

           app + pea .gt. par + ora

устанавливает отношение следующего вида: "сумма вещественных
переменных"app" и "pea" больше суммы вещественных переменных
"par" и "ora"". Если это соотношение  выполняется,  значение
выражения равно "истина", а если нет - то "ложь".

   Все операции отношения имеют одинаковый приоритет. Следо-
вательно, если в выражении встречаются два или более выраже-
ний отношения, операции отношения выполняются слева направо.
Арифметические  операции  имеют более высокий приоритет, чем
операции отношения.

   Для изменения порядка вычислений арифметических выражений
в выражении отношения скобки используются точно также, как и
в любом другом арифметическом  выражении.  Однако  поскольку
арифметические  операции  выполняются до операции отношения,
то заключать в скобки арифметическое  выражение  целиком  не
обязательно.

   Если в выражении  отношения  сравниваются  два  выражения
разных  типов  данных,  перед выполнением сравнения значение
выражения, имеющего тип более низкого ранга преобразуется  к
типу более высокого ранга.


   4.3. Логические выражения


   Логическое выражение может быть отдельным логическим эле-
ментом  или  комбинацией  логических  элементов и логических
операций. Логическое выражение имеет значение  "истина"  или
"ложь".

   Логический элемент может быть одним из следующих:

   - целая или логическая константа;





                                                          23

   - целая или логическая переменная;

   - элемент целого или логического массива;

   - выражение отношения;

   - логическое выражение, заключенное в скобки;

   - обращение к целой или логической функции.

   Логические операции следующие:

 .and.

   - логическая кон'юнкция (логическое "и");  выражение  ис-
     тинно тогда и только тогда, когда и "a", и "b" истинны;

 .or.

   - логическая  диз'юнкция  (логическое  "или");  например,
     "a.or.b"; выражение истинно тогда и только тогда, когда
     истинно либо "a", либо "b", либо оба;

 .xor.

   - исключающее или; пример: "a.xor.b"; выражение  истинно,
     если  "a" истинно, а "b" ложно, либо, если "b" истинно,
     а "a" ложно; выражение ложно, если оба  элемента  имеют
     одинаковое значение;

 .eqv.

   - логическая эквивалентность; например, "a.eqv.b";  выра-
     жение  истинно  тогда  и  только тогда, когда "a" и "b"
     имеют одинаковые логические значения, безразлично,  ис-
     тина или ложь;

 .not.

   - логическое  отрицание   (логическое   "не");   например
     ".not.a"; выражение истинно тогда и только тогда, когда
     ложно "a".

   Вычисление  логического  выражения  происходит   согласно
старшинству  его  операций.  Некоторые  логические выражения
могут быть вычислены без вычисления всех подвыражений.  Нап-
ример,    если    "a"    равно   ".false.",   то   выражение
"a.and.(x+y).gt.2.0).and.b" равно ".false.". Значение  этого
выражения может быть определено только проверкой "a" без вы-
числения x+y.

   Ниже  приведен  перечень  всех  операций,  которые  могут
встречаться  в  логическом выражении. Выполняются операции в
следующей последовательности:

        **             первой
        *,/            второй
        +,-            третьей
  операция отношения   четвертой
      .not.            пятой
      .and.            шестой
      .or.             седьмой


24

   .xor.,.eqv.         восьмой

   Операции с одинаковым приоритетом выполняются слева  нап-
раво. Ниже приведен пример логического выражения, содержаще-
го выражения отношений.

        a*b + c*abc.eq.x*y + dm*zz
     *  .and. .not.k*b.gt.tt

   Это выражение вычисляется в следующем порядке:

       (((a*b)+(c*abc)).eq.((x*y)+(dm*zz)))
     * .and.(.not.((k*b).gt.tt))

   Как и в арифметических выражениях для изменения  обычного
порядка выполнения операций могут использоваться скобки.

   Два знака  логических  операций  не  могут  располагаться
подряд,  за  исключением  того случая, когда вторая операция
есть ".not.".












































                                                          25




                 5. ОПЕРАТОРЫ ЯЗЫКА ФОРТРАН



   5.1. Операторы присваивания


   Операторы присваивания определяют значение переменной или
элемента  массива  путем  вычисления  некоторого выражения и
присваивания результирующего значения переменной или элемен-
ту массива.

   Существует три типа оператора присваивания:

   - арифметический;

   - логический;

   - оператор "assign".


   5.1.1. Арифметический оператор присваивания


   Арифметический оператор присваивает  значение  выражения,
расположенного  справа  от  знака  равенства, переменной или
элементу массива, находящемуся  слева  от  знака  равенства.
Если у переменной до этого было какое-то значение, оно теря-
ется.

   Арифметический оператор присваивания имеет следующий вид:

         w = a

 где

w  - идентификатор  числовой  переменной  или  идентификатор
     массива;

a  - выражение.

   Знак равенства здесь не означает "равно",  как  обычно  в
математике.  Он означает "заменяется". Таким образом, опера-
тор
      i = i+1 означает: "текущее значение  целой  переменной
"i"  заменяется  суммой  этого  текущего  значения  и  целой
константы "1".

   Хотя идентификатор слева от знака равенства может не быть
предварительно  определен,  всем  идентификаторам  справа от
знака равенства, к которым имеются  обращения  в  выражении,
предварительно должны быть присвоены значения.

   Результатом выражения должно быть значение,  удовлетворя-
ющее требованиям типа переменной или элемента массива, кото-
рым оно присваивается. Например, вещественное выражение, ре-
зультатом которого является величина, превышающая 32767, не-
допустимо, если об'ектом слева от знака  равенства  является
переменная типа "integer*2".


26


   Если тип переменной или  элемента  массива,  находящегося
слева  от  знака  равенства, точно такой же, как у выражения
справа,  оператор  непосредственно  выполняет  присваивание.
Если типы различаются, то перед присваиванием значение выра-
жения преобразуются к типу об'екта,  находящегося  слева  от
знака равенства.

   Правила преобразования для операторов присваивания следу-
ющие:

   Переменная или элемент массива "w" - целая:

   - если результатом выражения "a" является целая или логи-
     ческая константа,то "w" присваивается значение "a";

   - если результатом выражения  "a"  является  вещественная
     константа,  то значение "a" усекается до целого и прис-
     ваивается "w";

   - если результатом выражения  "a"  является  константа  с
     двойной  точностью, то значение "a" усекается до целого
     и присваивается "w";

   - если  результатом выражения  "a"  является  комплексное
     число,  то действительная часть "a" усекается до целого
     и присваивается "w". Мнимая часть "a" не используется.

   Переменная или элемент массива "w" - вещественная:

   - если результатом выражения "a" является целая или логи-
     ческая константа, то к значению "a" добавляется дробная
     часть (.0), и оно присваивается "w";

   - если результатом выражения  "a"  является  вещественная
     константа, то "w" присваивается значение "a";

   - если результатом выражения "a" является число с двойной
     точностью,  то "w" присваивается старшая значащая часть
     "a"; младшая часть "a" округляется;

   - если результатом  выражения  "a"  является  комплексное
     число,  то  действительная часть "a" присваивается "w";
     мнимая часть "a" не используется.

   Переменная или элемент массива "w" - с двойной точностью:

   - если результатом выражения "a" является целая или логи-
     ческая константа, то к значению "a" добавляется дробная
     часть (.0), и оно присваивается старшей значащей  части
     "w"; младшая значащая часть "w" равна нулю;

   - если результатом выражения  "a"  является  вещественная
     константа,  то "a" присваивается старшей значащей части
     "w". Младшая значащая часть равна нулю;

   - если результатом выражения "a" является число с двойной
     точностью, то "w" присваивается значение "a";

   - если результатом  выражения  "a"  является  комплексное
     число,  то действительная часть "a" присваивается стар-
     шей части "w". Младшая значащая часть "w"  равна  нулю;


                                                          27

     мнимая часть "a" не используется.

   Переменная или элемент массива "w" - комплексная:

   - если результатом выражения "a"  является целая или  ло-
     гическая  константа,  то  "a" снабжается дробной частью
     (.0) и присваивается действительной части  "w";  мнимая
     часть "w" равна 0.0;

   - если результатом выражения "a"   является  вещественная
     константа,  то  она  присваивается действительной части
     "w"; мнимая часть "w" равна 0.0;

   - если результатом выражения "a" является число с двойной
     точностью,  то старшая значащая часть "a" присваивается
     действительной части "w"; младшая  значащая  часть  "a"
     округляется. Мнимая часть "w" равна 0.0;

   - если результатом  выражения  "a"  является  комплексное
     число, то "w" присваивается значение "a".

   Примеры записи допустимых операторов:

  beta = -1./(2.*x) + a*a/(4.*(x*x))
  p1 = 3.14159
  sum = sum + 1

   Примеры записи недопустимых операторов:

  3.14 = a - b
  (об'ект в левой части должен быть пере-
   менной или элементом массива);

  -j =1**4
  (об'ект в левой части не должен иметь
  знака);

  alpha = ((x+6)*b*b/(x-y)
  (число открывающихся скобок
  не равно числу закрывающихся).


   5.1.2. Логические операторы присваивания


   Логический оператор присваивания подобен  арифметическому
оператору присваивания, но он оперирует с логическими данны-
ми. Логический оператор  присваивания  вычисляет  выражение,
находящееся справа от знака равенства, и присваивает резуль-
тирующую логическую величину переменной или элементу  масси-
ва, расположенному слева от знака равенства.

   Логический оператор имеет следующий вид:

       w = a

 где

w  - переменная или элемент массива логического типа;





28

a  - логическое выражение.

   Переменная или элемент массива, стоящие  слева  от  знака
равенства,  обязаны принадлежать к типу "logical". Их значе-
ние может быть и не определено заранее.

   Всем идентификаторам, присутствующим в выражении,  должны
быть предварительно присвоены числовые или логические значе-
ния. Результат вычисления должен быть логической величиной.

 Примеры:
 pagend =.false.
 pull = line.le.132.and..not.robin
 bill = a.gt.b.and. a.gt. c .and. a


   5.1.3. Оператор  'assign'


   Оператор "assign" используется для присвоения целой пере-
менной  метки оператора. Затем эта переменная может быть ис-
пользована для указания места передачи управления в последу-
ющем операторе перехода по предписанию "goto".

   Оператор "assign" имеет следующий вид:

      assign s to w

 где

s  - метка выполняемого оператора из  того  же  программного
     модуля,  что  и  оператор  "assign"  (она не может быть
     меткой оператора "format");

w  - целая переменная.

   Оператор "assign" присваивает переменной номер  оператора
таким же образом, как это делается в арифметическом операто-
ре присваивания. Переменная, получившая  значение  метки  не
может  быть  использована  как  переменная, имеющая числовое
значение, до тех пор, пока она его не получит в арифметичес-
ком операторе присваивания или в операторе ввода.

   Оператор

        assign 100 to number

Ставит в соответствие переменной  "number"  метку  оператора
100. После этого арифметические операции над этой переменной
такие, как в операторе

        number = number + 1

будут недопустимыми, так как метка оператора не  может  быть
изменена. Оператор

        number = 10

присваивает переменной "number" значение 10 и возвращает эту
переменную в ее исходное состояние в качестве целой перемен-
ной. Теперь эта переменная не может быть использована в опе-
раторе перехода по предписанию.


                                                          29


   Примеры использования оператора "assign":

        assign 10 to nstart
        assign 9999 to nstop
        assign 350 to eras
c   eras должна быть определена
c   как целая переменная



   5.2. Операторы управления


   Операторы, как правило,  выполняются  в  том  порядке,  в
каком  они записаны. Однако иногда необходимо прервать обыч-
ный порядок выполнения программы передачей управления в дру-
гую  секцию  программы или подпрограмму. Передача управления
из заданной точки программы может быть выполнена всякий раз,
когда  эта точка встретится в процессе выполнения программы.
Возможен также  вариант,  когда  передача  управления  будет
каждый раз осуществляться в одну и ту же точку программы.

   Передача управления, как внутри одного программного моду-
ля, так и в другой программный модуль, выполняется при помо-
щи операторов управления. Кроме того, эти операторы управля-
ют  итерационной  обработкой, приостановкой выполнения прог-
раммы и прекращением выполнения программы. Имеются следующие
операторы управления:

        go to
        if
        do
        continue
        call
        return
        stop
        end


   5.2.1. Оператор 'go to'


   Оператор "go to" передает управление внутри  программного
модуля  либо  каждый  раз на один и тот же оператор, либо на
один из операторов, принадлежащих  некоторому  множеству,  в
зависимости от значения некоторого выражения.

   Имеются три типа операторов "go to":

   - оператор безусловного перехода;

   - вычисляемый оператор перехода;

   - оператор перехода по предписанию.









30

   5.2.1.1. Оператор безусловного перехода


   Оператор безусловного перехода передает управление одному
и тому же оператору.

   Оператор безусловного перехода имеет следующий вид:

        go to s

 где

s  - метка некоторого выполняемого оператора, находящегося в
     том  же самом программном модуле, что и данный оператор
     "go to".

Примеры:
        go to  7740
        go to  99999
        go to 16.5
c недопустимо; неправильно записана
c метка оператора



   5.2.1.2. Вычисляемый оператор перехода 'go to'


   Вычисляемый оператор перехода передает управление  опера-
тору,  определяемому по значению выражения, входящего в опе-
ратор "go to".

   Вычисляемый оператор перехода  "go  to"  имеет  следующий
вид:

  go to  (k1,k2,...,kn)[,] m

 где

k1,k2,...,kn
   - метки выполняемых операторов; список  меток  называется
     списком переходов;

m  - арифметическое выражение, значением  которого  является
     целое  число, лежащее внутри интервала от 1 до n (где n
     - это число меток операторов в списке переходов).

   Вычисляемый оператор перехода  вычисляет  выражение  "m".
После  этого оператор "go to" передает управление метке опе-
ратора, порядковый номер которой в  списке  переходов  равен
полученному  значению выражения. Например, если список имеет
вид (30,20,50,40), а значение выражения "m"  равно  "2",  то
оператор  "go  to"  передаст управление на оператор с меткой
"20".

   Если значение выражения меньше единицы  или  больше,  чем
число меток в списке переходов, управление передается перво-
му выполняемому оператору, следующему за вычисляемым  опера-
тором перехода "go to ".





                                                          31

 Примеры:
   go to (17,25,36),kend
   go to (340,360,500,700) situ(j,k)+1


   5.2.1.3. Оператор перехода по предписанию 'go to'


   Оператор перехода по предписанию имеет следующий вид:

        go to v[[,](k1,k2,...,kn)]

 где

v  - целая переменная;

k1,k2,...,kn
   - метки выполняемых операторов.

   Оператор перехода по предписанию передает управление опе-
ратору,  метка  которого была последней присвоена переменной
"v" оператором "assign".

   Переменная "v" должна быть переменной целого  типа  и  ей
должно  быть присвоено значение метки некоторого оператора с
помощью оператора "assign" (а не  арифметического  оператора
присваивания) до выполнения оператора "go to".

   Оператор перехода по предписанию и соотвествующий  опера-
тор  (или операторы) "assign" должны быть расположены внутри
одного и того же программного модуля. Операторы, которым пе-
редается  управление, также должны быть расположены в том же
программном модуле.

 Примеры:
        go to igo
        go to index, (300,400,1000,700)


   5.2.2. Операторы 'if'


   Оператор "if" вызывает условную передачу  управления  или
условное  выполнение  некоторого оператора. Имеется два типа
операторов "if":

   - арифметический оператор условного перехода "if";

   - логический условный оператор "if".

   В обоих случаях решение о передаче управления или  о  вы-
полнении оператора основывается на результате вычисления вы-
ражения, входящего в состав оператора "if".











32

   5.2.2.1. Арифметический  оператор  условного  перехода
            'if'


   Арифметический оператор  условного  перехода  "if"  имеет
следующий вид:

        if (m) k1,k2,k3
 где

m  - арифметическое выражение,

k1,k2,k3
   - метки выполняемых операторов, расположенных  в  той  же
     самой программной единице.

   В записи оператора должны присутствовать все  три  метки.
Эти метки необязательно должны относиться к трем разным опе-
раторам. Если необходимо, одна или две метки могут относить-
ся к одному оператору.

   При выполнении арифметического оператора условного  пере-
хода  прежде  всего вычисляется выражение в скобках, а затем
управление передается оператору  с  меткой  "k1",  "k2"  или
"k3",  если  значение  выражения  "m" соответственно меньше,
равно или больше нуля.

 Примеры:
        if(gamma-chi) 50,50,100

Этот оператор передает управление  оператору  50,  если  ве-
щественная  переменная "gamma" меньше или равна вещественной
переменной "chi". Управление передается оператору 100 только
в том случае, когда "gamma" больше, чем "chi".

   if(number/2*2-number) 20,40,20

Этот оператор передает управление  оператору 40, если значе-
ние  целой  переменной "number" четно, и  оператору 20, если
оно нечетно. В этом случае третья  метка  оператора  обязана
присутствовать,  хотя  она никогда не используется; значение
выражения будет либо нулем, либо отрицательным числом.


   5.2.2.2. Логический условный оператор 'if'


   Логический условный оператор "if" имеет следующий вид:

        if (e) s

 где

e  - логическое выражение;

s  - оператор ФОРТРАНА, за исключением  оператора  "do"  или
     другого логического условного оператора "if".

   При выполнении  логического  условного  оператора  прежде
всего  вычисляется  значение логического выражения. Если это
значение равно ".true.", то происходит выполнение  оператора
"s". Если значение выражения равно ".false.", управление пе-


                                                          33

редается  первому выполняемому оператору, следующий за  опе-
ратором "if" (при этом оператор "s" не выполняется).

 Примеры:
 if (j.gt.4.or.j.lt.1) go to 200
 if (rec(j,k).ne.hold) rec(j,k)=rec(j,k)*2
 if (endrun) call exit


   5.2.3. Оператор 'do'


   Оператор "do" используется для задания итерационной обра-
ботки.  Оператор "do" позволяет повторить определенное число
раз  выполнение операторов, находящихся в области  его  дей-
ствия.

   Оператор "do" имеет следующий вид:

        do s i=e1,e2[,e3]

 Где

s  - метка последнего выполняемого оператора. Этот  оператор
     должен  физически  располагаться после оператора "do" в
     той же самой программной единице;

i  - целая переменная;

e1,e2,e3
   - целые константы или переменные целого типа

   Переменная "i" называется счетчиком цикла, а  "e1", "e2",
"e3"  называются соответственно начальным параметром, конеч-
ным параметром и шагом итерации. Если шаг опущен, он  прини-
мается равным "1".

   Последний оператор, включенный в цикл, указывается с  по-
мощью  метки  в записи оператора цикла "do". Этим оператором
не должен быть ни оператор "go to", ни арифметический опера-
тор  условного перехода "if", ни оператор "return" и ни дру-
гой оператор "do". В качестве последнего оператора допустимо
использование логического условного оператора "if".

   Все операторы, которые следуют за оператором "do"  вплоть
до последнего оператора (включая его), образуют область дей-
ствия оператора "do" (область цикла).

   При выполнении оператора "do"  прежде  всего  управляющей
переменной   присваивается  значение  начального  параметра.
Затем происходит многократное  выполнение  всех  выполняемых
операторов, лежащих в области действия оператора "do".

   Значение конечного параметра не должно быть меньше значе-
ния  начального  параметра.  Значение  шага  не  должно быть
нулем.

   Число выполнений операторов из области действия оператора
цикла, называемое числом итераций, определяется по формуле:





34

       [(e2 - e1)/e3]+ 1

Где величина в [ ] представляет наибольшее абсолютное  целое
значение выражения в скобках.

   Если число итераций равно нулю или отрицательно, цикл вы-
полняется только один раз.


   5.2.3.1. Управление итерацией


   Для каждой итерации вслед за выполнением последнего  опе-
ратора  тела  цикла  выполняются  следующие управляющие дей-
ствия:

   - к значению управляющей переменной алгебраически прибав-
     ляется значение шага;

   - уменьшается счетчик итераций;

   - еслисчетчик итераций больше нуля, управление передается
     первому  выполняемому оператору, расположенному за опе-
     ратором "do", для очередного повторения  операторов  из
     области действия цикла;

   - если счетчик  итераций  равен  нулю,  выполнение  цикла
     прекращается.

   Выполнение цикла может быть также  прекращено  с  помощью
оператора,  находящегося  в  области действия цикла, который
передает управление за пределы цикла. При этом у управляющей
переменной остается значение, равное ее текущему значению.

   Если последний оператор цикла входит и в другие циклы, то
по  окончанию  внутреннего  цикла  управление  передается на
самый внутренний из оставшихся  внешних  циклов.  Если  этот
последний  оператор  не входит ни в какие другие циклы, либо
если данный цикл был самым  внешним,  управление  передается
первому выполняемому оператору, следующему за последним опе-
ратором цикла.

   Значения управляющей переменной,  конечного  параметра  и
шага  не  могут изменяться внутри области действия оператора
"do". Внутри этой области допускаются обращения  к  управля-
ющей переменной как к обычной переменной.

   В области действия оператора "do" могут находиться другие
операторы "do" при условии, что они удовлетворяют определен-
ным требованиям.

   Возможна передача управления из тела  цикла  во  вне,  но
нельзя  передать управление в тело цикла из какого-либо дру-
гого места программы, если этот цикл еще не  начат,  или  он
уже закончен.

   Пример:







                                                          35

 do 100 k=1,50,2    (25 итераций;
                    k=49 во время последней
                    итерации)


   5.2.3.2. Вложенность операторов 'do'


   Область оператора "do" может  содержать  один  или  более
других операторов "do". Область действия внутреннего вложен-
ного цикла должна полностью лежать внутри  области  действия
охватывающего его цикла (или самого внутреннего из охватыва-
ющих). Такая совокупность операторов "do" и их областей  на-
зывается полностью вложенной. Циклы в цикле могут иметь один
и тот же последний оператор.


пример допустимой вложенности операторов "do":
   !-      do 90 k=1,10
   !           ...
   !           ...
   !
   !!-     do 35 l=2,50,2
   !!          ...
   !!          ...
   !!-        35 continue
   !
   !           ...
   !           ...
   !
   !!-     do 90 m=1,20
   !!
   !!          ...
   !!          ...
   !!-        90 continue
   !-

   Пример недопустимой вложенности операторов "do":

     !-     do 80 k=1,10
     !         ...
     !         ...
     !
   !-!      do 25 i=1,20
   ! !         ...
   ! !         ...
   ! !-  80 continue
   !
   !           ...
   !           ...
   !
   ! !-     do 30 m=1,15
   ! !         ...
   ! !         ...
   !-!   25 continue
     !
     !        ...
     !        ...
     !-  30 continue





36

   5.2.3.3. Передача управления во вложенных 'do'


   Внутри вложенной структуры "do" управление может  переда-
ваться  из внутреннего цикла во внешний. Передачи управления
из внешнего цикла во внутренний запрещены.

   Если два или более вложенных циклов имеют один и  тот  же
последний  оператор,  управление  этому оператору может быть
передано  только  из  области  действия  самого  внутреннего
цикла.  Любая  другая  передача  управления  этому оператору
будет рассматриваться как передача  управления  из  внешнего
цикла  во  внутренний,  так как этот общий оператор является
частью области действия самого внутреннего цикла.


   5.2.4. Оператор 'continue'


   Оператор "continue" передает управление следующему выпол-
няемому  оператору. Он главным образом используется как пос-
ледний оператор в области действия оператора "do" в тех слу-
чаях, когда последний оператор не может иметь метки заверше-
ния цикла (является либо оператором "go to", либо  арифмети-
ческим  оператором условного перехода "if", либо другим зап-
рещенным оператором управления).

   Оператор "continue" имеет следующий вид:

        continue


   5.2.5. Оператор 'call'


   Оператор "call" вызывает выполнение подпрограммы и  опре-
деляет   список   фактических   параметров,  передаваемых  в
подпрограмму.

   Оператор "call" имеет следующий вид:

      call s[([p] [,[p]]...)]

 где

s  - имя подпрограммы, написанной на языке ФОРТРАН, или  од-
     ной из системных подпрограмм;

р  - фактический параметр, соответствующий  одному  из  фор-
     мальных параметров в вышеперечисленных подпрограммах.

   Оператор "call" устанавливает соответствие между значени-
ями  списка параметров (если список присутствует) и формаль-
ными параметрами в подпрограмме и затем передает  управление
первому выполняемому оператору подпрограммы.

   Параметры, указанные в операторе "call", должны по своему
количеству, порядку следования и типу данных соответствовать
формальным параметрам в определении подпрограммы. В качестве
фактических параметров допускается использование переменных,
массивов, элементов массива, констант, выражений,  буквенно-
цифровых литералов или идентификаторов подпрограмм, если эти


                                                          37

идентификаторы были описаны в операторе "external".  Иденти-
фикатор  массива без списка индексов, расположенный в списке
параметров, относится ко всему массиву в целом.

 Примеры:
 call procent(bpl,3.14159,y,limit,r(lt+2))
 call calve(a,b)
 call exit


   5.2.6. Оператор 'return'


   Оператор "return" используется для возврата управления из
подпрограммы в вызывающий программный модуль.

   Оператор "return" имеет следующий вид:

        return

   При выполнении  в подпрограмме оператора "return" в вызы-
вающей программе  управление передается первому выполняемому
оператору, следующему непосредственно за оператором  "call",
который вызвал выполнение подпрограммы.

   Оператор "return" не  должен  присутствовать  в  основном
программном модуле.

   Пример:

        subroutine cart(n,a,data,p,k)
        dimension data(n), p(n)
        if(n.lt.10) go to 200
        data(k+2)=n-(n/10)*n
        n=n/10
        data(k+1)=n
        p(k+2)=a(data(k+2)+1)
        p(k+1)=a(data(k+1)+1)
        return
    200 p(k+2)=a(n+1)
        return
        end


   5.2.7. Оператор 'stop'


   Оператор "stop" используется для  прекращения  выполнения
программы.

   Оператор "stop" имеет следующий вид:

        stop [n]

где   n  - последовательность десятичных цифр, содержащая от
одной до пяти цифр, буквенно-цифровой литерал или восьмерич-
ная константа.

   Оператор "stop" выводит сообщение на терминал пользовате-
ля  (если это определено), прекращает выполнение программы и
возвращает управление операционной системе.



38

 Примеры:
        stop 73
        stop "7777
   1999 stop
        stop 'конец программы'


   5.2.8. Оператор 'end'


   Оператор "end" отмечает конец программной единицы. Опера-
тор "end" должен быть последней входной строкой любого прог-
раммного модуля.

   Оператор "end" имеет следующий вид:

        end

   В основной программе передача управления  оператору "end"
вызывает  прекращение выполнения программы, а в подпрограмме
- выполнение оператора "return".


   5.3. Ввод/вывод данных


   Ввод данных программой на ФОРТРАНЕ выполняется с  помощью
оператора   "read".   Вывод  данных  выполняется  оператором
"write". Эти операторы используются в сочетании со  специфи-
кациями  формата, которые управляют редактированием и преоб-
разованием данных из внутреннего представления в  символьную
форму и наоборот.

   Каждый оператор "read" или "write" содержит указание  ло-
гического  устройства, с которого или на которое должна быть
осуществлена передача данных.  Логическое  устройство  может
соотвествовать либо внешнему устройству, либо файлу.

   Операторы "read" и "write" могут принадлежать к одной  из
следующих категорий:

Неформатный  ввод/вывод
   - при выполнении операторов неформатного последовательно-
     го ввода/вывода осуществляется передача двоичных данных
     без преобразования.

Форматный  ввод/вывод
   - при выполнении операторов форматного  последовательного
     ввода/вывода осуществляется передача символьных данных,
     причем для преобразования данных в символы при выводе и
     во внутреннюю форму при вводе используются спецификации
     формата.

   Вспомогательные   операторы   ввода/вывода   "rewind"   и
"endfile"  не выполняют передачи данных, а служат для управ-
ления положением указателей файла.








                                                          39

   5.3.1. Номера логических устройств ввода/вывода


   Программа, написанная  на  ФОРТРАНЕ,  может  пользоваться
всеми  внешними  устройствами,  поддерживаемыми операционной
системой. Операторы ввода/вывода  обращаются  к  устройствам
ввода/вывода  с  помощью номеров логических устройств. Номер
логического устройства представляет  собой  целую  константу
или  переменную  с  положительным  значением  от 1 до 19. По
умолчанию номер 5 связан со стандартным вводом, номер 6 свя-
зан со стандартным выводом, а остальные связаны с файлами по
имени:

                            filexx

                            где

xx
   - логический номер.

Имя файлов можно сменить с помощью подпрограммы "setfile".


   5.3.2. Указатели формата


   Указатели формата используются  в  операторах  форматного
ввода/вывода.  Указатель  формата - это либо метка оператора
"format", либо имя массива,  содержащего  текстовые  данные,
интерпретируемые как описание формата.


   5.3.3. Единицы ввода/вывода


   Обмен информацией с помощ'ю операторов  ввода/вывода  ве-
дется  определенными  порциями, которые называются записями.
Количество информации, которое может содержаться в одной за-
писи, а также способы разделения этих записей зависят от ис-
пользуемого носителя информации.

   Для неформатного ввода/вывода количество данных,  которое
должно  быть передано, определяется оператором ввода/вывода.
В случае же форматного ввода/вывода количество  передаваемой
информации  определяется совместно оператором ввода/вывода и
спецификациями в соответствующем описании формата.

   Начало выполнения оператора ввода/вывода инициирует пере-
дачу  новой  записи.  Если  оператор ввода потребовал только
часть записи, остальная часть записи теряется. В случае фор-
матного  последовательного ввода/вывода отдельным оператором
ввода/вывода может быть передано несколько записей .

   В файлах ОС ДЕМОС нет разделителей бинарных  записей.  Из
файла  читается  ровно  столько  байтов, сколько запрошено в
операторе чтения.








40

   5.3.4. Списки ввода/вывода


   Список ввода/вывода определяет элементы данных, с которы-
ми  будет  манипулировать  оператор, содержащий список. Этот
список
 содержит имена переменных, массивов и  элементов  массивов,
значения  которых  должны  быть  переданы. Кроме того список
оператора вывода может содержать константы и выражения.

   Список ввода/вывода имеет следующий вид:

  s[,s]...

где каждое "s" - это простой список  или  список  с  неявным
циклом.  Оператор ввода/вывода присваивает вводимые значения
элементам списка или выводит значения элементов списка в той
последовательности,  в какой они встречаются в списке (слева
направо).


   5.3.4.1. Простые списки


   Простой элемент списка ввода/вывода состоит из  отдельной
переменной,  обращения к массиву, элемента массива.  Простой
список ввода/вывода содержит или простой элемент списка вво-
да/вывода или группы из двух или более таких элементов, раз-
деленных запятыми.

   Если в списке ввода/вывода встречается идентификатор мас-
сива без списка индексов, то оператор "read"  введет столько
данных, сколько  нужно, чтобы заполнить каждый элемент  мас-
сива;  оператор "write" выведет значения всех элементов мас-
сива. Передача данных начинается с начального элемента  мас-
сива и выполняется в порядке индексной прогрессии; при этом,
чем левее находится индекс, тем быстрее он изменяется.  Нап-
ример, если идентификатор массива, определенного как

 array (3,3)

встретится без списка индексов в операторе "read",  то  этот
оператор присвоит значения из введенной единицы (или единиц)
записи   элементам   array(1,1),   array(2,1),   array(3,1),
array(1,2) и так далее, вплоть до array(3,3).

   В операторе "read"   переменные,  находящиеся  в  списке,
могут  быть  использованы  как индексы массива, имя которого
содержится далее в этом списке. Например,  если  выполняется
оператор

        read (1,250) j,k,array(j,k)
    250 format (i1,x,i1,f6.2)

а входная единица записи содержит следующие величины:

        1, 3, 921.33

то  значение  "921.33"  будет  присвоено  элементу   массива
array(1,3). Первая введенная величина присваивается перемен-
ной "j", вторая - переменной "k" и, таким образом,  устанав-
ливаются   фактические   значения   индексов   для  элемента


                                                          41

array(j,k). Переменные, которые предназначаются для  исполь-
зования  их в качестве индексов вышеописанным способом, обя-
заны находиться в списке ввода/вывода слева от списка индек-
сов массива, в котором они используются.

   Запрещается включение выражений в список оператора ввода,
за исключением выражения индекса в обращении к массиву.


   5.3.4.2. Списки с циклами


   Списки с циклами используются для определения  повторений
в  списке ввода/вывода, для передачи только части некоторого
массива или для передачи элементов массива в  последователь-
ности,  отличной  от индексной прогрессии. Этот тип элемента
списка работает так, как будто имеется часть оператора  вво-
да/вывода,  помещенная  в область действия оператора "do", и
управляющая переменная этого подразумеваемого оператора  ис-
пользуется  для определения значения (или значений), которые
должны быть переданы во время итерации цикла.

   Список с циклом имеет следующий вид:

 (k, i=e1,e2[,e3])

 где

k  - список ввода/вывода;

i  - определение управляющей переменной.

   Величины i, e1, e2, e3 имеют такой же самый  вид,  как  в
операторе  "do". Правила для начального и конечного парамет-
ров, а также для шага  и  управляющей  переменной  списка  с
циклом  остаются такими же, как и в случае оператора "do". В
той же степени, в какой позволяют правила пользования опера-
тором  "do", вместо значений начального и конечного парамет-
ров, а также вместо шага,  могут  использоваться  выражения.
Список  может  содержать  обращения к управляющей переменной
при условии, что ее значение не  изменяется.  Областью  дей-
ствия неявного цикла является список.

Например:
       write(4,500)(a,b,c, f=1,3)
       write(6,700)l,m, (i,(j,p(i),q(i,j)
      *,j=1,l),i=1,m)
       read (1,100) ((arr(m,n,i),i=2,9)
      *,n=2,9),m=2,9)

   Определение первой  управляющей  переменной  эквивалентно
самому  внутреннему  оператору  "do"  из множества вложенных
циклов, и, следовательно, эта  переменная  будет  изменяться
чаще. Например, операторы:

      write (5,150) ((fast(k,l),l=1,10)
     *,k=1,10,2)
  150 format (f10.2)

аналогичны следующим операторам:




42

      do 50 k=1,10,2
      do 50 l=1,10
      write (5,150) fast(k,l)
  150 format (f10.2)
   50 continue

Так как внутренний цикл выполняется десять  раз  для  каждой
итерации  внешнего цикла, второй индекс "l" пробегает значе-
ния от одного до десяти для каждого значения первого  индек-
са.  Это является обратным порядком по отношению к индексной
прогрессии. Кроме того, т.к. "k" увеличивается на "2", будут
выведены только четные столбцы массива. Перед очередным уве-
личением управляющей переменной выполняется  передача  всего
списка с неявным циклом. Например:

      read (5,1000) (p(i),
     * (q(i,j),j=1,10),i=1,5)

присваивает введенные значения элементам массивов "p" и  "q"
в следующей последовательности:

        p(1), q(1,1), q(1,2),...,q(1,10),
        p(2), q(2,1), q(2,2),...,q(2,10),
         .      .       .     .     .
         .      .       .     .     .
        p(5), q(5,1), q(5,2),...,q(5,10)

   При обработке многомерных массивов допускается  использо-
вание комбинации из фиксированных индексов и индексов, изме-
няющихся по неявному циклу. Например, оператор:

        read(3,2222) (box(1,j), j=1,10)

присваивает вводимые значения элементам массива от  box(1,1)
до  box(1,10), а затем прекращает ввод, не затрагивая других
элементов данного массива.

   Можно также вывести непосредственно значения  управляющей
переменной, как, например, в операторе:

        write (6,3300)(i,i=1,20)

который выводит на печать целые числа от одного до двадцати.


   5.3.5. Неформатный  ввод/вывод


   Неформатный ввод/вывод представляет собой передачу данных
во  внутреннем (двоичном) формате без преобразования или ре-
дактирования. Неформатный  ввод/вывод  обычно  используется,
когда  выведенные данные из некоторой программы впоследствии
должны быть введены в эту же программу  (или  ей  подобную).
При  неформатном вводе/выводе экономится время выполнения за
счет отказа от процесса преобразования данных, обеспечивает-
ся  большая точность выведеных данных и, как правило, эконо-
мится место, требующееся для хранения файла данных.







                                                          43

   5.3.5.1. Оператор неформатного  ввода 'read'


   Оператор неформатного ввода "read" вводит одну  неформат-
ную  запись с определенного логического устройства и присва-
ивает значения элементов записи элементам списка ввода/выво-
да  без  преобразования  в той последовательности, в которой
они расположены, слева направо. Количество  данных,  присва-
иваемых каждому элементу, определяется его типом данных.

   Оператор неформатного ввода "read" имеет следующий вид:

        read(u)k

   - где

u  - номер логического устройства;

к  - список ввода.

   Оператор неформатного ввода "read" считывает одну запись.

   Оператор "read" с пустым списком не делает ничего.

Пример.

  read(1) form1,form2
c
c Считывает одну запись с логического
c устройства 1, присваивает значения
c переменным "form1" и "form2".
c



   5.3.5.2. Оператор неформатного вывода 'write'


   Оператор неформатного  вывода  "write"  выводит  значения
элементовсписка вывода на определенное логическое устройство
в виде одной неформатной записи; преобразования  данных  при
этом не происходит.

   Оператор неформатного вывода "write" имеет следующий вид:

        write (u) k

  где


u  - номер логического устройства;

k  - список вывода.

   Если список вывода отсутствует, на  указанное  устройство
выводится одна пустая запись.


Пример:

 write(3) (list(i),i=1,5)
c


44

c на логическое устройство 3 выводятся с
c первого по пятый элементы массива "list"
c


П_Р_И_М_Е_Ч_А_Н_И_Е.
     В ОС ДЕМОС записи  выводятся  без  разделителей,  длина
     запрошенной  записи  при  считывании должна совпадать с
     длиной при записи.



   5.3.6. Форматный ввод/вывод


   Операторы форматного ввода/вывода используются в  сочета-
нии  с  операторами "format" (или со спецификациями формата,
хранящимися в массивах) для преобразования и  редактирования
выводимых  данных,  а при вводе для преобразования данных из
внешнего формата во внутренний.


   5.3.6.1. Оператор форматного ввода 'read'


   Оператор форматного ввода "read"  считывает данные с ука-
занного  логического устройства, преобразуя их во внутренний
формат согласно спецификации  формата.  Полученные  значения
присваиваются элементам списка вывода.

   Оператор форматного ввода "read"  имеет вид:

        read(u,f) k

где



u  - номер логического устройства;

f  - указатель формата;

k  - список ввода.

   Если оператор "format", соответствующий оператору формат-
ного  ввода,  содержит  текстовую  константу  или  буквенно-
цифровой литерал, вводимые данные будут считываться и  зано-
ситься непосредственно в список спецификаций.

Пример:

      read (5,1000)
1000  format(6hdata..)
c
c Произойдет считывание шести символов
c и запоминание их на месте текста data..
c в спецификации формата типа "h".
c

   Операторы форматного ввода/вывода читают или пишут записи
определенной  длины в соотвествии с форматом. Запись состоит
из ряда символов КОИ-8, передаваемых под управлением формат-


                                                          45

ной  спецификации, за которыми следует знак разделения запи-
си.

   Если число элементов в списке меньше, чем число полей  во
вводимой записи, оставшаяся часть записи отбрасывается. Если
число элементов в списке ввода превышает число полей во вво-
димом списке, будет указано ошибочное состояние, если только
в спецификации формата не указано, что должны  быть  считаны
дополнительные записи.

   Если  список  ввода  отсутствует,  выполняется   передача
данных между записью и спецификацией формата.

Пример:

      read(1,700) array
700   format(20f8.2)
c
c Считывается  единица записи с логического
c устройства 1; значения полей присваива-
c ются массиву array.
c




   5.3.6.2. Оператор форматного вывода 'write'


   Оператор форматного вывода  "write"  передает  данные  на
указанное  логическое  устройство.  Список вывода определяет
значения, которые преобразуются в символы и  выводятся  сог-
ласно спецификации "format".

   Оператор форматного вывода "write" имеет следующий вид:

        write(u,f) k

где



u  - номер логического устройства;

f  - указатель формата;

k  - список вывода.

   Если список вывода  отсутствует,  выводимые  данные  пол-
ностью определяются спецификациями формата.

   Данные, передаваемые оператором форматного последователь-
ного   вывода  "write",  обычно  составляют  одну  форматную
запись. Однако в спецификации формата  может  быть  указано,
что при выполнении оператора "write" должно порождаться нес-
колько записей.

П_Р_И_М_Е_Ч_А_Н_И_Е.
     В ОС ДЕМОС в качестве разделителя записи служит  символ
     "конец строки" (код 012).




46

Примеры.

c выводит текст 'program' на стандартный
c вывод
      write(6,650)
650   format('program')
c выводит одну запись, состоящую из трех
c полей, на логическое устройство 1
      write(1,95) av,be,ce
95    format(f8.5,f8.5,f8.5)
c
c Вывод трех отдельных записей, по одному
c полю в каждой
c
      write(1,950) av,be,ce
950   format(f8.5)



   5.3.6.3. Оператор 'print'


   Оператор "print" служит для сокращенной записи  оператора
форматного  вывода  на устройство стандартного вывода (логи-
ческий канал 6).

      print f,k

 эквивалентно:

      write(6,f)k




   5.3.7. Вспомогательные операторы ввода/вывода


   Операторы,  относящиеся  к  этой   категории,   выполняют
функции управления файлами.


   5.3.7.1. Оператор 'rewind'


   Оператор "rewind" служит для  установки  указателя  точки
текущей  обработки  открытого последовательного файла на его
начало.

   Оператор имеет следующий вид:

      rewind u
 где

u  - номер логического устройсива.

   Бессмысленно выполнять  операцию  "rewind"  над  внешними
устройствами,  не имеющими файловой структуры, например, над
терминалом.





                                                          47

   5.3.7.2. Оператор 'endfile'


   Оператор "endfile" записывает признак конца файла на ука-
занное устройство.

   Оператор имеет следующий вид:

      endfile u
 где

u  - номер логического устройсива.



   5.3.8. Библиотечные программы


   Для  взаимодействия  с  операционной  системой  ДЕМОС   в
фортране служат специальные библиотечные подпрограммы:

setfil
   - позволяет связать логический канал с файлом ОС ДЕМОС;

ierror
   - позволяет обрабатывать ошибки на этапе выполнения прог-
     раммы;

getarg
   - передает параметры из командной строки ОС ДЕМОС в прог-
     рамму на фортране.

   Подробноеописание этих подпрограмм приведено в приложении
2.


   5.4. Операторы 'format'


   Операторы "format" являются  невыполняемыми  операторами,
используемыми совместно с операторами форматного ввода/выво-
да.

   Оператор "format"  описывает формат, в котором передаются
поля  данных, а также преобразование и редактирование, кото-
рые должны быть выполнены для приведения данных к этому фор-
мату.

   Оператор имеет следующий вид:


метка format(список-спецификаций)


   Список спецификаций может содержать следующие элементы:

   - спецификации  преобразования  или  список-спецификаций,
     заключенный в скобки, перед которыми может быть указано
     число повторений;





48

   - разделительный знак;

   - одна или несколько  наклонных  черт,  которые  являются
     признаком начала новой записи.

   Наличие внешних скобок является обязательным.

   Спецификация преобразования имеет следующий вид:

      [R]cW[.K]

где

R  - коэффициент повторения, который указывает,  что  данная
     спецификация должна быть применена "R" раз подряд; если
     коэффициент повторения  опущен,  он  полагается  равным
     единице.

c  - символ - тип спецификации;

W  - определяет длину поля;

K  - определяет число символов справа от десятичной точки.

   Величины "R", "W", "K" должны быть целыми константами без
знака, не превышающими 255.

   К разделительным знакам  относятся  запятая  и  наклонная
черта.  Наклонная черта, кроме того, служит признаком начала
новой записи.

   В списке спецификаций используются следующие спецификации
преобразования:

   - спецификации целых чисел: iW, oW;

   - логическая спецификация: lW;

   - спецификации вещественных и  с двойной точностью: fW.K,
     eW.K, dW.K, gW.K;

   - литеральные  и  редактирующие  спецификации:  aW,   Nh,
     '...', Nx.

   В буквенно-цифровых и редактирующих спецификациях N опре-
деляет число символов или символьных позиций.

   Каждой из спецификаций типа "f",  "e",  "d"  может  пред-
шествовать масштабный коэффициент в виде:

      Np

где

N  - целая константа с  необязательным  знаком  в  интервале
     -127 - 127; эта константа указывает, на сколько позиций
     влево или вправо сдвигается положение десятичной точки.

   Во время передачи данных выполняется сканирование  списка
спецификаций  слева направо. Величины из списка ввода/вывода
преобразуются под управлением  соответствующих  спецификаций
преобразования.


                                                          49


   В случае спецификаций типа "h" и литеральных спецификаций
обмен  данными происходит между списком спецификаций и внеш-
ней записью.


   5.4.1. Спецификации преобразования


   Спецификации  преобразования  игнорируют  пробелы,  пред-
шествующие  значащей части внешнего поля, а завершающие про-
белы и пробелы внутри поля рассматриваются как нули.

П_Р_И_М_Е_Ч_А_Н_И_Е.
     В этом разделе в качестве знака  пробела  употребляется
     символ "^".


   5.4.1.1. Спецификация 'i'


   Спецификация "i" управляет преобразованием данных  целого
типа. Она имеет следующий вид:

        iW

   Спецификация "i" вызывает считывание оператором ввода "W"
символов  из  внешней  записи и присваивание целого значения
соответствующему целому элементу из  списка  ввода.  Внешние
данные  должны  быть целыми величинами; они не должны содер-
жать ни десятичной точки, ни поля  указателя  степени.  Если
значение  внешнего  поля превышает допустимое значение соот-
ветствующего целого элемента списка, фиксируется ошибка.

   Если первый, отличный от пробела,  символ  внешнего  поля
является знаком "минус", то по спецификации "i" это поле за-
поминается как отрицательная величина. Поле, которому  пред-
шествует знак "плюс", или поле без знака рассматривается как
положительная величина. Например:

 формат  внешнее поле  внутреннее
                      представление
  i4     2788           2788
  i3     -35            -35
  i9     ^^^^^^415      415
  i9     3.12     не допускется; ошибка

   Спецификация "i" вызывает передачу оператором вывода зна-
чения  соответствующего  списка вывода во внешнее поле, име-
ющее длину "W" символов и выравненное справа, причем  незна-
чащие  левые  нули  заменяются  пробелами. Если этот элемент
списка имеет отрицательную величину в качестве первого лево-
го символа, отличного от пробела, во внешнем поле будет знак
"минус". Поэтому в "W" должен учитываться знак  минус,  если
значение  меньше нуля. С другой стороны знак "плюс" не выво-
дится и его не надо учитывать в "W". Если количество  симво-
лов  "W"  слишком мало, чтобы поле вместило запись выводимой
величины, все внешнее поле заполняется звездочками.  Примеры
использования спецификации "i" для оператора вывода:





50

 формат  внутренняя величина  внешнее
                             представление
  i3        284                284
  i4        -284               -284
  i5        174                ^^174
  i2        3244               **
  i3        -473               ***
  i7        29.905   не допускается; ошибка


   5.4.1.2. Спецификация 'f'


   Спецификация "f" определяет преобразование и редактирова-
ние  вещественных  величин,  величин  с двойной точностью, а
также действительных или мнимых частей комплексных  величин.
Она имеет следующий вид:

    fW.K

   При вводе спецификация "f" вызывает считывание "W" симво-
лов  из записи и присваивание их в виде вещественного значе-
ния соответствующему элементу списка ввода. Если первым, от-
личным  от  пробела  символом  во внешнем поле является знак
"минус", значение, записанное в  поле,  рассматривается  как
отрицательная  величина.  Если полю предшествует знак "плюс"
либо если поле не имеет знака, то  оно  считывается  положи-
тельным.  Во всех случаях в записи спецификации "f" величина
"W" должна быть больше или равна величине "K+1".

   Если поле не содержит ни десятичной точки, ни экспоненты,
оно  рассматривается  как  содержащее  запись  вещественного
числа, состоящего из "W" цифр, в котором правые "K" цифр на-
ходятся  справа  от десятичной точки. Если в поле содержится
десятичная точка в явном виде, то величина "K" не принимает-
ся  во внимание. Если поле содержит указание степени, то эта
степень используется в формировании величины  перед  присва-
иванием элементу списка.

   Примеры использования спецификации "f" для преобразования
вещественных величин:

 формат  внешнее поле  внутреннее
                       представление
  f8.5    135679452     135.67945
  f8.5    24.77е+2      2477.0
  f5.2    1234567.89    123.45

   При выводе спецификация "f" вызывает округление  значения
соответствующего  элемента  списка  вывода до "K" десятичных
знаков в дробной части, передачу его во внешнее  поле,  име-
ющее  длину в "W" символов и выравненное справа. Если преоб-
разуемые данные состоят менее чем из "W"  символов,  в  поле
заносятся  левые  пробелы.  Если данные состоят более чем из
"W" символов, все поле заполняется звездочками.

   Общее число символов "W" должно быть  достаточно  велико,
чтобы учесть следующее:

   - наличие знака "минус", если он имеется  (знак  плюс  не
     выводится);



                                                          51

   - как минимум одной цифры слева от десятичной точки;

   - самой десятичной точки;  наличие  "K"  цифр  справа  от
     точки.

   Поэтому величина "W" должна всегда быть больше или  равна
величине "K+3"

   Примеры использования спецификации "f" для редактирования
вещественных величин:

 формат       внутреннее       внешнее
               значение     представление
  f8.5         2.4875189      ^2.48752
  f9.3      8837.4761         ^8837.476
  f2.3        48.51             **
  f10.4      -23.28732        ^^-23.2873
  f5.2       765.014          *****
  f5.2         -.2            -0.20


   5.4.1.3. Спецификация 'e'


   Спецификация "e" определяет передачу вещественных величин
или  величин  с  двойной точностью в экспоненциальной форме.
Она имеет следующий вид:

      eW.K

    Спецификация "e" вызывает ввод оператором ввода "W" сим-
волов из записи. Эти данные интерпретируются и присваиваются
точно таким же образом, как и в случае спецификации "f".

   Примеры использования  спецификации  "e"  для  операторов
ввода:

 формат  внешнее поле        внутреннее
                           представление
  e9.3    689.234e3        689234.0
  e12.4   ^^1042.34e-6       1042.34e-6
  e15.12  52.3759663^^^^^      52.3759663
  e12.5   210.3271d+10        210.3271e10

   Необходимо заметить, что в последнем примере спецификация
"e"  игнорирует  дополнительное назначение признака поля по-
рядка "d", как указателя двойной точности,  и  рассматривает
его, как признак "e".

   Спецификация "e" вызывает передачу оператором вывода зна-
чения  соответствующего  элемента  списка  вывода во внешнее
поле длиной в "W" символов, выравненное по  правой  позиции.
Если  число символов в преобразованных данных меньше "W", то
в левые позиции поля заносятся пробелы. Если число  символов
превышает  "W",  то  все  поле  будет заполнено звездочками.
Соответствующий элемент списка вывода должен быть веществен-
ного, с двойной точностью или комплексного типа.

   Данные, выводимые под управлением спецификации  "e",пере-
даются в стандартной форме, состоящей из знака "минус", если
величина отрицательная (знак "плюс" не выводится), нуля, де-
сятичной  точки, "K" цифр справа от десятичной точки и четы-


52

рехсимвольного порядка числа в виде:

  e+nn   или   e-nn ,

где nn - это двухзначная целая константа.

   "K" цифр справа от десятичной точки представляют  величи-
ну, сведенную к правильной десятичной дроби.

   Так как длина поля должна быть достаточно большой,  чтобы
вместить знак "минус" (если он присутствует), нуль, десятич-
ную точку, порядок и "K"  цифр,  величина  "W"  должна  быть
всегда больше или равна величине (K+7).

   Примеры использования спецификации "e" для операторов вы-
вода:

  формат  внутреннее значение  внешнее
                             представление
   e9.2    475867.233         ^0.48e+06
   e12.5   475867.233         ^0.47587e+06
   e12.3        0.00069       ^^^0.690e-3
   e10.3       -0.5555        -0.556e+00
   e5.3        56.12           *****


   5.4.1.4. Спецификация 'd'


   Спецификация "d" определяет передачу вещественных величин
или величин с двойной точностью. Она имеет следующий вид:

             dW.K

   При вводе спецификация "d" выполняет те же функции, что и
эквивалентная  спецификация  "e",  за  исключением того, что
вводимые данные  преобразуются  и  присваиваются  об'екту  с
двойной точностью, как показано в следующих примерах:

  формат  внешнее поле  внутреннее
                      представление
 d10.2   12345^^^^^  12345000.0d0
 d10.2   ^^123.45^^     123.45d0
 d15.3   367.4571263d+04  3.674571263d+06

   При выводе спецификация "d" работает идентично специфика-
ции "e" за исключением того, что вместо признака порядка "e"
используется признак порядка "d". Например:

  формат  внутреннее   внешнее
           значение  представление
 d14.3      0.0463   ^^^^^0.463d-01
 d23.9  5573.86781 ^^^^^0.557386781d+04
 d9.6       1.2       *********










                                                          53

   5.4.1.5. Спецификация 'l'


   Спецификация "l" определяет передачу  логических  данных.
Она имеет следующий вид:

  lW

   Спецификация "l" вызывает считывание оператором ввода "W"
символов из записи. Если первым, отличным от пробела, симво-
лом в этом поле будет "t", соответствующему элементу  списка
ввода  присваивается значение ".true." (соответствующий эле-
мент списка должен иметь логический тип). Если первым,отлич-
ным от пробела, символом в поле является буква "f" или, если
все поле состоит из пробелов,  то  выполняется  присваивание
значения  ".false.".  Любое  другое значение, находящееся во
внешнем поле, вызывает ошибку.

   Спецификация "l" вызывает передачу во внешнее поле опера-
тором  вывода либо буквы "t", если значение соответствующего
элемента списка равно ".true.", либо  буквы  "f",  если  это
значение  равно  ".false".  Внешнее поле состоит из "W" сим-
вольных позиций. Буквы "t" и "f" записываются в самую правую
позицию этого поля, а остальные позиции заполняются пробела-
ми. Например:

  формат  внутреннее  внешнее
           значение  представление
    l5     .true.    ^^^^t
    l1     .false.       f


   5.4.1.6. Спецификация 'a'


   Спецификация "a"  определяет  передачу  буквенно-цифровых
данных. Она имеет вид:

   aW

   При вводе спецификация "a" вызывает считывание "W" симво-
лов  из записи и запоминание их в формате кода "кои-8" в со-
ответствующем элементе списка (соответствующий элемент спис-
ка  ввода  может иметь любой тип). Максимальное число симво-
лов, которое может быть записано в переменной  или  элементе
массива,зависит от типа этого элемента или переменной.

   элемент списка        максимальное
    ввода/вывода        число символов
   logical*1                1
   logical*4                4
   integer*2                2
   integer                  4
   real                     4
   double precision         8
   complex                  8

   Если "W" больше, чем максимальное число символов, которое
может  быть  записано в соответствующем элементе списка , то
этому об'екту будут присвоены только один, два,  четыре  или
восемь  самых  правых символов (в зависимости от типа данных
этой переменной или элемента массива); избыточные левые сим-


54

волы при этом теряются. Если "W" меньше, чем число символов,
которые могут быть записаны в данном  об'екте,  то  элементу
списка  будут  присвоены  слева "W" символов, а в оставшиеся
незаполненными правые символьные позиции занесутся пробелы.

   Примеры преобразования буквенно-цифровых данных при вводе
по спецификации "a":

 формат внешнее поле   внутреннее
                    представление
   a6    page^*     *        (logical*1)
   a6    page^*    ^*        (integer*2)
   a6    page^*    ge^*      (real)
   a6    page^*    page^*^^  (double)

   При выводе спецификация "a" вызывает передачу содержимого
соответствующего  элемента вывода во внешнее поле, состоящее
из "W" символьных позиций. Если элемент списка вывода содер-
жит  менее "W" символов, данные записываются выравненными по
правой позиции, а в оставшиеся левые позиции заносятся  про-
белы.  Если  элемент  списка содержит более "W" символов, то
будут переданы только старшие "W" символов.

   Примеры преобразования буквенно-цифровых данных при выво-
де по спецификации "a":

 формат   внутреннее   внешнее
           значение   представление
  a5       beta          ^beta
  a5       volts^^^^     volts
  a5       alphaes^      alpha


   5.4.1.7. Спецификация 'h'


   Спецификация "h" имеет вид текстовой константы:

        Nhc1c2c3...cn

Где

N  - определяет число символов, которые должны быть  переда-
     ны;

c  - символ кода "КОИ-8".

   Спецификация "h"  вызывает  считывание  оператором  ввода
"N"  символов  из  записи и помещение их в спецификацию "h",
причем первый символ помещается  непосредственно  за  буквой
"h". Любые символы, находящиеся до выполнения ввода в специ-
фикации, могут быть заменены вводимыми символами.

   При выполнении оператора вывода спецификация "h" вызывает
передачу  "N"  символов, непосредственно следующих за буквой
"h" в спецификации, во внешнюю запись.

   Вместо спецификации "h" может быть использован  буквенно-
цифровой  литерал. Его функции идентичны функциям специфика-
ции "h".




                                                          55

   5.4.1.8. Спецификация 'x'


   Спецификация "x" имеет следующий вид:

          Nx

   По этой спецификации оператор write засылает "N" пробелов
во внешнюю запись. Например:

      write(6,100) npage
  100 format(12hpage^number    ,
     * i2,4x,7hgraphik)

Оператор "write" напечатает запись следующего вида:

 page number nn    graphik

где "nn" - это текущее значение переменной "npage". При вво-
де  по этой спецификации будет пропущено "N" знаков вводимой
записи, начиная от текущей позиции.


   5.4.2. Редактирование комплексных данных


   Так как комплексная величина представляет собой пару  ве-
щественных величин, ввод и вывод комплексного об'екта управ-
ляется двумя спецификациями вещественного формата, используя
любую комбинацию из спецификаций "fW.K", "eW.K", "dW.K" .

   При вводе два последовательных поля считываются и присва-
иваются   комплексному  элементу  списка  ввода,  как  соот-
ветственно его действительная и мнимая части. Например:

   формат  внешние    внутреннее
            поля     представление
        2374512346735.76
  f8.5,f8.5          237.45123,46735.76
        563.472e7271348690
  e9.1,f9.3          563.472e7,27134.869

   Привыводе составные части комплексной величины передаются
под  управлением повторенных или последовательных специфика-
ций. Между этими частями не включаются никакие  разделители,
если  в  списке  спецификаций не используется дополнительная
спецификация. Например:

  формат      внутреннее   внешнее
               значение   представление

   2f8.5       3.2567189  ^3.25672^4.35263
               4.352632

e9.2,'^,^',e5.3 56789.323 ^0.57e+05^,^*****
                32.114








56

   5.4.3. Масштабный коэффициент


   С помощью масштабного коэффициента при  выполнении  ввода
или  вывода может быть изменено положение десятичной точки в
вещественных величинах с двойной  точностью  и  в  составных
частях  комплексных  величин.  Масштабный  коэффициент имеет
следующий вид:

   Np

где N - целая константа со знаком или без, лежащая в  диапо-
зоне от -127 до +127, определяющая число позиций, на которое
должна быть сдвинута десятичная точка вправо или влево.

   Масштабный коэффициент может встречаться  в  любом  месте
списка  спецификаций, но он должен предшествовать специфика-
ции, к которой он относится. Допускаются следующие записи:

 NpfW.K    NpeW.K   NpdW.K   NpgW.K

   Данные, введенные под управлением одной из  вышеприведен-
ных  спецификаций,  перед  их присваиванием соответствующему
элементу списка ввода/вывода умножаются на 10**(-N).  Напри-
мер,  масштабный коэффициент "2p" вызывает умножение введен-
ной величины на 0.01, перемещая десятичную точку на две  по-
зиции влево; а масштабный коэффициент "-2p" вызывает умноже-
ние введенной величины на 100, перемещая десятичную точку на
две позиции вправо. Если же внешнее поле содержит показатель
степени в явном  виде,  масштабный  коэффициент  вычитается.
Например:

  формат    внешнее поле    внутреннее
                           представление
  3рe10.5   ^^^47.518^        .047518
  3рe10.5   ^^47.518e5    4751.8
 -3рe10.5   ^^^^47.518   47518.0

   Влияние масштабного коэффициента при  выводе  зависит  от
типа  спецификации, которой он соответствует. Для специфика-
ции "f" значение элемента списка ввода/вывода перед  переда-
чей во внешнюю запись умножается на 10**N. Таким образом по-
ложительный  масштабный  коэффициент  перемещает  десятичную
точку вправо, а отрицательный масштабный коэффициет - влево.

   Величины, выводимые под управлением  спецификации  "e"  и
"d"  с масштабным коэффициентом, преобразуются умножением на
10**N вещественной константы, входящей в состав каждой вели-
чины, и вычитанием "N" из ее порядка.

   Таким образом положительный масштабный коэффициент  пере-
мещает  десятичную точку вправо и уменьшает порядок, а отри-
цательный масштабный коэффициент перемещает десятичную точку
влево и увеличивает порядок.

   Необходимо отметить, что при вводе и выводе под  управле-
нием  спецификации "f" масштабный коэффициент фактически из-
меняет величину данных, а при выводе под управлением  специ-
фикации  "e", "d" масштабный коэффициент всего лишь изменяет
форму, в которой передаются данные. При вводе  положительный
масштабный  коэффициент перемещает десятичную точку влево, а
отрицательный масштабный коэффициент - вправо,  в  то  время


                                                          57

как при выводе - наоборот.

   Если в спецификации не указан масштабный коэффициент,  то
он  считается  равным  нулю. Если масштабный коэффициент был
один раз определен, то он влияет на последующие спецификации
вещественных  и  с двойной точностью преобразований, которые
находятся в этом же списке спецификаций до тех пор, пока  не
встретится  другой  масштабный коэффициент, который изменяет
управление. Повторная форматизация не влияет  на  масштабный
коэффициент.  Нулевой  коэффициент  может  быть восстановлен
только явной спецификацией 0p.

   Примеры влияния масштабного коэффициента при выводе:

   формат      внутреннее    внешнее
                значение   представление
   1pe12.3     -480.148    ^^-4.801e+02
   1pe12.2     -480.148    ^^^-4.80e+02
  -1pe12.2     -480.148    ^^^-0.05e+04


   5.4.4. Группирование и повторяемые группы


   Ряд одинаковых, расположенных друг за другом спецификаций
в  формате  можно заменить одной спецификацией с предшеству-
ющим ей коэффициентом повторения.  Такое  об'единение  можно
производить  для  спецификаций  "i",   "f", "e",  "d", "l" и
"a".  Коэффициентом  повторения  может  быть  только   целая
константа без знака. Например, операторы:

 30   format(e10.3,e10.3,i4,i4,i4,i4)

и

 30   format (2e10.3,4i4)

идентичны.

   Аналогично допускается  повторение  группы  спецификаций,
если  ее заключить в скобки и перед открывающей скобкой пос-
тавить целую  константу,  означающую  количество  повторений
этой группы. Например, оператор

   77 format (2i5,2(f4.3,e12.5))

эквивалентны оператору

   77 format(i5,i5,f4.3,e12.5,f4.3,e12.5)

   Спецификации "h" и "t", которые обычным образом не  могут
быть повторены, можно заключить в скобки и рассматривать как
повторяемую группу. Таким образом они могут  быть  повторены
нужное число раз.

   Если коэффициент повторения группы опущен, он  подразуме-
вается равным единице.







58

   5.4.5. Разделительные знаки списка спецификаций


   Спецификации преобразования в  списке  спецификаций,  как
правило,  отделяются  друг от друга запятыми. Для разделения
спецификаций может также использоваться наклонная черта  "/"
-  признак начала новой записи. Наклонная черта вызывает за-
вершение вводимой или выводимой записи и инициирование новой
записи. Например, запись:

      write(6,70) i,l,n,m,o,p
   70 format (306/i5,2f4.2)

эквивалентна следующей:

      write (6,70) i,l,n
   70 format (306)
      write (6,40) m,o,p
   40 format (i5,2f4.2)

   С помощью  нескольких,  идущих  подряд  признаков  начала
новой  записи,  можно  выполнить пропуск нескольких вводимых
записей или вывод нескольких пустых записей. Если между дву-
мя спецификациями преобразования расположены n идущих подряд
наклонных черт, то это вызовет  пропуск  (n-1)  записей  при
вводе  или выдачу (n-1) пустых (состоящих из пробелов) запи-
сей т.е. пустых строк при выводе. Первая наклонная черта за-
канчивает текущую запись, вторая наклонная черта заканчивает
первую пропускаемую или пустую запись и так далее. Но если n
подряд  расположенных  черт встречаются в начале или в конце
списка спецификаций, они вызывают n пропущенных  или  пустых
записей, т.к. открывающая или закрывающая скобки списка спе-
цификаций являются признаком начала новой записи и признаком
завершения записи. Например, операторы:

   write (5,10)
10 format ("temporary"//,"result"//)

   выполняет следующий вывод:

       temporary
 (пустая строка)
 (пустая строка)
       result
 (пустая строка)
 (пустая строка)


   5.4.5.1. Разделители внешних полей


   Спецификация преобразования определяет, что оператор вво-
да  должен считать "W" символов из внешней записи. Если поле
данных в рассматриваемом случае содержит менее "W" символов,
оператор  ввода  считает  несколько  символов  из следующего
поля, если только короткое поле не будет расширено  за  счет
левых  незначащих  нулей или пробелов. Для того, чтобы избе-
жать необходимости этого расширения, вводимое поле, содержа-
щее  менее "W" символов, может быть завершено запятой, кото-
рая отменяет значение ширины поля по спецификации преобразо-
вания. Такая методика называется завершением короткого поля.
Она удобна при вводе данных с клавиатуры терминала. Методика


                                                          59

применима  к спецификациям "i",  "f", "e", "d" и "l". Напри-
мер:

   read (5,40) m,n,a,b
40 format (2i6,2f10.2)

   Если внешняя единица записи, вводимая по этим операторам,
имеет следующий вид:

 1,-3,1.0,47

то будет выполнено следующее присваивание значений:

    м = 1
    n = -3
    a = 1.0
    b = 0.47

   Необходимо отметить, что физический  конец  записи  также
служит  ограничителем  поля. Часть "K" спецификации "W.K" не
отменяется, как это видно из присвоения значения  переменной
"b".

   Запятой могут быть завершены только те поля, которые  со-
держат  менее  "W" символов. Если за полем, состоящем из "W"
или более символов, следует запятая, то она  рассматривается
как часть следующего поля.

   Две идущие  подряд  запятые  или  запятая,  следующая  за
полем, содержащим ровно "W" символов, образуют нулевое (име-
ющее нулевую длину) поле. В зависимости  от  соответствующей
спецификации будет присвоено одно из следующих значений:

 0, 0.0, 0d0 или .false.

   Запрещается использование запятой для  завершения  полей,
которые  должны  быть  считаны  под управлением спецификаций
"a","h" или спецификаций в виде буквенно-цифровых литералов.
Но  если физический конец записи обнаруживается до того, как
будут считаны "W" символов,то выполнится завершение коротко-
го  поля  и символы будут введены и присвоены обычным спосо-
бом. В этом случае в незаполненные последние  позиции  соот-
ветствующего элемента списка ввода или спецификации преобра-
зования будут занесены пробелы.


   5.4.5.2. Переменный список спецификаций


   Списки спецификаций могут  храниться  в  массивах.  Такой
список  спецификаций (называемый переменным списком специфи-
каций) может быть построен или изменен  непосредственно  при
выполнении  программы.  Вид  списка  спецификаций  в массиве
идентичен оператору "format" за исключением того, что в  нем
отсутствуют слово "format" и метка оператора. Однако наличие
открывающей и закрывающей скобок является обязательным.

   Пример переменного списка спецификаций:






60

   real fact(5,5)
   double precision form(6),rec,fest,feb,sml
   data form(1),reg,fest,feb,sml/"(",")","f8.2",
&  f9.4,","f9.6"/
   do 30 j=1,5
   do 31 i=1,5
   if (fact(i,j).lt.100.and.fact(i,j).gt.0.1)
&  form(i+1)=feb
   if (fact(i,j).ge.100.)form(i+1)=fest
   if (fact(i,j).le.0.1) form(i+1)=sml
31 continue
   form(i+1)=reg
   write(5,form) (fact(k,j),k=1,5)
30 continue
   end

   В этом примере  оператор  "data"  присваивает  код  левой
скобки  первому  элементу  массива "form" и присваивает коды
правой скобки и три спецификации переменным для последующего
использования. Затем выбираются соответствующие спецификации
для включения их в список спецификаций, исходя  из  значений
отдельных  элементов массива "fast". Затем списку специфика-
ций перед его использованием в операторе "write" добавляется
правая  скобка. Таким образом список спецификаций изменяется
с каждым повторением цикла оператора "do".


   5.4.6. Взаимодействие  управления  форматом  и  списка
          ввода/вывода


   Управление форматом инициируется началом выполнения  опе-
ратораформатного ввода/вывода. Каждое действие по управлению
форматом зависит от  информации,  предоставляемой  совместно
очередным  элементом списка ввода/вывода (если он имеется) и
очередной спецификацией оператора "format" или массива,  со-
держащего  список спецификаций. Как список спецификаций, так
и список  ввода/вывода  просматривается  слева  направо  (за
исключением случаев повторений).

   Если оператор ввода/вывода содержит список  ввода/вывода,
то  в списке спецификаций должна иметься хотя бы одна специ-
фикация преобразования, отличная от спецификаций  типа  "a",
"x"  и "p". Если это условие не выполняется, то при выполне-
нии программы фиксируется ошибка.

   При выполнении оператора форматного ввода считывается од-
на  запись с указанного устройства и инициируется управление
форматом; после этого могут быть считаны дополнительные  за-
писи, как указано в списке спецификаций. Управление форматом
требует ввода новой записи всякий раз, когда в списке специ-
фикаций  встречается  наклонная  черта или когда достигается
последняя внешняя закрывающая скобка списка спецификаций,  а
в списке ввода еще остались незаполненные элементы. При счи-
тывании новой записи теряются все оставшиеся символы текущей
записи.

   При выполнении оператора форматного вывода запись переда-
ется на указанное устройство только по завершении управления
форматом. Возможен также вывод нескольких записей при выпол-
нении управления форматом, если в списке спецификаций встре-
тится наклонная черта или если достигается последняя внешняя


                                                          61

закрывающая  скобка, а в списке вывода еще имеются элементы,
подлежащие выводу.

   Каждая спецификация типа "i",  "f", "e", "d",   "l",  "a"
соответствуют  одному элементу списка ввода/вывода. Специфи-
кациям "h",  "x",  "p"   и  спецификации  в  виде  буквенно-
цифрового  литерала  не ставится в соответствие ни один эле-
мент списка. В случае спецификации типа "h" или спецификации
в  виде  буквенно-цифрового  литерала  передача  данных осу-
ществляется непосредственно между записью и списком специфи-
каций.

   Если управление форматом обнаруживает  спецификацию  типа
"i",  "f", "e", "d",  "l", "a" , то определяется наличие со-
ответствующего элемента в списке  ввода/вывода.  Если  такой
элемент имеется, то управление форматом осуществляет переда-
чу соответствующим образом преобразованных данных между  за-
писью и элементом списка, а затем переходит к обработке сле-
дующей спецификации (если не  требуется  повторения  текущей
спецификации). Если же соответствующего элемента в списке не
обнаружено, то управление форматом завершается.

   При достижении последней закрывающей скобки списка специ-
фикаций  управление  форматом  определяет,  имеются ли еще в
списке ввода/вывода элементы, подлежащие обработке. Если та-
ковых  не  имеется,  управление форматом завершается. Если в
списке ввода/вывода остались необработанные элементы, то те-
кущая запись завершается, а управление форматом возвращается
к самой правой повторяемой группе спецификаций самого  высо-
кого  уровня  (открывающая  скобка которой составляет пару с
предпоследней закрывающей скобкой списка спецификаций). Этот
принцип  известен  как повторная форматизация. Если в списке
спецификаций  отсутствуют  повторяемые   группы,  управление
форматом вернется к начальной открывающей скобке списка спе-
цификаций. Действия по управлению форматом будут  продолжены
с этой точки.


   5.4.7. Сводка правил для оператора 'format'


   В этом пункте приводится перечень  правил,  связанных  со
структурой и использованием оператора "format" (или массива,
содержащего список спецификаций) и его составных  частей,  а
также  правил, связанных со структурой внешних полей и запи-
сей, с которыми взаимодействует список спецификаций.


   5.4.7.1. Общие правила


   Правило 1. Оператор  "format"  обязательно  должен  иметь
метку.

   Правило 2. В спецификациях, таких  как  "RiW"  или  "Nx",
члены  "R",  "W"  и  "N"  должны  быть целыми положительными
константами без знака. Коэффициент повторения и спецификация
ширины поля могут быть опущены.

   Правило 3. В спецификациях, таких  как  "fW.K",  величина
"K" должна быть целой константой без знака. Она обязана при-
сутствовать в спецификациях "f", "e",  "d",  даже  если  она


62

равна  нулю.  Присутствие точки также является обязательным.
Спецификация ширины поля "W" должна быть  больше  или  равна
"K". Величины "W" и "K" должны либо обе присутствовать, либо
обе быть опущены.

   Правило 4. В  спецификации  преобразования  "Nhc1c2...cn"
после  кода спецификации "h" должно присутствовать ровно "N"
символов. В этой  спецификации  может  присутствовать  любой
символ  кода  кои-8  без  русских  букв (спецификация в виде
буквенно-цифрового литерала подчиняется тому же правилу).

   Правило 5.  В  масштабном  коэффициенте  вида  "mp",  "m"
должно быть целой константой со знаком или без него, лежащей
в диапозоне от -127 до +127 включительно. Масштабный коэффи-
циент  применяется  только  к  спецификациям  "f", "e", "d".
Будучи один раз определен, масштабный коэффициент  действует
на все последующие спецификации из списка спецификаций. Дей-
ствие этого  масштабного  коэффициента  прекращается,  когда
встречается  другой  масштабный коэффициент. Для того, чтобы
восстановить нулевой масштабный коэффициент, надо явно опре-
делить  его в виде "0p". Повторная форматизация не оказывает
влияния на масштбный коффициент.

   Правило 6. Не допускается использование коэффициента пов-
торения перед спецификациями "h",  "t" и перед спецификацией
в виде буквенно-цифрового литерала за исключением тех случа-
ев, когда эти спецификации заключены в скобки и рассматрива-
ются как повторяемая группа спецификаций.

   Правило 7. Если в операторе ввода/вывода  имеется  список
ввода/вывода,  то  список  спецификаций содержит как минимум
одну спецификацию, отличную от спецификаций "h",  "x",  "p",
"t" и буквенно-цифровых литералов.

   Правило 8. Список  спецификаций  в  массиве  должен  быть
построен  также,  как  и  список  спецификаций  в  операторе
"format", включая открывающую и закрывающую скобки. При  ис-
пользовании  идентификатора  массива со списком спецификаций
вместо оператора "format" этот идентификатор не должен  быть
индексирован.


   5.4.7.2. Правила для ввода


   Правило 1. Внешнему полю вводимых данных, содержащему от-
рицательную  величину,  должен  предшествовать знак "минус".
Наличие знака "плюс" перед записью  положительного  значения
не является обязательным.

   Правило 2. Внешнее поле, преобразование которого при вво-
де  выполняется  под  управлением  спецификации  "i", должно
иметь формат целой константы.

   Правило 3. Внешнее поле, преобразование которого при вво-
де  выполняется  под  управлением  спецификаций  "f" или "e"
должно иметь формат целой или  вещественной  константы,  или
константыс двойной точностью. Оно может содержать десятичную
точку и/или поле показателя степени типа "e" или "d".

   Правило 4. Если внешнее поле содержит  десятичную  точку,
то  фактический  размер дробной части поля, указываемый этой


                                                          63

точкой, переопределяет для этого поля  спецификацию  "K"  из
соответствующей спецификации действительного преобразования.

   Правило 5. Если внешнее поле содержит показатель степени,
это вызывает игнорирование масштабного коэффициента (если он
имеется) при выполнении преобразования этого поля.

   Правило6.  Спецификация длины поля должна быть достаточна
велика  для  того,  чтобы  охватить кроме последовательности
цифровых символов внешнего поля и  другие  символы,  которые
могут  в нем присутствовать (алгебраический знак, десятичная
точка и/или признак показателя степени).

   Правило 7. Единственным символом, который может использо-
ваться как внешний разделитель записи, является запятая. Она
используется для завершения ввода полей, которые короче, чем
это указывается в спецификации, а также для формирования ну-
левых (имеющих нулевую длину) полей.



   5.4.7.3. Правило для вывода


   Правило 1. Список спецификаций не должен  задавать  вывод
большего  числа  символов,  чем  их  может содержать внешняя
запись (например, единица записи устройства печати не  может
содержать больше 133 символов, включая символ управления ка-
реткой).

   Правило 2. Спецификация длины поля "W" должна быть доста-
точно велика, чтобы охватить все символы, которые могут быть
сформированы при выводе, включая алгебраический знак,  деся-
тичную  точку и признак показателя степени. Например, специ-
фикация длины поля в спецификации преобразования "e"  должна
быть достаточно велика, чтобы поле вмещало (K+7) символов.


   5.5. Операторы описания


   Эти операторы являются  невыполняемыми  операторами.  Они
обеспечивают  транслятор  информацией,  необходимой для пра-
вильного размещения переменных и массивов и задания  их  на-
чальных  значений,  а также определяют другие характеристики
символических имен, используемых в программе.


   5.5.1. Оператор 'implicit'


   Оператор "implicit" переопределяет неявное  задание  типа
идентификаторов, согласно которому все идентификаторы, начи-
нающиеся с букв "i", "j", "k", "l", "m" и "n" предназначают-
ся  для  представления целых данных. Идентификаторы, начина-
ющиеся с любой другой буквы, предназначены для  вещественных
данных.

   Оператор "implicit" имеет следующий вид:





64

 implicit typ(a[,a]...)[,typ(a[,a]...)]...

Или

                  implicit typ/a[,a]...]...

Где

typ
   - один из следующих дескрипторов типа данных:

  integer
  integer*2
  real
  real*8
  double precision
  complex
  logical
  logical*1

a  - буквенная спецификация вида:

  c или c1-c2

c  - буквенный символ.

   Последняя форма  определяет  последовательность  букв  от
"c1" до "c2" включительно, которые должны быть расположены в
алфавитном порядке. Оператор "implicit" присваивает  опреде-
ленный  тип данных всем идентификаторам, начинающимся с ука-
занной буквы или с любой из букв указанной последовательнос-
ти. При этом тип данных присваивается только тем идентифика-
торам, у которых он не был описан явным  образом.  Например,
операторы:

     implicit integer (i,j,к,l,m,n)
     implicit real    (a-g,p-z)

представляют стандартные описания типа при отсутствии других
описателей типа данных.

   Операторы "implicit" не должны иметь меток.

   Примеры:

     implicit double precision q
     implicit real (s,y),
&    logical*1 (b,a-c)


   5.5.2. Операторы описания типа


   Операторы описания типа явным образом определяют тип ука-
занных идентификаторов.

   Оператор описания типа имеет следующий вид:







                                                          65

     typ v[,v]...
 Где

typ
   - один из  дескрипторов типа данных;

v  - идентификатор  переменной,  массива,  оператора-функции
     или дескриптор массива.

   Оператор описания типа вызывает присваивание  идентифика-
тору определенного типа. Он переопределяет тип данных, неяв-
но определяемый первой буквой идентификатора.

   Операторописания типа может определять массивы включением
в его список дескрипторов массивов. В каждом программном мо-
дуле идентификатор массива может появляться только один  раз
в дескрипторе массива.

   Идентификатору может приписываться справа указатель длины
типа  данных, имеющий вид "*s", где "s" - одна из допустимых
длин для об'явленного типа данных. Такая запись  переопреде-
ляет  для  того элемента, к которому она относится, характе-
ристику длины, указанную оператором. Например:

      integer*2 l, i, j, m12*4,
&     s, iven*4(10)
      real*8 zx1, zwx,
&     wx2*4, wx4, wx1*8

   Операторы описания типа должны предшествовать всем выпол-
няемым операторам и всем операторам описания "implicit". Они
обязаны указываться до первого употребления любых  идентифи-
каторов, которые они определяют.

   Тип данных каждого идентификатора может быть описан явным
образом только один раз.

   Операторы описания типа не должны иметь меток. Например:

     integer cart, mas(4,4), res
     real mes, item
     logical option


   5.5.3. Оператор 'dimension'


   Оператор "dimension"  определяет  размерность  массива  и
число элементов в каждом измерении.

   Оператор "dimension" имеет следующий вид:

      dimension a(d)[,a(d)]...

где

a  - идентификатор массива;

d  - значение индекса.

   Каждое выражение  "a(d)"  представляет  собой  дескриптор
массива.


66


   Оператор "dimension" отводит некоторое число областей па-
мяти  по одной для каждого элемента каждого массива, указан-
ного в операторе. Каждая область памяти состоит  из  одного,
двух, четырех или восьми байтов в зависимости от типа данных
массива. Общее число областей памяти, отводимых для массива,
 равно произведению всех значений индексов из описания этого
массива. Например, запись

  dimension count(4,4), mas(5,5,5)

Определяет массив "count", как 16 вещественных элементов  по
два  слова  каждый,  и  массив  "mas", как имеющий 125 целых
эементов по одному слову каждый.

   Дескрипторы массивов могут также встречаться в операторах
описания  типа и "common", но внутри одного программного мо-
дуля идентификатор массива может встретиться только в  одном
описании массива.

   Оператор "dimension" не должен иметь метки.

   Например:

      dimension bal(7,8,12)
      dimension a(4,4,4),b(2,19),c(50)
      dimension mas(3,3,3,3)


   5.5.4. Оператор 'common'


   Оператор "common" определяет одну или  более  непрерывных
областей,   которые   называются   общими  блоками  (блоками
common). Блоку common может в операторе common быть  присво-
ено  имя.  Такие  блоки называются именованными. Если имя не
задано, блок называется неименованным общим блоком. Оператор
"common"  также  определяет  порядок следования переменных и
массивов, составляющих каждый общий блок.

   Допускается обращение к данным общего блока из  различных
программных  модулей по одному и тому же идентификатору бло-
ка.

   Оператор "common" имеет следующий вид:

      common [/[a]/k] [[,]/[a]/k]...

где

a  - идентификатор, являющийся именем общего блока, или про-
     бел;  если  первый идентификатор опущен, то первая пара
     наклонных черт также может быть опущена;

k  - список идентификаторов переменных, идентификаторов мас-
     сивов и дескрипторов массивов, разделенных запятыми.

   Идентификатор общего блока в выполняемой программе  может
быть  таким же, как идентификатор переменной или массива, но
не должен совпадать с идентификатором функции  или  подпрог-
раммы  или  с  идентификатором  точки  входа  в  функцию или
подпрограмму.


                                                          67


   При компоновке выполняемой  программы  все  общие  блоки,
имеющие одно и то же имя в разных программных модулях, будут
размещены в к одной и той же области памяти.

   Ввиду того, что занесение элементов в общий блок выполня-
ется  последовательно один за другим, то элементы, об'явлен-
ные в операторе "common" в одном программном  модуле  должны
соответствовать по типу данных элементам, помещаемым в общий
блок в другом программном модуле. Например, если один  прог-
раммный модуль содержит оператор

         common count

а другой программный модуль содержит оператор

         integer*2 mores
         common mores

то может получиться некорректный результат, так  как  однос-
ловная  переменная  "mores"  поставлена  в  соответствие ве-
щественной переменной "count", представленной большим  коли-
чеством слов.

   Следует обращать  внимание  на  внесение  элементов  типа
"logical*1" или integer*1 в общий блок, чтобы обеспечить вы-
равнивание по границе слова данных любых других типов,  раз-
мещаемых после данных "logical*1" или "integer*1". Все общие
блоки начинаются в памяти с границы слова (с  четного  адре-
са).

   Примеры:

c    головная программа
     common het,x/blk/item,q
              .
              .
              .
     call sum
              .
              .
     end
c    подпрограмма
     subroutine scm
     common/blk/lero,r//a,b
             .
             .
     return
     end


Оператор "common" в головной программе помещает "het" и  "x"
в  неименованный общий блок и помещает "item" и "q" в имено-
ванный блок "blk". Операторы "common" в  подпрограмме  уста-
навливают  соответствие  между  "a"  и  "b" с одой стороны и
"het"  и "x" с другой стороны в неименованном блоке, а также
между  "lero"  и "r" с одной стороны и "item" и "q" с другой
стороны в общем блоке "blk".






68

   5.5.4.1. Именованный и неименованный общие блоки


   Во всей выполняемой программе может быть только один  не-
именованный  общий  блок.  Операторы "common" могут быть ис-
пользованы для построения  любого  числа  именованных  общих
блоков.

   Переменным из именованного и неименованного блоков  можно
присваивать начальные значения оператором "data".


   5.5.4.2. Операторы 'common' с дескрипторами массивов


   В операторе  "common"  могут  использоваться  дескрипторы
массивов.  Идентификаторы массивов не должны быть индексиро-
ваны (не допускается приписывание к общему  блоку  отдельных
элементов  массива). В программном модуле идентификатор мас-
сива может встретиться только в одном дескрипторе массива.


   5.5.5. Оператор 'equivalence'


   Оператор "equivalence" описывает два или  более  об'ектов
как  размещаемые  (полностью  или частично) в одной и той же
области памяти. Операторы "equivalence" работают с элемента-
ми, находящимися в одном о том же программном модуле.

   Оператор "equivalence" имеет следующий вид:

     equivalence (k1)[,(k2)]...

где

ki
   - список переменных и элементов массивов, разделенных за-
     пятыми; в каждом списке должны присутствовать как мини-
     мум два об'екта.

   Оператор "equivalence" вызывает такое распределение памя-
ти,  что  все элементы из списка в скобках будут размещаться
начиная с одной и той же ячейки оперативной памяти.  Необхо-
димо заметить, что если установить эквивалентность целой ве-
личины с какой-нибудь вещественной величиной,  то  при  этом
они разделяют старшее слово области вещественной переменной.
Смешивание подобным образом различных типов данных  является
допустимым.  Несколько  элементов  одного  типа данных могут
разделять память с одним элементом, имеющим тип данных более
высокого ранга. Например:

      double precision den
      integer*2 ias(4)
      equivalence (den,ias(1))

Оператор "equivalence" вызывает такое распределение  памяти,
при котором четыре элемента массива занимают ту же самую об-
ласть памяти, что и переменная с двойной точностью "den".

   Оператор "equivalence"  может  также  использоваться  для
указания  эквивалентности идентификаторов переменных. Напри-


                                                          69

мер, оператор:

      equivalence (f1,f2,f3)

устанавливает эквивалентность  идентификаторов  "f1",  "f2",
"f3" при условии, что они имеют одинаковый тип данных.

   Оператор "equivalence" в подпрограмме не должен содержать
формальных параметров.

Примеры:

      equivalence (a,b),(b,c)
c     выполняется так же, как
c     оператор
c     "equivalence (a,b,c)";
c
      equivalence (b(1),x), (b(2),y), (b(3),z)


   5.5.5.1. Установление эквивалентности массивов


   При установлении эквиалентности  между  двумя  элементами
разных  массивов  оператор "equivalence" также устанавливает
эквивалентность между остальными сответствующими  элементами
этих двух массивов. Таким образом, если первые элементы двух
массивов одной размерности эквивалентны, то оба массива  це-
ликом разделяют одну область памяти. Если третий элемент пя-
тиэлементного массива сделан эквивалентным первому  элементу
другого  массива,  то последние три элемента первого массива
совпадают в памяти с первыми тремя элементами второго масси-
ва.

   Оператор "equivalence" не может выделить одну и ту же об-
ласть  памяти двум или нескольким элементам одного и того же
массива. Запрещаются также любые присваивания областей памя-
ти,  нарушающие нормальное последовательное запоминание эле-
ментов массива  в  памяти  (например,  установление  эквива-
лентности  между двумя первыми элементами разных массивов, а
затем попытка установления эквивалентности между вторым эле-
ментом одного массива и шестым элементом другого).

   В операторе "equivalence" (и только  в  нем)  допускается
указание элемента массива по одному индексу (т.е. последова-
тельному номеру элемента), даже если этот массив был опреде-
лен как многомерный.

   Например, операторы:

      dimension tom(2,2),ter(2,2,2)
      equivalence (tom(4),ter(7))

вызовут разделение всем массивом "tom" части области памяти,










70

предназначенной для массива "ter", как показано в табл. 4

                                                  Таблица 4.
                  Размещение двух массивов
 ----------------------------------------
 !    массив "ter"   !     массив "том" !
 !---------!---------!----------!-------!
 ! элемент ! номер   ! элемент  !номер  !
 ! массива ! элеm. в ! массива  !элем. в!
 !         ! массиве !          !массиве!
 !---------!---------!----------!-------!
 !ter(1,1,1)   1     !          !       !
 !ter(2,1,1)   2     !          !       !
 !ter(1,2,1)   3     !          !       !
 !ter(2,2,1)   4     ! tom(1,1) !  1    !
 !ter(1,1,2)   5     ! tom(2,1) !  2    !
 !ter(2,1,2)   6     ! tom(1,2) !  3    !
 !ter(1,2,2)   7     ! tom(2,2) !  4    !
 !ter(2,2,2)   8     !          !       !
-----------------------------------------

Табл. 4 показывает, что операторы

    equivalence (tom(1),ter(4))
  и
      equivalence (ter(1,2,2),tom(4))

в результате дают одно и то же размещение двух масивов.


   5.5.5.2. Взаимодействие    операторов    'common'    и
            'equivalence'


   При установлении эквивалентности между некоторым  элемен-
том  и об'ектом, хранящимся в общем  блоке, общий блок может
быть  расширен  за  его  первоначальные  границы.   Оператор
"equivalence" может расширить общий блок только за счет рас-
ширения области за последний элемент предварительно  постро-
енного  общего блока (но не за счет помещения дополнительной
области перед первым элементом существующего общего блока).

   Пример допустимого расширения общего блока:

    dimension c(4),e(6)
    common c
    equivalence (c(2),e(1))
 существующий общий блок область расширения
 c(1)  c(2)  c(3)  c(4)
       e(1)  e(2)  e(3)  e(4)  e(5)  e(6)

   Пример недопустимого расширения общего блока:

      dimension c(4), e(6)
      common c
      equivalence (c(2),e(3))

   область   существующий       область
 расширения  общий блок         расширения

           c(1) c(2) c(3) c(4)
      e(1) e(2) e(3) e(4) e(5)   e(6)


                                                          71


   Если два элемента приписаны одному и тому же общему блоку
или разным общим блокам, между ними нельзя устанавливать эк-
вивалентность.


   5.5.5.3. Оператор   'equivalence'   и   массивы   типа
            'logical*1' и 'integer*1'


   Если элемент массива типа "logical*1", который не  вырав-
нен  по границе слова, устанавливается эквивалентным массиву
или переменной другого типа данных, это может вызвать  такое
распределение памяти, при котором переменная или все элемен-
ты массива данных типа, не совпадающего  с  logical*1  ,  не
будут  выравнены  по  границе слова. Если это произойдет, то
попытка обратиться к такой переменной или  элементам  такого
массива вызовет ошибку при выполнении программы.

   Все сказнное применимо и к типу "integer*1".


   5.5.6. Оператор 'external'


   Оператор "external" позволяет использовать идентификаторы
внешних   процедур   (подпрограмм   и  библиотечных  функций
ФОРТРАНА)  в  качестве  фактических  параметров  для  других
подпрограмм. Оператор "external" имеет следующий вид:

  external v[,v]...

где

v  - идентификатор подпрограммы или идентификатор формально-
     го  параметра, который поставлен в соответствие иденти-
     фикатору подпрограммы.

   Оператор "external"  об'являет  каждый  идентификатор  из
списка  как идентификатор внешней процедуры. Такой идентифи-
катор затем может использоваться  как  фактический  параметр
для  подпрограммы.  После этого подпрограмма может использо-
вать идентификатор  соответствующего  формального  параметра
для обращения
 в операторе "call".

   Пример:

c       головная программа
      external sin,cos,tan
          .
          .
      call trig(arc,sin,sec)
          .
          .
      call trig(arc,cos,cor)
          .
          .
      call trig(arc,tan,tgn)
          .
          .
c         подпрограммы


72

      subroutine trig(x,f,y)
      call f(x,y)
      return
      end

      subroutine tan(x,y)
      y=sin(x)/cos(x)
      return
      end

Каждый оператор "call" пересылает  идентификатор  функции  в
подпрограмму  "trig".  Функция затем вызывается обращением к
подпрограмме f(x,y) во втором операторе подпрограммы "trig".
Таким образом, результатом работы второго оператора будет:

      y=sin(x)
      y=cos(x)
 или
      y=tan(x)

В зависимости от того, какой из операторов "call" обращается
к  "trig" (функции "sin" и "cos" являются примерами тригоно-
метрических функций, которые являются библиотечными  функци-
ями ФОРТРАНА).


   5.5.7. Оператор 'data'


   Оператор присваивания начальных значений "data" позволяет
выполнить  присваивание начальных значений переменным и эле-
ментам массива еще до выполнения
 программы.

   Оператор "data" имеет следующий вид:

      data k/const/[[,]k/const/]...

 Где

k  - список, состоящий из одного или  более  идентификаторов
     переменных  или идентификаторов элементов массивов; все
     эти идентификаторы отделяются друг от  друга  запятыми;
     индексные выражения должны быть константами;

const
   - список констант;  константы  имеют  одну  из  следующих
     форм:

         v или n*v

n  - ненулевая целая константа без знака, которая указывает,
     сколько раз значение "v" должно быть присвоено последо-
     вательным элементам из соответствующего списка.

   Оператор "data" вызывает присваивание постоянных значений
из  каждого  списка  "const" элементам из предыдущего списка
"k". Присваивание значений  выполняется  в  том  порядке,  в
каком они расположены.

   Если выполняется присваивание текстовых констант перемен-
ной  или  элементу массива, число байтов, которое может быть


                                                          73

присвоено, зависит от типа переменной. Если число символов в
текстовой константе или в буквенно-цифровом литерале меньше,
чем число байтов, отведенных переменной или элементу  масси-
ва,  то  эта  константа  дополняется  справа пробелами. Если
число символов в текстовой константе больше, чем  максималь-
ное число, которое может быть записано, лишние правые симво-
лы не будут использованы. Текстовые константы могут  присва-
иваться массиву целиком.

   Пример:

     real r(2)
     integer i,str(5)
     data r(1),r(2),i,
&    str/1.0,2.0,10,"strong="/

   Оператор data присваивает двум элементам массива r значе-
ния  1.0  i 2.0, переменной i значение 10, и засылает строку
"strong" в целый массив "str".













































74




                      6. ПОДПРОГРАММЫ


   Все подпрограммы ФОРТРАНА делятся на  два  общих  класса:
подпрограммы,  написанные пользователем и подпрограммы, пре-
доставляемые системой ФОРТРАН. Подпрограммы также делятся на
следующие   категории:  арифметические  операторы-функции  и
подпрограммы.


   6.1. Параметры подпрограмм


   Параметры подпрограмм встречаются дважды -  в  виде  фор-
мальных параметров и в виде фактических параметров.

   Формальные параметры используются в определении  подпрог-
раммы для представления соответствующих фактических парамет-
ров.   Формальные   параметры   присутствуют   в   операторе
"subroutine"  или  в  определении арифметического оператора-
функции  как  неиндексированные  идентификаторы  переменных.
Фактические  параметры  присутствуют   в  операторе "call" и
обеспечивают фактические значения, которые должны  использо-
ваться  при  вычислениях.  Фактические  параметры могут быть
константами, переменными,  массивами,  элементами  массивов,
выражениями или идентификаторами подпрограмм.

   Между фактическими и формальными параметрами устанавлива-
ется соответствие во время передачи управления в подпрограм-
му. Фактический и формальный параметры, между которыми уста-
навливается   соответствие,   должны  иметь  одинаковый  тип
данных. Формальный параметр,  описанный  как  массив,  может
быть поставлен в соответствие  массиву или элементу массива.

   Если фактическим параметром является константа, выражение
или идентификатор подпрограммы, подпрограмма не должна изме-
нять значение соответствующего формального параметра.

   Формальные параметры не должны встречаться  в  операторах
"common", "equivalence" и "data".


   6.2. Пользовательские подпрограммы


   Передача управления оператору-функции  осуществляется  по
обращению  к  функции,  в  то  время как передача управления
подпрограмме осуществляется по оператору "call". Подпрограм-
мы  могут передавать в вызывающую программу некоторые допол-
нительные значения, присваивая их своим параметрам. Подпрог-
рамма  может  обращаться  к  другим подпрограммам, но она не
может прямо или косвенно обращаться к самой себе.









                                                          75

   6.2.1. Подпрограмма


   Подпрограмма является программным модулем, начинающимся с
оператора  "subroutine",  за которым идет последовательность
операторов, определяющих вычислительную процедуру.  Передача
управления  подпрограмме осуществляется по оператору "call",
а возврат в вызывающий программный  модуль  -  по  оператору
"return".

   Оператор "subroutine" имеет следующий вид:

          subroutine nam[([p[,p]...])]
  где

nam
   - идентификатор подпрограммы;

p  - формальный параметр.

   При передаче управления в подпрограмму  формальные  пара-
метры  оператора "subroutine" заменяются значениями, исполь-
зуемыми как фактические параметры  в операторе "call". После
этого выполняются операторы подпрограммы.

   Оператор  "subroutine"  обязан  быть  первым   оператором
подпрограммы; у него не должно быть метки.

   Подпрограмма не может содержать операторов  "block  data"
или  "subroutine" (за исключением первого оператора подпрог-
раммы).

   Пример:

     common nfaces,erce,volume
1    print 71
71   format("enter nfasec,length")
     read(5,70)nfaces,erce
     print 70,nfaces,erce
70   format(i2,f8.5)
     if(nfaces.eq.0) stop
     call obmng
     print 72,volume
72   format("obiem =",f8.5)
     goto 1
     end
     subroutine obmng
     common nfaces,erce,volume
     cubed = erce**3
     goto (6,6,6,1,6,2,6,3,6,
&    6,6,4,6,6,6,6,6,6,5,6),nfaces
1    volume = cubed*0.11785
     return
2    volume = cubed
     return
3    volume = cubed*0.47140
     return
4    volume =cubed*7.66312
     return
5    volume = cubed*2.18170
     return
6    print 25,nfaces


76

25   format("uncorrect number of faces: ")
     return
     end

В этом примере подпрограмма вычисляет об'ем правильного мно-
гогранника,  заданного числом граней и длиной ребра. Она ис-
пользует вычисляемый оператор перехода "go to" для определе-
ния того, является ли данный многогранник тетраэдром, гекса-
эдром, додекаэдром или икосаэдром, и для передачи управления
соответствующей  процедуре для вычисления об'ема. Если число
граней тела отлично от 4, 6, 8, 12 или 20, подпрограмма  вы-
водит сообщение об ошибке на терминал оператора.


   6.2.2. Подпрограмма данных 'block data'


   Подпрограмма данных используется для присваивания началь-
ных  значений об'ектам, находящимся в именованных общих бло-
ках, одновременно с определением этих блоков. Она начинается
с  оператора "block data", за которым следует ряд операторов
описания.

   Оператор "block data" имеет следующий вид:

      block data [nam]
 где

nam
   - идентификатор.

   В подпрограмме данных  разрешено  использовать  следующие
операторы:  операторы  описания  типа, операторы "implicit",
"dimention", "common", "equivalence" и "data".

   Операторы описания в подпрограмме данных определяют общие
блоки,  размещают переменные и массивы в этих блоках и прис-
ваивают начальные значения этим элементам.

   Оператор  "block  data"  обязан  быть  первым  оператором
подпрограммы данных. Он не должен иметь метку.

   Подпрограмма данных не должна содержать выполняемых  опе-
раторов.

   Если в подпрограмме данных  задаются  начальные  значения
некоторого элемента именованного общего блока, то в подпрог-
рамме должен присутствовать полный набор  операторов  описа-
ния,  задающих  весь  блок, даже если некоторые из элементов
этого блока не появляются в операторе "data". Одной и той же
подпрограммой могут быть определены несоколько общих блоков.

   Пример:

      block data
      integer x,y
      logical q,w
      double precision d
      dimension r(4)
      common/blk1/r,x,q,d,blk2/w,y,z
      data r/2.0,3*4.0/,q/.false./,
&     d/0.317638d-7/,w


                                                          77

&     /.true./z/3.5/
      end


   6.2.3. Библиотечные функции ФОРТРАНА


   Перечень библиотечных функций ФОРТРАНА приведен в  прило-
жении 4. Обращения к библиотечным функциям ФОРТРАН записыва-
ются в таком же виде, как  и  обращения  к  пользовательским
функциям. Например:

      r= abs(x-1)

Выполняет вычисление абсолютного значения "х-1" и присваива-
ет полученное значение переменной "r".

   В приложении 4 также указывается  тип  результата  каждой
библиотечной функции и тип  фактических параметров. Парамет-
ры, передаваемые в эти функции, не должны быть идентификато-
рами массивов или идентификаторами подпрограмм.


   6.2.4. Макропроцессор


   Символ "#" в первой позиции строки означает команду  мак-
ропроцессора. Распознаются операторы "define" и "include".

  #define имя лексема

Символическая переменная "имя" получает значение "лексема" и
в  дальнейшем в тексте заменяется на свое значение; эта воз-
можность удобна для описания символических констант:

   include "имя файла"

На место оператора подставляется файл "имя файла".  Оператор
"include" обычно используется для подстановки описаний общих
блоков в фортран-программах.
























78

                                                 ПРИЛОЖЕНИЕ 


            1. Вызов транслятора с языка ФОРТРАН


   Для вызова транслятора с языка ФОРТРАН  используется  ко-
манда "fc" операционной системы "ДЕМОС".

   Синтаксис команды:

  fc [-c] файл_1.f ...файл_o1.0 ...флагиз

Где:

   Файлы,  кончающиеся  на  ".f",  содержат   программы   на
ФОРТРАНЕ,  по  одной программной единице(программа, подпрог-
рамма, функция, блок данных) на файл;

   Файлы, кончающиеся на ".o", являются об'ектными модулями;

   "Флагиз" - флаги и режимы для загрузчика "ld" ОС ДЕМОС.

   Команда "fc" компилирует программы на ФОРТРАНЕ и  записы-
вает  результат  в об'ектные файлы (суффикс "f" заменяется в
ихимени на "o"). Затем, если не указан флаг "-c", полученные
модули обрабатываются редактором связей.

   Полученная программа записывается в файл "a.out" и  может
быть вызвана на счет по команде:

 a.out

   Флаг "-c" блокирует выход на редактор связей "ld"; созда-
ются только об'ектные файлы.

   Для записи полученной программы в файл с именем, отличным
от "a.out", служит флаг "-o":

 fc <параметры> -o имя

Выполняемая программа будет записана в файл "имя".

   Любые  синтаксические  ошибки,  обнаруженные   на   этапе
трансляции, блокируют выход на редактор связей.

   Имеются  ошибки  (например,  недопустимое  преобразование
типов), которые будут обнаружены при редактировании связей.

   Например,диагностика:

  "i1tr8 undefened"

означает, что в программе встретилось неявное преобразование
переменной  "integer*1"  в тип "real*8". Допустимы следующие
преобразования типов (слева указан тип левой части оператора








                                                          79

                                                  Tаблица 1.
присваивания, сверху - тип правой части):

              Допустимые преобразования типов

--------------------------------------------
|   ! l*1 ! l ! i*1 ! i*2 ! i ! r ! r*8! С |
|------------------------------------------|
|l*1!  +  ! + !  -  !  -  ! - ! - !  - ! - |
|------------------------------------------|
|l  !  +  ! + !  -  !  -  ! - ! - !  - ! - |
|------------------------------------------|
|i*1!  -  ! - !  +  !  -  ! + ! - !  - ! - |
|------------------------------------------|
|i*2!  -  ! - !  +  !  +  ! + ! + !  + ! - |
|------------------------------------------|
|i  !  -  ! - !  +  !  +  ! + ! + !  + ! - |
|------------------------------------------|
|r  !  -  ! - !  -  !  +  ! + ! + !  + ! - |
|------------------------------------------|
|r*8!  -  ! - !  -  !  +  ! + ! + !  + ! - |
|------------------------------------------|
|с  !  -  ! - !  -  !  -  ! + ! + !  + ! + |
--------------------------------------------

 Обозначения типов:
 l*1 - logical*1
 l   - logical
 i*1 - integer*1
 i*2 - integer*2
 i   - integer
 r   - real
 r*8 - real*8
 c   - complex


   Ошибки, обнаруженные  на  этапе  счета,  идентифицируются
следующими номерами:

   1.недопустимый логический аргумент;
   2.неверное число аргументов в "amod";
   3.неверное число аргументов в "atanr";
   4.недопустимый аргумент в "cabs";
   5.слишком большой аргумент в "cexp";
   6.неверное число аргументов в "cmplx";
   неверное число аргументов в "dim";
   8.недопустимый аргумент в "exp";
   9.неверное число аргументов "idim";
  10.неверное число аргументов "isign";
  11.неверное число аргументов "mod";
  12.неверное число аргументов "sign";
  13.недопустимый аргумент "sgrt";
  14.в вычисляемом "goto" индекс вне
     допустимого диапазона;
  15.индекс массива вне диапазона;
  16.переполнение real**real;
 100.недопустимый номер устройства
     в операторе  ввода/вывода;
 101.некорректное использование устройства
     ввода/вывода;
 102.невозможно создать выходной файл;
 103.невозможно открыть входной файл;


80

 104.конец файла при вводе;
 105.недопустимый символ в формате;
 106.формат не начинается с " ( ";
 107.список ввода/вывода не пуст, а в
     формате нет спецификации преобразова-
     ния;
 108.ошибка во вложенности скобок в
     формате;
 109.недопустимая спецификация формата;
 110.недопустимый символ во входном поле;
 111.конец формата в спецификации;
 112.недопустимый аргумент "setfil";
 113.недопустимый аргумент у "ierror";
 999.ошибка преобразования при вводе.


















































                                                          81

                                                 ПРИЛОЖЕНИЕ 


    2. Подпрограммы для связи программ на ФОРТРАНЕ с ОС
                             ДЕМОС


   В библиотеке подпрограмм для ФОРТРАНА  имеются  следующие
подпрограммы для взаимодействия с системой:

setfil
   - открыть файл по имени.

Обращение к setfil имеет вид:

 call setfil(unit, string)

Подпрограмма связывает логический канал ввода/вывода  "unit"
с  файлом  по  имени  "string".  "string" представляет собой
текстовую константу или переменную, причем за  именем  файла
должен следовать пробел.

   setfil можно вызывать либо до первого  обмена  по  каналу
"unit"  ,либо  после  операторов  "rewind unit" или "endfile
unit". Каналы с номерами 5 и 6 переопределить нельзя.

ierror
   - перехватить обработку ошибок.

Обращение имеет вид:

 if (ierror(номер ошибки).ne.0) goto label

   Функция "ierror" дает возможность предотвратить окончание
задачи  в  случае  ошибок  при  счете.  При  вызове "ierror"
возвращает значение "0" и запоминает точку вызова. При  воз-
никновении  ошибки со специфицированным номером иммитируется
выход из "ierror" в ту же точку с ненулевым значением; таким
образом,  в нашем примере выполняется оператор "goto label".
Номера ошибок приведены в приложении 1.

П_Р_И_М_Е_Ч_А_Н_И_Е.
     Возврат по "ierror" в подпрограмму, которая уже окончи-
     ла свою работу, приводит к тяжелым ошибкам.

   Обычно функция "ierror" используется для обработки  конца
файла и ошибок при вводе информации. В системе имеется огра-
ничение - нельзя указать одновременно реакцию больше чем  на
5 ошибок.



getarg, iargc
   - получение аргументов из командной строки.

Подпрограмма "getarg" вводит i-й аргумент из командной стро-
ки в текстовый массив. Обращение:







82

 call getarg (i,iarrag [,n])

i-й аргумент команды, по  которой  вызывалась  программа  на
ФОРТРАНЕ,  передается  в массив "iarrag". Если указан третий
параметр, он служит ограничителем длины - массив дополняется
пробелами  до "isize" слов справа, либо, если параметр слиш-
ком длинный, он обрезается справа.

   Узнать число параметров можно с помощью функции "iargc":

 m=iargc(0);

(Функция имеет один фиктивный параметр).



















































                                                          83

                                                 ПРИЛОЖЕНИЕ 


     3. Отличия ФОРТРАНА ОС ДЕМОС от  ФОРТРАНА ОС РАФОС


1. В каждом файле записывается ровно один модуль.

2. Операторы записываются в любом месте строки,  начиная  со
второй  позиции.  Признаком  продолжения служит символ "&" в
первой позиции. Длина строки не ограничена.

3. Вместо одиночных кавычек в текстовых константах использу-
ются двойные.

4. Алфавит языка включает латинские строчные буквы. Ключевые
слова записываются только строчными буквами.

5. Индексные выражения могут иметь только простейшую форму:

 kv+c  или  c  или  kv
где

k и c
   - целые(возможно, отрицательные) константы


v  - целая переменная.

6. В операторе "data" невозможна рассылка  массива  целиком,
все  иницилизируемые элементы массива должны указываться яв-
но.

7. Отсутствует управление кареткой при выводе на печать.

8. Имеются только следующие операторы ввода/вывода:

        read
        write
        print

   Нет параметров типа "err=метка" в операторах  ввода/выво-
да, номер канала может лежать в диапазоне от 1 до 19.

9. Отсутствует оператор "back space".

10.параметры Цикла "l1,l2,l3" должны быть  константами  либо
целыми переменными.

11. Нет восьмеричных констант.

12. Нет операторов-функций.

13. Недопустимы описатели типов:

        logical*2
        integer*4
        real*4.

14. Имеется встроенный макропроцессор.




84

                                                 ПРИЛОЖЕНИЕ 


            4. Основные сведения о языке ФОРТРАН


                         1. Операции

   Операции каждого типа приведены в табл. 1 в порядке  убы-
вания приоритета.

                                                  Таблица 1.
                     Операции ФОРТРАНА
-------------------------------------------
| знак  операции  и        !     операнд  |
! описание  операций       !              !
|-----------------------------------------|
!           арифметические операции       !
! ** возведение в степень  ! арифметичес- !
! *,/ умножение, деление   ! кие константы!
! +,- сложение, вычитание, ! и выражения  !
! унарные плюс и минус     !              !
!             операции отношения          !
!.gt.  больше            ! арифметические !
!.ge.  больше или равно  ! константы, пе- !
!.lt.  меньше            ! ременные и вы- !
!.le.  меньше или равно  ! ражения   (все !
!.eq.  равно             ! рации отношений!
!.ne.  не равно          ! имеют одинако- !
!                        ! вый приоритет  !
-------------------------------------------

































                                                          85

                                      Продолжение таблицы 1.
-------------------------------------------
| знак  операции  и        !     операнд  |
! описание  операций       !              !
|-----------------------------------------|
!           логические операции           !
!.not. .not.a истинно тогда! логические   !
!      и только тогда, ког-! константы,   !
!      да "a" ложно        ! переменные и !
!.and. a.and.b истинно тог-! выражения    !
!      да и только тогда,  !              !
!      когда оба операнда  !              !
!      "a" и "b" истинны   !              !
!.or.  a.or.b истинно тогда!              !
!      и только тогда, ког-!              !
!      да либо "a", либо   !              !
!      "b", либо и "a" и   !              !
!      "b" истинны         !              !
!.eqv. a.eqv.b истинно тог-!(приоритет    !
!      да, когда "a" и "b" !такой же,     !
!      оба истинны или "a" !как и у .xor. !
!      и "b" оба ложны     !              !
!.xor. a.xor.b истинно тог-!(приоритет    !
!      да и только тогда,  !такой же, как !
!      когда "a" истинно, а!и у .eqv.     !
!      "b" ложно или когда !              !
!      "b" истинно, а "a"  !              !
!      ложно               !              !
-------------------------------------------

                        2. Операторы

   Ниже приведен перечень операторов ФОРТРАНА, дан  основной
формат каждого оператора и краткие пояснения.

Арифметическое/логическое присваивание w=a

w  - идентификатор  переменной  или  идентификатор  элемента
     массива;

a  - выражение.

Переменной присваивается значение арифметического или  логи-
ческого выражения.


assign  s to w

s  - метка выполняемого оператора;

w  - идентификатор целой переменной.

Устанавливается соответствие между меткой  оператора  "s"  и
целой переменной "w" для последующего использования в опера-
торе перехода по предписанию go to.


block data [nam]

nam
   - идентификатор.



86

Определяет следующую за ним  подпрограмму  как  подпрограмму
данных.


call s[([,p][, [p]]...)]

s  - идентификатор подпрограммы;

p  - выражение,    идентификатор процедуры        или  иден-
     тификатор массива.

Вызывается подпрограмма с идентификатором "s". При  этом  ей
передаются  фактические  параметры "p" для замены формальных
параметров в определении подпрограммы.


common [/[a]/] k[[,]/[a]/k]...

a  - идентификатор общего блока;

k  - список,  состоящий     из    одного    или   нескольких
     идентификаторов    переменных,   идентификаторов   мас-
     сивов    или дескрипторов массивов,  разделенных  запя-
     тыми.

Резервирует участок оперативной памяти, помеченный идентифи-
катором блока common, для размещения переменных, связанных с
этим блоком.

continue

Передает управление на следующий выполняемый оператор.


data k/c/[[,] k/c/]...

k  - список, состоящий из одного или  нескольких  идентиика-
     торов  переменных  или идентификаторов элементов масси-
     вов, разделенных запятыми. Индексные  выражения  должны
     быть константами;

c  - список, состоящий из  одной  или  нескольких  констант,
     разделенных  запятыми,   причем  каждой константе может
     предшествовать необязательная форма j*, где j - ненуле-
     вая целая константа без знака.

Вызывает присваивание начальных значений из списка  констант
соответствующим элементам списка идентификаторов переменных.


dimension a(d)[,a(d)]...
   a(d) - дескриптор массива.

Определяет об'ем памяти, требующейся для массивов.


do s[,] i=e1,e2[,e3]

s  - метка последнего выполняемого оператора в цикле;





                                                          87

i  - идентификатор переменной цикла;

e1,e2[,e3]
   - константы или переменные.

Выполняются следующие действия:

     1) установка i=e1; 2) выполнение операторов до операто-
     ра с номером "s" включительно; 3) вычисление i=i+e3; 4)
     повторение пунктов второго и третьего "m" раз, где m  =
     max(1,int((e2-e1)/e3)+1)


end

Завершает программный модуль.


end file u

u  - целая переменная или константа.

На логическое  устройство  "u"  записывается  признак  конца
файла.


equivalence (k)[,(k)]...

k  - список, состоящий из двух или более идентификаторов пе-
     ременных, идентификаторов  массивов или идентифи- като-
     ров элементов массивов, разделенных запятыми. Индексные
     выражения должны быть константами.

Каждый из идентификаторов, принадлежащих списку, размещается
в одной и той же области памяти.


external v [,v]...

v  - идентификатор подпрограммы.

Описывает идентификаторы, как идентификаторы внешней  проце-
дуры.


format(спецификация преобразования)

Описывает формат, в котором должна быть  передана  одна  или
несколько записей. Оператор должен иметь метку.


go to s

s  - метка выполняемого оператора.

Безусловный переход. Передает управление оператору с  меткой
"s".







88


go to (k1,k2,...,kn)[,] m


k1,k2,...,kn
   - - список,состоящий из одной или нескольких меток выпол-
     няемых  операторов,  разделенных запятыми;

m  - целое выражение.

Вычисляемый оператор перехода; передает управление  операто-
ру  с меткой, определяемой значением выражения "m"; если "m"
равно 1, управление передается оператору с первой меткой  из
списка; если "m" равно 2, управление передается оператору со
второй меткой и т.д; если "m" меньше единицы или больше, чем
имеющееся  число  меток,  передача  управления происходит на
следующий выполняемый оператор.


go to v [[,](k1,k2,...,kn)]

v  - идентификатор целой переменной;

k1,k2,...,k3
   - список,состоящий из одной или нескольких меток выполня-
     емых операторов, разделенных запятыми.

Переход по предписанию; передает управление оператору, кото-
рый  был последним установлен в соответствие  переменной "v"
оператором assign.


if (m) k1,k2,k3

m  - выражение;

k1,k2,k3
   - метки выполняемых операторов.

Арифметический оператор условного перехода; передает  управ-
ление  оператору  с  номером k1, k2 или k3, в зависимости от
значения выражения; если значение выражения меньше нуля,  то
выполняется  переход  на "k1"; если значения выражения равно
нулю - выполняется переход на "k2"; если значение  выражения
больше нуля - выполняется переход на "k3".


if (e) s

e  - выражение;

s  - любой выполняемый оператор за исключением оператора  do
     и логического условного оператора if.

Логический условный оператор. Выполняет оператор "s" при ус-
ловии истинности выражения.


implicit typ (a[,a]...)[,typ(a[,a]...)]...





                                                          89

typ
   - указатель типа данных;

a  - одна,  либо  две  буквы в алфавитном порядке, разделен-
     ные знаком "-"; (например, x-y, c-d).

Элементы "a" представляют отдельные буквы (или наборы букв),
присутствие  которых  в качестве первой буквы идентификатора
переменной задает тип этой переменной.


pause[n]

n  - последовательность десятичных  цифр,  содержащая от од-
     ной  до  пяти цифр, или буквенно-цифровой литерал,  или
     восьмеричная константа.

Приостанавливает выполнение программы и выводит на  терминал
оператора "n", если "n" задано.


read (u,f)[k]
read f[,k]

u  - целая переменная или целая константа;

f  - метка оператора format или идентификатор массива;

k  - список ввода.

Форматный последовательный ввод. Считывает  одну  или  более
логических  записей с устройства "u" и присваивает элементам
списка ввода значения,  преобразованные  в  соответствии  со
спецификацией формата в операторе "f".


read(u)[k]

u  - целая переменная или целая константа;

k  - список ввода.

Неформатный последовательный ввод. Считывает одну  неформат-
ную запись с устройства "u" и присваивает значения элементам
списка.


return

Возвращает управление в вызывающую программу из  выполняемой
подпрограммы.


rewind u

u  - целая переменная или целая константа.

Вызывает возврат  к  началу  файла,  открытого  в  настоящий
момент на логическом устройстве "u".





90


stop[n]

n  - последовательность    десятичных    цифр,     буквенно-
     цифровой литерал или восьмеричная константа.

Прекращает выполнение программы и выводит на терминал опера-
тора "n", если "n" задано.


subroutine nam [([p[,p]...])]

nam
   - идентификатор;

p  - идентификатор.

Начинает подпрограмму, указывая ее идентификатор и идентифи-
каторы формальных параметров "p".


typ v[,v]...

typ
   - указатель типа данных;

v  - идентификатор  переменной  ,   идентификатор   массива,
     идентификатор функции  или  точки  входа в функцию, или
     дескриптор  массива. За идентификатором   может  следо-
     вать необязательный указатель длины типа данных (*n).

Идентификаторам "v" в данной программной единице  присваива-
ется указанный тип. Тип может быть одним из следующих:

       double precision
       complex
       complex*8
       real
       real*8
       integer
       integer*2
       logical
       logical*1


write(u,f)[k]
print f[,k]

u  - целая переменная или целая константа;

f  - метка оператора format или идентификатор массива;

k  - список вывода.

Форматный последовательный вывод; записывает  на  устройство
"u"  одну или несколько записей, содержащих значения элемен-
тов списка, преобразованные  согласно  спецификации  формата
"f".






                                                          91


write (u)[k]

u  - целая переменная или целая константа;

k  - список вывода.

Неформатный последовательный вывод. Записывает на устройство
"u"  одну  неформатную запись, содержащую значения элементов
списка.






















































92

                                                 ПРИЛОЖЕНИЕ 


              5. Библиотечные функции ФОРТРАНА


1) Функции преобразования:

abs(x)
     вещественное абсолютное значение; тип параметра  -  ве-
     щественный, тип функции - вещественный.

iabs(i)
     целое абсолютное значение; тип параметра -  целый,  тип
     функции - целый.

dabs(x)
     абсолютное значение с двойной точностью; тип  параметра
     -  с  двойной  точностью,  тип функции - с двойной точ-
     ностью.

cabs(z)
     абсолютное значение комплексной величины, где  z=(x,y),
     cabc(z)=(x**2+y**2)**0,5;  тип параметра - комплексный,
     тип функции - вещественный.

float(i)
     преобразование целой величины в вещественную; тип пара-
     метра - целый, тип функции - вещественный.

ifix(x)
     преобразование вещественной величины в  целую;  ifix(x)
     эквивалентна  int(x); тип параметра - вещественный, тип
     функции - целый.

sngl(x)
     преобразование  величины  с  двойной  точностью  в  ве-
     щественную  величину;  тип  параметра  - с двойной точ-
     ностью, тип функции - вещественный.

dble(x)
     преобразование вещественной величины в величину с двой-
     ной   точностью;  тип  параметра  -  вещественный,  тип
     функции - с двойной точностью.

real(z)
     выделение действительной части в комплексной  величине;
     тип  параметра  - комплексный, тип функции - веществен-
     ный.

aimag(z)
     выделение мнимой части в комплексной величине; тип  па-
     раметра - комплексный, тип функции - вещественный.

cmplx(x,y)
     об'единение двух вещественных величин в комплексную ве-
     личину  cmplx(x,y)=x+i*y; тип параметра - вещественный,
     тип функции - комплексный.

2) Функции выделения целой части:




                                                          93

   Результатом функций выделения целой  части  является  на-
ибольшее  целое число, не превышающее по абсолютной величине
аргумент функции. Функции присваивается знак аргумента.

aint(x)
     выделение целой части вещественной величины; тип  пара-
     метра - вещественный, тип функции - вещественный.

int(x)
     выделение целой части вещественной величины; тип  пара-
     метра - вещественный, тип функции - целый.

idint(x)
     выделение целой части величины с двойной точностью; тип
     параметра - двойной точности, тип функции - целый.

3) Функции остатка:

   Результатом функций остатка является остаток  от  деления
первого аргумента на второй.

amod(x,y)
     остаток вещественный; тип  параметров  -  вещественный,
     тип функции - вещественный.

mod(i,j)
     остаток целый; тип параметров - целый,  тип  функции  -
     целый.

dmod(x,y)
     остаток с двойной точностью; тип  параметра  -  двойной
     точности, тип функции - двойной точности.

4) Функции выбора максимального значения:

   Результатом функций выбора максимального значения являет-
ся  наибольшее  значение из аргументов списка, состоящего из
двух или более аргументов.

amax0(i,j,...)
     максимальное вещественное значение из списка целых  ар-
     гументов;  тип  параметров  -  целый, тип функции - ве-
     щественный.

amax1(x,y,...)
     максимальное вещественное значение из списка веществен-
     ных   аргументов;   тип  параметров  вещественный,  тип
     функции - вещественный.

max0(i,j,...)
     максимальное целое значение из списка целых аргументов;
     тип параметра - целый, тип функции - целый.

max1(x,y,...)
     максимальное целое значение из списка вещественных  ар-
     гументов;  тип  параметра - вещественный, тип функции -
     целый.

dmax1(x,y,...)
     максимальное значение двойной точности из списка  аргу-
     ментов  с  двойной точностью; тип параметра - с двойной
     точностью, тип функции - с двойной точностью.


94


5) Функции выбора минимального значения:

   Результатом функций выбора минимального значения является
наименьшее значение из списка аргументов, состоящего из двух
или более аргументов.

amin0(i,j,...)
     минимальное вещественное значение из списка целых аргу-
     ментов;  тип  параметров  -  целый,  тип  функции - ве-
     щественный.

amin1(x,y,...)
     минимальное вещественное значение из списка  веществен-
     ных  аргументов;  тип  параметров  -  вещественный, тип
     функции - вещественный.

min0(i,j,...)
     минимальное целое значение из списка целых  аргументов;
     тип параметров - целый, тип функции - целый.

min1(x,y,...)
     минимальное целое значение из списка вещественных аргу-
     ментов;  тип  параметров  - вещественный, тип функции -
     целый.

dmin1(x,y,...)
     минимальное значение с двойной точностью из списка  па-
     раметров  с двойной точностью; тип параметров - с двой-
     ной точностью, тип функции - с двойной точностью.

6) Функции присваивания знака:

   Результатомфункции присваивания знака является абсолютное
значение  первого аргумента с присвоенным ему знаком второго
аргумента.

sign(x,y)
     присваивание знака вещественной величине; тип  парамет-
     ров - вещественный, тип функции - вещественный.

isign(i,j)
     присваивание знака целой  величине;  тип  параметров  -
     целый, тип функции - целый.

dsign(x,y)
     присваивание знака величине с  двойной  точностью;  тип
     параметров - с двойной точностью, тип функции - с двой-
     ной точностью.

7) Функции положительной разности:

   Результатом  функции  положительной   разности   является
разность  первого  аргумента и минимального из двух аргумен-
тов.

dim(x,y)
     положительная разность вещественных величин; тип  пара-
     метров - вещественный, тип функции - вещественный.





                                                          95

idim(i,j)
     положительная разность целых величин; тип параметров  -
     целый, тип функции - целый.

8) Экспоненциальные функции:

   Результатом экспоненциальных  функций  является  значение
"е", возведенное в степень, равную аргументу.

exp(x)
     е**х. Тип параметра - вещественный, тип функции  -  ве-
     щественный;

dexp(x)
     е**х. Тип параметра - с двойной точностью, тип  функции
     - с двойной точностью.

cexp(z)
     е**z.  Тип  параметра  -  комплексный,  тип  функции  -
     комплексный.

9) Логарифмические функции:

alog(x)
     натуральный логарифм вещественного аргумента; тип пара-
     метра - вещественный, тип функции - вещественный.

alog10(x)
     десятичный логарифм вещественного аргумента.

dlog(x)
     натуральный логарифм аргумента с двойной точностью; тип
     параметра  - с двойной точностью, тип функции - с двой-
     ной точностью.

clog(z)
     натуральный логарифм комплексного аргумента; тип  пара-
     метра - комплексный, тип функции - комплексный.

10) Квадратный корень:

sqrt(x)
     корень квадратный из вещественного аргумента; тип пара-
     метра - вещественный, тип функции - вещественный.

dsqrt(x)
     корень квадратный из аргумента  двойной  точности;  тип
     параметра  - с двойной точностью, тип функции с двойной
     точностью.

csqrt(z)
     корень квадратный из комплексного аргумента; тип  пара-
     метра - комплексный,  тип функции - комплексный.

11) Тригонометрические функции:

sin(x)
     синус вещественного  аргумента;  тип  параметра  -  ве-
     щественный, тип функции - вещественный.





96

dsin(x)
     синус аргумента с двойной точностью; тип параметра -  с
     двойной точностью, тип функции - с двойной точностью.

csin(z)
     синус   комплексного   аргумента;   тип   параметра   -
     комплексный, тип функции - комплексный.

cos(x)
     косинус вещественного аргумента; тип  параметра  -  ве-
     щественный, тип функции - вещественный.

dcos(x)
     косинус аргумента с двойной точностью; тип параметра  -
     с двойной точностью, тип функции - с двойной точностью.

ccos(z)
     косинус  комплексного  аргумента;   тип   параметра   -
     комплексный, тип функции - комплексный.

atan(x)
     арктангенс вещественного аргумента; тип параметра - ве-
     щественный, тип функции - вещественный.

datan(x)
     арктангенс аргумента с двойной точностью; тип функции -
     с двойной точностью.

atan2(x,y)
     арктангенс  вещественного  аргумента  от   "x/y";   тип
     функции - вещественный.

datan2(x,y)
     арктангенс аргумента с двойной точностью от "x/y";  тип
     функции - с двойной точностью.

12) Дополнительные математические функции:

conjg(z)
     вычисление   комплексно-сопряженной   величины;    если
     z=х+i*y, то conjg(z)=x-i*y.

ran(i,j)
     вычисление случайного числа, равномерно распределенного
     на  интервале  от  0 до 1; "i" и "j" должны быть целыми
     переменными, первоначально установленными в 0 ; повтор-
     ная  установка "i" и "j" в 0 повторно генерирует после-
     довательность случайных чисел; изменение начальных зна-
     чений для "i" и "j" вызывает генерацию новых последова-
     тельных случайных чисел.

tanh(x)
     тангенс гиперболический; тип параметра - вещественный.











                                                          97



                           СОДЕРЖАНИЕ



1.  ОБЩИЕ СВЕДЕНИЯ И СПОСОБ ОПИСАНИЯ ЯЗЫКА.............    3
    1.1. Компоненты программы на ФОРТРАНЕ..............    3
    1.1.1. Операторы...................................    3
    1.1.2. Комментарии.................................    3

2.  ЭЛЕМЕНТЫ И ОСНОВНЫЕ КОНСТРУКЦИИ ЯЗЫКА..............    4
    2.1. Набор символов ФОРТРАН........................    4
    2.1.1. Использование редактора текста..............    4

3.  ЭЛЕМЕНТЫ ДАННЫХ ФОРТРАНА...........................    5
    3.1. Идентификаторы................................    5
    3.2. Типы данных      .............................    6
    3.3. Константы.....................................    7
    3.3.1. Целые константы.............................    7
    3.3.2. Вещественные константы......................    8
    3.3.3. Константы с двойной точностью...............   10
    3.3.4. Комплексные константы.......................   10
    3.3.5. Логические константы........................   11
    3.3.6. Текстовые константы.........................   11
    3.3.6.1. Буквенно-цифровые литералы................   12
    3.4. Переменные....................................   12
    3.4.1. Спецификация типа данных....................   13
    3.5. Массивы.......................................   13
    3.5.1. Дескрипторы массивов........................   14
    3.5.2. Списки индексов.............................   14
    3.5.3. Расположение массивов в памяти..............   15
    3.5.4. Тип данных массива..........................   16
    3.5.5. Обращения к массивам без использования спис-
           ка индексов.................................   16
    3.5.6. Массивы с переменными границами.............   17

4.  ВЫРАЖЕНИЯ..........................................   19
    4.1. Арифметические выражения......................   19
    4.1.1. Применение скобок...........................   20
    4.1.2. Тип значения арифметического выражения......   21
    4.2. Выражения отношений...........................   22
    4.3. Логические выражения..........................   23

5.  ОПЕРАТОРЫ ЯЗЫКА ФОРТРАН............................   26
    5.1. Операторы присваивания........................   26
    5.1.1. Арифметический оператор присваивания........   26
    5.1.2. Логические операторы присваивания...........   28
    5.1.3. Оператор  'assign'..........................   29
    5.2. Операторы управления..........................   30
    5.2.1. Оператор 'go to'............................   30
    5.2.1.1. Оператор безусловного перехода............   31
    5.2.1.2. Вычисляемый оператор перехода 'go to'.....   31
    5.2.1.3. Оператор перехода по предписанию 'go to'..   32
    5.2.2. Операторы 'if'..............................   32
    5.2.2.1. Арифметический оператор условного перехода
             'if'......................................   33
    5.2.2.2. Логический условный оператор 'if'.........   33
    5.2.3. Оператор 'do'...............................   34
    5.2.3.1. Управление итерацией......................   35
    5.2.3.2. Вложенность операторов 'do'...............   36
    5.2.3.3. Передача управления во вложенных 'do'.....   37


98

    5.2.4. Оператор 'continue'.........................   37
    5.2.5. Оператор 'call'.............................   37
    5.2.6. Оператор 'return'...........................   38
    5.2.7. Оператор 'stop'.............................   38
    5.2.8. Оператор 'end'..............................   39
    5.3. Ввод/вывод данных.............................   39
    5.3.1. Номера логических устройств ввода/вывода....   40
    5.3.2. Указатели формата...........................   40
    5.3.3. Единицы ввода/вывода........................   40
    5.3.4. Списки ввода/вывода.........................   41
    5.3.4.1. Простые списки............................   41
    5.3.4.2. Списки с циклами..........................   42
    5.3.5. Неформатный  ввод/вывод.....................   43
    5.3.5.1. Оператор неформатного  ввода 'read'.......   44
    5.3.5.2. Оператор неформатного вывода 'write'......   44
    5.3.6. Форматный ввод/вывод........................   45
    5.3.6.1. Оператор форматного ввода 'read'..........   45
    5.3.6.2. Оператор форматного вывода 'write'........   46
    5.3.6.3. Оператор 'print'..........................   47
    5.3.7. Вспомогательные операторы ввода/вывода......   47
    5.3.7.1. Оператор 'rewind'.........................   47
    5.3.7.2. Оператор 'endfile'........................   48
    5.3.8. Библиотечные программы......................   48
    5.4. Операторы 'format'............................   48
    5.4.1. Спецификации преобразования.................   50
    5.4.1.1. Спецификация 'i'..........................   50
    5.4.1.2. Спецификация 'f'..........................   51
    5.4.1.3. Спецификация 'e'..........................   52
    5.4.1.4. Спецификация 'd'..........................   53
    5.4.1.5. Спецификация 'l'..........................   54
    5.4.1.6. Спецификация 'a'..........................   54
    5.4.1.7. Спецификация 'h'..........................   55
    5.4.1.8. Спецификация 'x'..........................   56
    5.4.2. Редактирование комплексных данных...........   56
    5.4.3. Масштабный коэффициент......................   57
    5.4.4. Группирование и повторяемые группы..........   58
    5.4.5. Разделительные знаки списка спецификаций....   59
    5.4.5.1. Разделители внешних полей.................   59
    5.4.5.2. Переменный список спецификаций............   60
    5.4.6. Взаимодействие управления форматом и  списка
           ввода/вывода................................   61
    5.4.7. Сводка правил для оператора 'format'........   62
    5.4.7.1. Общие правила.............................   62
    5.4.7.2. Правила для ввода.........................   63
    5.4.7.3. Правило для вывода........................   64
    5.5. Операторы описания............................   64
    5.5.1. Оператор 'implicit'.........................   64
    5.5.2. Операторы описания типа.....................   65
    5.5.3. Оператор 'dimension'........................   66
    5.5.4. Оператор 'common'...........................   67
    5.5.4.1. Именованный и неименованный общие блоки...   69
    5.5.4.2. Операторы 'common' с дескрипторами  масси-
             вов.......................................   69
    5.5.5. Оператор 'equivalence'......................   69
    5.5.5.1. Установление эквивалентности массивов.....   70
    5.5.5.2. Взаимодействие   операторов   'common'   и
             'equivalence'.............................   71
    5.5.5.3. Оператор  'equivalence'  и  массивы   типа
             'logical*1' и 'integer*1'.................   72
    5.5.6. Оператор 'external'.........................   72
    5.5.7. Оператор 'data'.............................   73



                                                          99

6.  ПОДПРОГРАММЫ.......................................   75
    6.1. Параметры подпрограмм.........................   75
    6.2. Пользовательские подпрограммы.................   75
    6.2.1. Подпрограмма................................   76
    6.2.2. Подпрограмма данных 'block data'............   77
    6.2.3. Библиотечные функции ФОРТРАНА...............   78
    6.2.4. Макропроцессор..............................   78

ПРИЛОЖЕНИЕ 1.  Вызов транслятора с языка ФОРТРАН.......   79

ПРИЛОЖЕНИЕ 2.  Подпрограммы  для  связи   программ   на
    ФОРТРАНЕ с ОС ДЕМОС................................   82

ПРИЛОЖЕНИЕ 3.  Отличия ФОРТРАНА ОС ДЕМОС  от   ФОРТРАНА
    ОС РАФОС...........................................   84

ПРИЛОЖЕНИЕ 4.  Основные сведения о языке ФОРТРАН.......   85

ПРИЛОЖЕНИЕ 5.  Библиотечные функции ФОРТРАНА...........   93













































100

