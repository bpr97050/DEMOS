
AWK(1)                 ДЕМОС. Команды                 AWK(1)


ИИММЯЯ
       aawwkk - язык сканирования и обработки текстов

ФФООРРММААТТ
       aawwkk [--FF_c] --ff _ф_а_й_л__с__A_W_K-_п_р_о_г_р_а_м_м_о_й [_в_х__ф_а_й_л...]

       aawwkk [--FF_c] ''_A_W_K-_п_р_о_г_р_а_м_м_а'' [_в_х__ф_а_й_л...]

ООППИИССААННИИЕЕ
       Команда aawwkk является интерпретатором языка AWK, пред-
       назначенного для обработки структурированных текстов.
       Структурированный текст содержится во входном файле и
       рассматривается  как  список  записей  и  полей в них
       (символ '_c' в  ключе  --FF_c  -  это  символ-разделитель
       полей  в  записях).   Над  входным файлом выполняется
       некоторый определенный программистом  алгоритм  обра-
       ботки  (содержащийся либо в _A_W_K-_п_р_о_г_р_а_м_м_е непосредст-
       венно в командной строке, либо  в  файле  _ф_а_й_л__с__A_W_K-
       _п_р_о_г_р_а_м_м_о_й).   Входные  файлы считываются по порядку;
       если они не указаны или  вместо  них  задан  параметр
       '--',  используется стандартный файл ввода.  Результат
       выполнения AWK-программы печатается на  экране  дисп-
       лея,  если не указано >>_в_ы_х_о_д_н_о_й__ф_а_й_л (тогда результат
       направляется в этот файл).

       В языке AAWWKK выделяют две группы переменных: предопре-
       деленные  и декларированные в программе.  Предопреде-
       ленные переменные доступны для подстановок и  измене-
       ний в программе, их исходные значения устанавливаются
       интерпретатором aawwkk в процессе запуска  и  выполнения
       AWK-программы.  К  предопределенным  переменным отно-
       сятся:

       NNRR        номер текущей записи;
       NNFF        число полей в текущей записи;
       RRSS        разделитель записей на вводе (символ);
       FFSS        разделитель полей записи на вводе (символ);
       OORRSS       разделитель записей на выводе AWK-программы
                 (символ);
       OOFFSS       разделитель полей записи  на  выводе  (сим-
                 вол);
       OOFFMMTT      формат вывода чисел;
       FFIILLEENNAAMMEE  имя входного файла (строка).

       По умолчанию предопределенные переменные имеют следу-
       ющие значения:

       RRSS     =   "\n";
       FFSS     =   'пробел(ы) и/или табуляция';
       OOFFSS    =   FFSS;
       OORRSS    =   RRSS;
       OOFFMMTT   =   "%.6g";

       Предопределенным переменным RRSS, FFSS,  OORRSS,  OOFFSS,  OOFFMMTT
       можно присваивать значения в AWK-программе.

       Кроме предопределенных переменных, применяются следу-
       ющие типы переменных: позиционная переменная; число с


                            -1-                     ДЕМОС/PV


AWK(1)                 ДЕМОС. Команды                 AWK(1)


       плавающей точкой; строка символов; массив.   В  языке
       AAWWKK  отсутствуют  декларация  и  явная  инициализация
       переменной любого типа. Всякой переменной до ее  пер-
       вого использования присваивается значение "" - пустая
       строка.

       Позиционная переменная определяет поле записи, содер-
       жимое  которого может быть отнесено к типам  "строка"
       или   "число_с_точкой"   и   используется   в    виде
       $$_н_о_м_е_р__п_о_л_я__з_а_п_и_с_и          или         $$(_в_ы_р_а_ж_е_н_и_е).
       _Н_о_м_е_р__п_о_л_я__з_а_п_и_с_и  может  быть  значением  выражения.
       Значением  позиционной  переменной  $$0  является  вся
       запись.

       Интерпретатор aawwkk рассматривает переменную как  стро-
       ковую  до  того  момента,  когда необходимо выполнить
       некоторую операцию над ее значением. В зависимости от
       контекста тип значения переменной остается либо стро-
       ковым, либо преобразуется к  типу  число_с_точкой.  В
       двусмысленных случаях  переменные рассматриваются как
       строковые. Строки, которые не могут быть  интерпрети-
       рованы  как  числа,  в числовом контексте будут иметь
       числовое значение _н_о_л_ь.

       Массив не декларируется, он начинает  существовать  в
       момент первого использования. Индексы в массиве могут
       иметь любое ненулевое  значение,  включая  нечисловые
       строки, это позволяет использовать ассоциативные мас-
       сивы.

       В языке AAWWKK используются операторы присваивания

       ==   ++==   --==   **==   //==   %%==

       и арифметические операции

       ++    --    **    //    %%    ++++    ----

       Они имеют тот же смысл, что и в языке  программирова-
       ния  Си.   Имеются  некоторые  особенности выполнения
       операций сравнения

       <<    <<==    ====    !!==     >>==     >>

       Если оба  операнда  интерпретируются  как  числа,  то
       выполняется  сравнение чисел.  Если один из операндов
       является строкой символов,  а  другой  -  числом,  то
       выполняется  сравнение строк.  В AWK-программах можно
       использовать следующие логические операции:

       !! (не)     |||| (или)     &&&&  (и)

       Как обычно, значением выражения, содержащего операции
       отношения и/или логические операции, являются: истина
       (не ноль) или ложь  (ноль).   Приоритеты  операций  в
       выражениях  аналогичны установленным в языке Си.  Для
       управления порядком выполнения операций  в  выражении
       используются круглые скобки.


                            -2-                     ДЕМОС/PV


AWK(1)                 ДЕМОС. Команды                 AWK(1)


       В языке AAWWKK имеется операция,  не  предусмотренная  в
       Си, - это операция "пробел", которая используется для
       конкатенации переменных, значения которых интерпрети-
       руются как строковые.

       AWK-программа состоит из списка правил вида:

       _с_е_л_е_к_т_о_р_1   {{  _д_е_й_с_т_в_и_е  }}
            ...
       _с_е_л_е_к_т_о_р_N   {{  _д_е_й_с_т_в_и_е  }}

       Открывающая фигурная скобка должна стоять  в  той  же
       строке,  где  селектор. В любом месте программы можно
       ввести комментарий, он печатается от символа  '##'  до
       конца строки.

       Каждое правило выполняется для каждой записи из вход-
       ного  потока.  Селектор  используется для того, чтобы
       выделить запись, над которой будет выполнено действие
       соответствующего правила.  Если запись не выделена ни
       одним из селекторов, она игнорируется и не  выводится
       на  стандартный вывод.  Если запись выделена селекто-
       ром, выполняется  действие  соответсвующего  правила.
       Если  некоторую запись выделяют несколько селекторов,
       над ней выполняются действия соответствующих  правил.
       В  правиле может отсутствовать селектор, тогда дейст-
       вие этого правила будет выполнено для всех без исклю-
       чения входных записей.  В правиле может отсутствовать
       действие,  тогда  все  выделенные  селектором  записи
       будут направлены на стандартный вывод без изменений.

       Определены два правила специального вида:

       BBEEGGIINN   {{  _д_е_й_с_т_в_и_е  }}
       EENNDD     {{  _д_е_й_с_т_в_и_е  }}

       Правило с селектором BBEEGGIINN выполняется до чтения пер-
       вой  входной  записи, с селектором EENNDD - после чтения
       последней записи.  Правило с селектором BBEEGGIINN  должно
       быть  первым в списке правил, с селектором EENNDD - пос-
       ледним.  Действие в правиле  может  содержать  список
       операторов и управляющих конструкций. Оператор должен
       заканчиваться  символом  ';;',  или   символом   новой
       строки, или закрывающей скобкой.

       Селектор  указывается,  чтобы  определить,  будет  ли
       выполняться  действие в правиле. В качестве селектора
       может быть использовано  любое  выражение,  шаблон  и
       произвольная их комбинация.

       Шаблон используется для формирования одного или боль-
       шего  числа  образцов  в  селекторе. При сканировании
       входной записи осуществляется поиск цепочки символов,
       тождественной  образцу.  В простейшем случае селектор
       с шаблоном выглядит следующим образом: //_о_б_р_а_з_е_ц//.

       Если необходимо, чтобы соответствие образцу определя-
       лось в конкретном поле записи, используются операторы


                            -3-                     ДЕМОС/PV


AWK(1)                 ДЕМОС. Команды                 AWK(1)


       соответствия ('~~' и '!!~~').

       $$_н_о_м_е_р__п_о_л_я ~~  _ш_а_б_л_о_н
              если при просмотре указанной позиционной пере-
              менной  обнаруживается  цепочка символов, тож-
              дественная образцу в шаблоне  (оператор  '~~'),
              выполняется действие правила.

       $$_н_о_м_е_р__п_о_л_я !!~~ _ш_а_б_л_о_н
              если при просмотре указанной позиционной пере-
              менной  не  обнаруживается  цепочка  символов,
              тождественная  образцу  в  шаблоне   (оператор
              '!!~~'), выполняется действие правила.

       При необходимости используются так  называемые  регу-
       лярные  выражения, в этом случае шаблон выглядит сле-
       дующим  образом:  //_р_е_г_у_л_я_р_н_о_е__в_ы_р_а_ж_е_н_и_е//.  Регулярные
       выражения в шаблонах селекторов AAWWKK аналогичны подоб-
       ным в lleexx, редакторе eedd и в команде ggrreepp.  Регулярное
       выражение формируется как композиция цепочек символов
       (и/или диапозонов символов) и операторов. Операторы в
       регулярных  выражениях  указываются  в виде символов-
       операторов.   Чтобы  отменить  специальное   значение
       символа-оператора, его экранируют символом '\\'.

       Для  определения  диапазона  записей   в   селекторах
       используется операция запятая. До запятой указывается
       селектор, выделяющий первую запись в диапазоне, после
       запятой  -  селектор,  выделяющий  последнюю запись в
       диапазоне.

       Действия в правилах AWK-программы определяют алгоритм
       обработки  выделенных  селектором записей. Для записи
       алгоритма используются присваивания, выражения,  опе-
       раторы управления, операторы вывода, встроенные функ-
       ции.  Действие в правиле  записывается  как  блок  (в
       смысле  языка  программирования Си). Фигурная скобка,
       открывающая блок, должна указываться в той же строке,
       что и селектор, закрывающая - по завершению блока.

       К числу операторов управления относятся:

       nneexxtt   перейти к чтению следующей записи.  Управление
              передается  на  первое  правило  AWK-программы
              (если имеется правило с селектором  BBEEGGIINN,  то
              на следующее за ним).

       bbrreeaakk  прерывает  выполнение   охватывающего   цикла.
              Управление  передается  на оператор, следующий
              за циклом.

       ccoonnttiinnuuee
              переход к следующей итерации цикла.

       eexxiitt   завершить выполнение программы.

       iiff(_в_ы_р_а_ж_е_н_и_е) { _б_л_о_к__1 }  eellssee { _б_л_о_к__2 }
              если значение _в_ы_р_а_ж_е_н_и_я - истина,  выполняются


                            -4-                     ДЕМОС/PV


AWK(1)                 ДЕМОС. Команды                 AWK(1)


              операторы  _б_л_о_к_а__1,  иначе  операторы _б_л_о_к_а__2.
              Часть eellssee можно опустить.

       wwhhiillee(_в_ы_р_а_ж_е_н_и_е) { _б_л_о_к }
              операторы  _б_л_о_к_а  выполняются,  пока  значение
              _в_ы_р_а_ж_е_н_и_я - истина.

       ffoorr(_в_ы_р_а_ж_е_н_и_е__1; _в_ы_р_а_ж_е_н_и_е__2; _в_ы_р_а_ж_е_н_и_е__3) { _б_л_о_к }
              если значение _в_ы_р_а_ж_е_н_и_я__2 -  истина,  выполня-
              ются операторы _б_л_о_к_а.  _В_ы_р_а_ж_е_н_и_е__1 вычисляется
              перед  первой  итерацией  цикла,   _в_ы_р_а_ж_е_н_и_е__3
              вычисляется на каждой итерации цикла.

       ffoorr( _и_н_д_е_к_с iinn _и_м_я__м_а_с_с_и_в_а ) { _б_л_о_к }
              для каждого значения _и_н_д_е_к_с_а _м_а_с_с_и_в_а  выполня-
              ются операторы _б_л_о_к_а.  Значение индекса форми-
              руется автоматически на каждой итерации  цикла
              и  равно  значению,  еще  не использованному в
              цикле. Если используется ассоциативный массив,
              индекс    формируется   в   лексикографическом
              порядке.

       Для вывода данных в AWK-программе используется опера-
       тор  pprriinntt(_с_п_и_с_о_к__п_а_р_а_м_е_т_р_о_в).   Круглые скобки можно
       не  указывать,  то  есть  записи  "pprriinntt($1,$2);"   и
       "pprriinntt $1,$2;" равнозначны.  Если необходим форматный
       вывод, можно применять библиотечную  функцию  pprriinnttff,
       синтаксис и результаты работы которой такие же, как и
       в языке Си.

       Интерпретатор aawwkk включает набор встроенных  функций,
       которые  можно использовать в действиях правил.  Име-
       ются следующие встроенные функции:

       lleennggtthh(_в_ы_р_а_ж_е_н_и_е)
              значением выражения является  строка;  функция
              lleennggtthh возвращает длину строки.

       eexxpp(_в_ы_р_а_ж_е_н_и_е)
              возвращает экспоненту от выражения.

       lloogg(_в_ы_р_а_ж_е_н_и_е)
              возвращает натуральный логарифм выражения.

       ssqqrrtt(_в_ы_р_а_ж_е_н_и_е)
              возвращает значение квадратного корня от выра-
              жения.

       iinntt(_в_ы_р_а_ж_е_н_и_е)
              возвращает целую часть числа, равного значению
              выражения.

       ssuubbssttrr((_S, _M, _N)
              возвращает часть  строки  _S,  начинающуюся  от
              позиции  _M и имеющую длину не более _N символов
              (символы в строке _S нумеруются с 1).

       iinnddeexx(_A_s, _P_s)


                            -5-                     ДЕМОС/PV


AWK(1)                 ДЕМОС. Команды                 AWK(1)


              возвращает номер позиции, с которой строка  _P_s
              совпадает  со строкой _A_s (если совпадения нет,
              возвращается 0).

       sspprriinnttff(_ф_о_р_м_а_т, _в_ы_р_а_ж_е_н_и_е, ...)
              возвращает строку, выведенную по формату (син-
              таксис  функции  и результат работы аналогичны
              функции sspprriinnttff в библиотеке языка  программи-
              рования Си).

       sspplliitt( _S, _N_a_m_e, _р_а_з_д_е_л_и_т_е_л_ь )
              строка _S разбивается на поля, значения которых
              присваиваются  элементам  массива _N_a_m_e. Значе-
              нием первого элемента _N_a_m_e[1] будет содержимое
              первого  выделенного  поля,  значением второго
              элемента _N_a_m_e[2] - второго выделенного поля  и
              так далее.

ППРРИИММЕЕРРЫЫ
       Во входном файле _d_f_i_l_1  (с  разделителем  полей  ':')
       найти  строки, в которых значение третьего поля равно
       1989 и напечатать  в  файл  _r_e_s  значения  первого  и
       третьего полей каждой из выбранных строк:

       aawwkk --FF: ''$3==1989 {pprriinntt($1,$3);}'' _d_f_i_l_1 >>_r_e_s

       Во входном файле _d_f_i_l_2 (разделитель полей  -  пробел)
       найти строки, в которых первое поле начинается с сим-
       вола '#' и выдать найденные строки на экран:

       aawwkk ''$1~/^#/ {pprriinntt}' _d_f_i_l_2

       Обработать входной файл  _d_f_i_l  (разделитель  полей  -
       ':')  в  соответствии  с  программой,  содержащейся в
       файле _c_f_i_l и результат обработки выдать в файл _r_e_s:

       aawwkk --FF: --ff _c_f_i_l _d_f_i_l >>_r_e_s

       Примечание
              В примерах, приведенных  далее,  программы  не
              записаны  в  явном  виде в командной строке, а
              содержатся в  файле  и  вызываются  аналогично
              предыдущему случаю.

       Напечатать первое, шестое и третье поля  (отделяя  их
       друг  от  друга тремя пробелами) тех строк, в которых
       третье  поле  оканчивается  числом  89,  шестое  поле
       содержит  цепочку  символов  "тел."  и первое поле не
       равно третьему:

       $3~/89$/ && $6~/тел\./ && ( $1 != $3 ) {
          pprriinnttff("%4d   %15s   %s\n",$1,$6,$3);}

       Напечатать заголовок РЕЗУЛЬТАТ РАБОТЫ; в тех строках,
       у  которых первое поле равно 1988, присвоить ему зна-
       чение 1989 (вместо значения 1988) и  напечатать  пер-
       вое, третье и шестое поля (разделенные табуляцией):



                            -6-                     ДЕМОС/PV


AWK(1)                 ДЕМОС. Команды                 AWK(1)


       BBEEGGIINN  { OOFFSS = "\t"; pprriinntt "РЕЗУЛЬТАТ РАБОТЫ" }
       ($1 == 1988) { $1 = 1989; pprriinntt($1,$3,$6); }

       Напечатать  строки,  в  которых  девятое  поле   есть
       цепочка  символов "октябрь"; в конце напечатать сумму
       и среднее по третьему полю для всех выбранных строк:

       $9 == "октябрь" {_n++; _s+=$3; pprriinntt $0}
       EENNDD  {
         pprriinnttff("Сумма: %d Среднее: %d\n",_s,_s/_n);}

       Напечатать строки, длина которых больше 40, в третьей
       и  четвертой  позициях  первого поля стоят цифры 58 и
       значение первого поля больше 22:

       $1>22 {
        iiff( lleennggtthh>40 && ssuubbssttrr($1,3,2)=="58" ) pprriinntt;}

       Напечатать поля в обратном  порядке  для  всех  строк
       входного файла:

       { ffoorr (_i = NNFF; _i > 0; --_i) pprriinntt $_i }

       Напечатать все строки, в которых первое поле  отлича-
       ется от первого поля предыдущей строки:

       $1 != _p_r_e_v { pprriinntt; _p_r_e_v = $1 }

       Напечатать все строки  от  строки  с  номером  10  до
       строки, пятое поле которой в последнем символе содер-
       жит либо цифру 7, либо цифру 9:

       NNRR == 10 , $5~/[79]$/

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
       _l_e_x(1), _s_e_d(1)

       Имеется отдельный документ по aawwkk.

ЗЗААММЕЕЧЧААННИИЯЯ
       Не существует явного преобразования между  числами  и
       строками.  Для  того,  чтобы выражение обрабатывалось
       как число, добавьте к нему 0, а для того,  чтобы  оно
       обрабатывалось  как строка, объедините его с "" (пус-
       той строкой) с помощью операции "пробел".















                            -7-                     ДЕМОС/PV

