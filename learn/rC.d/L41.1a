#print
Написать функцию
	bitct(x)
просматривающую биты в x и возвращающую число установленных
в единицу битов. Способов подсчета - множество. Приведем
два из них.
(1) обыкновенный. 16 раз сдвиньте слово x вправо (если Вы
работаете в ОС ДЕМОС), проверяя каждый раз самый правый бит
и подсчитывая число "единичных" битов.
(2) машинно-независимый (в чем-то). У операции "логическое И"
два аргумента: x и x-1, содержащих сам бит и на единицу меньший.
Можно устроить цикл по логическому И  до тех пор, пока не получим нуль.
Запрограммируйте любой из алгоритмов; скомпилируйте и проверьте
программу. Поместите ее в файл bitct.c и наберите "готов".
#once #create tzaqc.c
main()
{
int x;
x=23069;
if (bitct(x) != goodct(x)) return(1);
x=0;
if (bitct(x) != goodct(x)) return(1);
x=16384;
if (bitct(x) != goodct(x)) return(1);
x = -1;
if (bitct(x) != goodct(x)) return(1);
x= -200;
if (bitct(x) != goodct(x)) return(1);
return(0);
}
goodct(x)
{
int k, i;
for(k=i=0; i<16; i++)
	{
	k =+ (x&1);
	x= x>>1;
	}
return(k);
}
#user
cc tzaqc.c bitct.o
a.out
#succeed
/* возможное решение */
bitct(x)
{
	int k, i;

	for(i=k=0; i<16; i++) {
		if (x&1)
			k++;
		x >>= 1;
	}
	return(k);
}
/* между прочим, если Вы действительно заинтересовались
этой задачей, то табличный просмотр по всем байтам значительно
быстрее */
#log
#next
42.1a 10
