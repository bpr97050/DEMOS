
            дддд   ееееее   м     м    oooo     сссс
           д   д   е        мм   мм   o    o   с    с
          д    д   е        м м м м   o    o   с    с
          д    д   еееее    м  м  м   o    o   с
          д    д   е        м     м   o    o   с
          д    д   е        м     м   o    o   с    с
         дддддддд  ееееее   м     м    oooo     сссс



          демосдемосдемосдемосдемосдемосдемосдемосде
          емосдемосдемосдемосдемосдемосдемосдемосдем
          мо                                      мо
          ос                                      ос
          сд        ОПЕРАЦИОННАЯ СИСТЕМА          сд
          де                                      де
          ем               ДЕМОС                  ем
          мо                                      мо
          ос                                      ос
          сд                                      сд
          де             Версия 1.0               де
          ем                                      ем
          мо                                      мо
          сдемосдемосдемосдемосдемосдемосдемосдемосд
          демосдемосдемосдемосдемосдемосдемосдемосде







                     ОПИСАНИЕ ЯЗЫКА СИ







                  Руднев Алексей Петрович












                       МОСКВА - 1985









                                                           1













   Описан универсальный алгоритмический язык  программирова-
ния "Си". Приведены структура и синтаксис языка, правила на-
писания программ, даны начальные сведения  о  взаимодействии
программ на "Си" с операционной системой Демос.

















































2




                        1. ВВЕДЕНИЕ


   Язык "Си" - это универсальный язык программирования,  для
которого  характерны  экономичность  выражения,  современный
набор операторов и типов данных. Язык "Си"  не  является  ни
языком  "очень  высокого  уровня", ни "большим" языком, и не
предназначается для некоторой специальной  области  примене-
ния,  но  отсутствие ограничений и общность языка делают его
для многих задач более удобным  и  эффективным,  чем  языки,
предположительно  более мощные. Операционная система, компи-
лятор с языка "Си" и по существу  все  прикладные  программы
системы   "ДЕМОС"  написаны  на  "Си". Язык "Си" не связан с
какими-либо определенными аппаратными средствами или  систе-
мами, и на нем легко писать программы, которые можно пропус-
кать без изменений на любой ЭВМ, имеющей "Си"-компилятор.

   Язык "Си" является универсальным языком программирования.
Он  первоначально  появился  в  операционной системе UNIX, и
развивался как основной язык систем, совместимых с ОС  UNIX.
Сам язык , однако, не связан с какой-либо одной операционной
системой или машиной; и хотя его называют языком  системного
программирования, так как он удобен для написания операцион-
ных систем, он  может  использоваться  для  написания  любых
больших  вычислительных  программ,  программ  для  обработки
текстов и баз данных.

   Язык "Си" - это язык относительно "низкого  уровня".  Это
означает,  что "Си" имеет дело с об'ектами того же вида, что
и большинство ЭВМ, а именно, с символами, числами и  адреса-
ми.  Они могут об'единяться и пересылаться посредством обыч-
ных арифметических и логических операций, осуществляемых ре-
альными ЭВМ.

   В языке "Си" отсутствуют операции,  имеющие  дело  непос-
редственно  с составными об'ектами, такими как строки симво-
лов, множества, списки или с массивами, рассматриваемыми как
целое. Здесь, например, нет никакого аналога операциям PL/1,
оперирующим с массивами и строками.  Язык  не  предоставляет
никаких других возможностей распределения памяти, кроме ста-
тического определения и  механизма  стеков,  обеспечиваемого
локальными  переменных  функций.  Сам  по  себе язык "Си" не
обеспечивает никаких возможностей ввода-вывода. Все эти  ме-
ханизмы  высокого  уровня должны обеспечиваться явно вызыва-
емыми функциями.

   Аналогично, язык "Си" предлагает только простые, последо-
вательные конструкции управления: проверки, циклы, группиро-
вание и подпрограммы, но не  мультипрограммирование,  парал-
лельные операции, синхронизацию или сопрограммы.

   Удержание языка в скромных размерах дает реальные преиму-
щества.  Так  как "Си" относительно мал, он не требует много
места для своего описания и может быть быстро выучен. Компи-
лятор  с "Си" может быть простым и компактным. Это обеспечи-
вает  высокую  степень  мобильности  языка.  Поскольку  типы
данных  и  структуры  управления,  имеющиеся  в "Си", непос-
редственно  поддерживаются  большинством  существующих  ЭВМ,
библиотека, необходимая во время прогона изолированных прог-


                                                           3

рамм, оказывается очень маленькой. На СМ-4, например  ,  она
содержит  только программы для 32-битового умножения и деле-
ния и для упрятывания и восстановления регистров при входе в
функцию.  Конечно, каждая реализация обеспечивает исчерпыва-
ющую, совместимую библиотеку функций для выполнения операций
ввода-вывода, обработки строк и распределения памяти, но так
как обращение к ним осуществляется только явно, можно,  если
необходимо,  избежать их вызова; эти функции могут быть ком-
пактно написаны на самом "Си".

   Опять же из-за того, что язык "Си"  отражает  возможности
современных  компьютеров, программы на "Си" оказываются дос-
таточно эффективными, так что не возникает побуждения писать
вместо  этого программы на языке ассемблера. Хотя "Си" соот-
ветствует возможностям  многих ЭВМ, он не зависит от  какой-
либо конкретной архитектуры машины и в силу этого без особых
усилий позволяет писать "переносимые" программы, т.е.  прог-
раммы,  которые  можно пропускать без изменений на различных
аппаратных средствах.

   Язык "Си"  не является языком со строгими типами в смысле
паскаля  или алгола 68. Он сравнительно снисходителен к пре-
образованию данных, хотя и не  будет  буйно  преобразовывать
типы данных подобно языку PL/1. Компилятор не предусматрива-
ет никакой проверки индексов массивов,  типов  аргументов  и
т.д. во время выполнения программы.

   В тех ситуациях, когда желательна строгая проверка типов,
используется  специальная  программа "lint". Программа  lint
не генерирует машинного кода, а делает очень строгую провер-
ку  всех  тех сторон программы, которые можно проконтролиро-
вать во время компиляции и загрузки. Она определяет  несоот-
ветствие типов, несовместимость аргументов, неиспользованные
или очевидным образом неинициализированные  переменные,  по-
тенциальные трудности переносимости и т.д.

   Из за того, что в языке отсутствуют средства ввода/вывода
и т.п., при программировании на нем существенную роль играет
библиотека стандартных программ,  осуществляющих  взаимодей-
ствие с системой. Во всех системах, совместимых с ОС UNIX, к
которым относится  и  ДЕМОС,  существует  совместимый  набор
программ  для ввода/вывода, управления памятью, преобразова-
ния данных и выполняющих другие функции, использование кото-
рых  обеспечивает  возможность  переноса  программ на другие
ЭВМ.

   В данном документе описывается язык Си, расширения, обес-
печиваемые  специальным препроцессором (фактически они вошли
уже в понятие "язык Си"), стандартная библиотека ввода/выво-
да, и даются начальные сведения о взаимодействии программ на
Си с ОС ДЕМОС. Полное описание библиотечных программ имеется
в  руководстве программиста ОС ДЕМОС (части 3 и 4), и в опе-
ративной документации "man(2) и man(3)".  Хорошим  учебником
по  языку "Си" является книга [1], краткое формальное описа-
ние языка приведено в [2].


   В тексте встречаются примечания, относящиеся к реали-   |
зации  языка  Си в ОС ДЕМОС. Такие примечания выделяются   |
вертикальной чертой справа (как выделен данный абзац).     |




4




                 2. СИНТАКСИЧЕСКАЯ НОТАЦИЯ


   В используемой в этом руководстве синтаксической  нотации
синтаксические  категории  записываются  русскими  буквами и
символом "_", а все остальные  символы  рассматриваются  как
литерные  (то  есть  изображающие сами себя). Альтернативные
категории перечисляются на отдельных строчках.  Необязатель-
ный символ, терминальный или нетерминальный, указывается ин-
дексом "необ", так что

           { выражение      }
                      необ

указывает на необязательное выражение, заключенное в  фигур-
ных скобках. Синтаксис суммируется в приложении 1.

   Если описание не помещается на одной строке, оно  продол-
жается на следующей с некоторым сдвигом вправо, например:

  описание_структуры:
       спецификатор_типа
              список_описателей_структуры

Здесь следует читать:

 описание_структуры:
 спецификатор_типа список_описателей_структуры

































                                                           5




                   3. ЛЕКСИКА ЯЗЫКА 'СИ'


   Имеется шесть классов  лексем:  идентификаторы,  ключевые
слова,  константы,  строки,  операции  и другие разделители.
Пробелы, табуляции, новые строки и комментарии (они  называ-
ются  "символы пустых промежутков"), как описано ниже, игно-
рируются, за исключением тех случаев, когда они служат  раз-
делителями лексем. Всегда необходим какой-либо пустой проме-
жуток  для  разделения  идентификаторов,  ключевых  слов   и
констант, которые в противном случае сольются.

   Если сделан разбор входного потока на лексемы  вплоть  до
данного символа, то в качестве следующей лексемы берется са-
мая длинная строка символов, которая еще может  представлять
собой  лексему (это правило действует, например, при выделе-
нии констант).


   3.1. Комментарии


   Комментарий открывается символами /* и заканчивается сим-
волами */. Комментарии не вкладываются друг в друга.


   3.2. Идентификаторы (имена)


   Идентификатор  -  это  последовательность  букв  и  цифр;
первый символ должен быть буквой. Подчеркивание "_" считает-
ся буквой. Буквы нижнего и верхнего  регистров  различаются.
Значащими являются не более чем первые восемь символов, хотя
можно использовать и больше. На внешние идентификаторы,  ко-
торые  используются  различными ассемблерами и загрузчиками,
накладыватся более жесткие ограничения:

 CM-ЭВМ (ДЕМОС)    7 символов, 2 регистра
 IBM/370 (OS-360)  7 символов, 1 регистр
 VAX 11  (UNIX)    7 символов, 2 регистра



   3.3. Ключевые слова


   Следующие идентификаторы зарезервированы для  использова-
ния  в качестве ключевых слов и не могут использоваться иным
образом:

      int         extern          else
      char        register        for
      float       typedef         do
      double      static          while
      struct      goto            switch
      union       return          case
      long        sizeof          default
      short       break           entry
      unsigned    continue


6

      auto        if

Ключевое слово  entry  в  настоящее  время  не  используется
каким-либо компилятором; оно зарезервировано для использова-
ния в будущем. В некоторых реализациях  резервируются  также
слова fortran и asm.


   3.4. Константы


   Имеется несколько  видов  констант,  которые  перечислены
ниже.


   3.4.1. Целые константы


   Целая константа, состоящая  из  последовательности  цифр,
считается  восьмеричной,  если  она  начинается  с  0 (цифра
нуль), и десятичной в противном случае. Цифры 8  и  9  имеют
восьмеричные  значения   10  и 11 соответственно. Последова-
тельность цифр, которой предшествуют символы  0х  (нуль,  х-
маленькое)  или  0х  (нуль  X-большое),  рассматривается как
шестнадцатиричное целое.  Шестнадцатиричные  цифры  включают
буквы  от a (маленькое) или А (большое) до f (маленькое) или
F (большое) со значениями от 10 до 15. Десятичная константа,
величина которой превышает наибольшее машинное целое со зна-
ком, считается длинной; восьмеричная  или  шестнадцатиричная
константа,  которае  превышает наибольшее машинное целое без
знака, также считается длинной.


   3.4.2. Длинные (long) константы


   Десятичная, восьмеричная или шестнадцатиричная константа,
за  которой  непосредственно следует l (эль-маленькое) или L
(эль-большое), является длинной константой. На некоторых ма-
шинах  целые  и  длинные  значения могут рассматриваться как
идентичные.


   3.4.3. Символьные константы


   Символьная константа - это символ, заключенный в  одиноч-
ные   кавычки,  как,  например,  'х'.  Значением  символьной
константы является численное значение этого символа в машин-
ном представлении набора символов.

   Некоторые неграфические символы, одиночная  кавычка  '  и
обратная  косая черта \ могут быть представлены двумя симво-
лами в соответствии со следующей таблицей условных  последо-
вательностей:

  Название                 Код  Обозначение

 новая строка              012     \n
 горизонтальная табуляция  011     \т
 символ возврата на одну   010     \в
 позицию


                                                           7

 возврат каретки           015     \r
 переход на новую страницу 014     \f
 обратная косая черта      0133     \\
 одиночная кавычка         047     \'
 произвольный символ      0ddd     \ddd


   Условная  последовательность  \ddd  состоит  из  обратной
косой  черты,  за  которой  следуют  1, 2 или 3 восьмеричных
цифры, которые рассмативаются как задающие значение желаемо-
го  символа.  Специальным  случаем этой конструкции является
последовательность \0 (за нулем не следует  цифра),  которая
определяет  нулевой символ. Если следующий за обратной косой
чертой символ не совпадает с одним из указанных, то обратная
косая черта игнорируется.


   3.4.4. Вещественные константы


   Вещественная константа состоит из целой части, десятичной
точки,  дробной  части, буквы "e" (маленькая) или "E" (боль-
шая) и целой экспоненты с необязательным знаком. Как  целая,
так  и дробная часть являются последовательностью цифр. Либо
целая, либо дробная часть (но не обе)  может  отсутствовать;
либо  десятичная  точка,  либо "е"  и экспонента (но не то и
другое  одновременно)  может   отсутствовать.   Вещественные
константы  в  большинстве  реализаций  считаются константами
двойной точности.


   3.5. Строки


   Строка - это последовательность символов,  заключенная  в
двойные  кавычки,  как,  например,  "...".  Строка имеет тип
"массив символов" и класс памяти "static" (см. ниже). Строка
инициализирована  указанными  в  ней  символами. Все строки,
даже идентично записанные, считаются различными.  Компилятор
помещает  в конец каждой строки нулевой байт \0, с тем чтобы
просматривающая строку программа могла определить ее  конец.
Перед  стоящим  внутри  строки  символом двойной кавычки '"'
должен быть поставлен символ обратной косой черты  \;  кроме
того,  могут использоваться те же условные последовательнос-
ти, что и в символьных константах. Обратная косая  черта  \,
за  которой непосредственно следует символ новой строки, иг-
норируется.


   Имеются   макропроцессорные   средства,   позволяющие   |
об'единять  совпадающие  строки  при  трансляции с целью   |
экономии памяти (см. команду "xstr").                      |












8

   3.6. Характеристики аппаратных средств


   Следующая ниже таблица суммирует некоторые свойства аппа-
ратного  оборудования,  которые меняются от машины к машине.
Хотя они и влияют на переносимость программ, на практике они
представляют  меньшую проблему, чем это может казаться зара-
нее.

                                                  Таблица 1.
          -----------------------------------------
          |         CM-ЭВМ   IBM 370 (OS) VAX-11  |
          |           КОИ-8      ebcdic   ASCII   |
          | char      8 бит      8 бит    8 бит   |
          | int       16         32       32      |
          | short     16         16       16      |
          | long      32         32       32      |
          | float     32         32       32      |
          | double    64         64       64      |
          | range   -38/+38     -76/+76   -76/+76 |
          |_______________________________________|











































                                                           9




                   4. ОБ'ЕКТЫ ЯЗЫКА 'СИ'



   4.1. Интерпретация идентификаторов


   С каждым идентификатором в Си связано два  атрибута:  его
класс памяти и его тип. Класс памяти определяет место и вре-
мя хранения памяти, связанной с идентификатором; тип опреде-
ляет  смысл  величин, находящихся в памяти, определенной под
идентификатором.

   Имеются четыре класса памяти:  автоматическая,  статичес-
кая,  внешняя и регистровая. Автоматические переменные явля-
ются локальными для каждого вызова блока и исчезают при  вы-
ходе из этого блока. Статические переменные являются локаль-
ными, но сохраняют свои значения даже после того, как управ-
ление  передается  за  пределы блока. Внешние переменные су-
ществуют и сохраняют свои значения в течение выполнения всей
программы  и могут использоваться для связи между функциями,
в том числе и между независимо скомпилированными  функциями.
Регистровые   переменные  хранятся  (если  это  возможно)  в
быстрых регистрах машины; подобно автоматическим  переменным
они являются локальными для каждого блока и исчезают при вы-
ходе из этого блока.

   В  языке  "Си"  предусмотрено  несколько  основных  типов
об'ектов:

Символьный.
   - Об'екты, описанные как символы (char), достаточно вели-
     ки, чтобы хранить любой член из соответствующего данной
     реализации внутреннего набора символов, и если действи-
     тельный символ из этого набора символов хранится в сим-
     вольной переменной, то ее значение эквивалентно  целому
     коду  этого символа. В символьных переменных можно хра-
     нить и другие величины, но  реализация  будет  машинно-
     зависимой.  (На  СМ  ЭВМ значение символьных переменных
     изменяется от -0177 до 0177.)

Целый.
   - Можно использовать до трех размеров целых,  описываемых
     как  short  int, int и long int. Длинные целые занимают
     не меньше памяти, чем короткие, но в конкретной  реали-
     зации  может  оказаться,  что либо короткие целые, либо
     длинные целые, либо  те  и  другие  будут  эквивалентны
     простым   целым.  "Простые"  целые  имеют  естественный
     размер, предусматриваемый архитектурой используемой ма-
     шины; другие размеры вводятся для удовлетворения специ-
     альных потребностей.

Беззнаковый.
   - Целые без знака, описываемые как unsigned,  подчиняются
     законам  арифметики по модулю 2**n, где n - число битов
     в их представлении. (На  CM-ЭВМ  длинные  величины  без
     знака не предусмотрены).




10

Вещественный.
   - Вещественные одинарной точности (float) и  вещественные
     двойной точности (double) в некоторых реализациях могут
     быть синонимами. (На СМ ЭВМ float занимает 32 бита  па-
     мяти, а double - 64).

В языке нет логического типа данных, а в качестве логических
значений  используются  целые  "0" - "ложь" и "1" - "истина"
(при проверках любое целое, не равное 0, трактуется как "ис-
тина").

   Поскольку об'екты упомянутых выше типов могут быть разум-
но  интерпретированы  как  числа,  эти типы будут называться
арифметическими. Типы char и  int  всех  размеров  совместно
будут  называться  целочисленными.  Типы float и double сов-
местно будут называться вещественными типами.

   Кроме основных арифметических типов существует  концепту-
ально бесконечный класс производных типов, которые образуют-
ся из основных типов следующим образом:

   - массивы об'ектов большинства типов;

   - функции, которые возвращают об'екты заданного типа;

   - указатели на об'екты данного типа;

   - структуры, содержащие последовательность об'ектов  раз-
     личных типов;

   - об'единения, способные  содержать  один  из  нескольких
     об'ектов различных типов.

   Вообще говоря, эти методы построения об'ектов могут  при-
меняться рекурсивно.


   4.2. Об'екты и l_значения


   Об'ект  является  доступным  обработке  участком  памяти;
l_значение  (левое значение) - это выражение, ссылающееся на
об'ект. Очевидным  примером  выражения  l_значения  является
идентификатор.  Существуют операции, результатом которых яв-
ляются l_значения; если, например, e - выражение типа указа-
тель,  то  *e является выражением l_значения, ссылающимся на
тот об'ект, на который указывает  е.  Название  "l_значение"
происходит  от выражения присваивания е1=е2, в котором левая
часть должна быть выражением l_значения. При последующем об-
суждении  каждой  операции будет указываться, ожидает ли она
операндов l_значения и выдает ли она l_значение.


   4.3. Преобразования


   Ряд операций может в зависимости от своих операндов вызы-
вать  преобразование значения операнда из одного типа в дру-
гой. В этом разделе об'ясняются результаты, которые  следует
ожидать  от  таких  преобразований. В конце подводятся итоги
преобразований, требуемые большинством обычных операций; эти
сведения  дополняются  необходимым  образом  при  обсуждении


                                                          11

каждой операции.


   4.3.1. Символы и целые


   Символ или короткое целое можно использовать  всюду,  где
можно  использовать целое. Во всех случаях значение преобра-
зуется  к целому. Преобразование более  короткого  целого  к
более  длинному  всегда сопровождается знаковым расширением;
целые являются величинами со знаком.  Осуществляется или нет
знаковое  расширение  для  символов, зависит от используемой
машины, на СМ-ЭВМ такое преобразование  осуществляется,  так
что  русские буквы при прямом преобразовании получат отрица-
тельные коды.  Область  значений  символьных  переменных  на
CM-ЭВМ меняется от -128 до 127; символы из набора ASCII име-
ют положительные значения. Символьная константа, заданная  с
помощью  восьмеричной условной последовательности, подверга-
ется знаковому расширению и может  оказаться  отрицательной;
например, '\377' имеет значение -1.

   Когда более длинное целое преобразуется в более  короткое
или  в char, оно обрезается слева; лишние биты просто отбра-
сываются.


   4.3.2. Типы float и double -  вещественной  и  двойной
          точности.


   Вся вещественная арифметика в "Си" выполняется с  двойной
точностью.  Каждый раз, когда об'ект типа float появляется в
выражении, он удлиняется до  double  посредством  добавления
нулей  в  его дробную часть. Когда об'ект типа double должен
быть преобразован к типу float, например, при  присваивании,
перед усечением double округляется до длины float.


   Единственное исключение может быть сделано в компиля-   |
торах  для  ЭВМ,  на которых нет аппаратных операций над   |
числами типа "double"  (например,  СМ-4).  Уточнить  это   |
можно по описанию компилятора (команда "cc").              |



   4.3.3. Вещественные и целочисленные величины


   Преобразование  вещественных  значений  к  целочисленному
типу в некоторой степени машинно-зависимо; в частности, нап-
равление усечения отрицательных чисел меняется от  машине  к
машине.  Результат не определен, если значение не помещается
в предоставляемое пространство.

   Преобразование целочисленных значений в вещественные  вы-
полняется  без  осложнений. Может произойти некоторая потеря
точности, если для результата не хватит длины мантиссы.







12

   4.3.4. Указатели и целые


   Целое или длинное целое может быть прибавлено к указателю
или  вычтено из него; в этом случае первая величина преобра-
зуется так, как указывается в  описании операции сложения.

   Два указателя на об'екты одинакового типа могут быть выч-
тены;  в  этом  случае результат преобразуется к целому, как
указывается в описании операции вычитания.


   4.3.5. Целое без знака


   Всякий раз, когда целое без знака об'единяется с  простым
целым,  простое  целое преобразуется в целое без знака и ре-
зультат оказывается целым без знака. Значением является  на-
именьшее  целое  без знака, соответствующее целому со знаком
(по  модулю  2**размер  слова).  В  двоичном  дополнительном
представлении  это преобразование является чисто умозритель-
ным и не изменяет фактическую комбинацию битов.

   Когда целое без знака преобразуется к типу long, значение
результата  совпадает  со  значением целого без знака. Таким
образом, это преобразование сводится к добавлению нулей сле-
ва.


   4.3.6. Арифметические преобразования


   Подавляющее большинство операций вызывает  преобразование
и определяет типы результата аналогичным образом. Приводимая
ниже схема в дальнейшем будет называться "обычными арифмети-
ческими преобразованиями".

1)  Сначала любые операнды типа char или short преобразуются
    в  int,  а  любые  операнды  типа  float преобразуются в
    double.

2)  Затем, если какой-либо операнд имеет тип double, то дру-
    гой  преобразуется  к типу double, и это будет типом ре-
    зультата.

3)  В противном случае, если какой-либо  операнд  имеет  тип
    long, то другой операнд преобразуется к типу long, и это
    и будет типом результата.

4)  В противном случае, если какой-либо  операнд  имеет  тип
    unsigned,   то   другой  операнд  преобразуется  к  типу
    unsigned, и это будет типом результата.

5)  В противном случае оба операнда будут иметь тип  int,  и
    это будет типом результата.









                                                          13




                        5. ВЫРАЖЕНИЯ


   Старшинство операций в выражениях  совпадает  с  порядком
следования  основных подразделов настоящего раздела, начиная
с самого высокого уровня старшинства. Так, например, выраже-
ниями,   указываемыми  в  качестве  операндов  операции  "+"
(п.5.4), являются  выражения,  определенные  в  п.п.5.1-5.3.
Внутри  каждого  подраздела  операции имеют одинаковое стар-
шинство. В каждом подразделе для  описываемых  там  операций
указывается их ассоциативность слева или справа. Старшинство
и ассоциативность всех операций в выражениях резюмируются  в
грамматической сводке в приложении.

   В противном случае порядок вычислений выражений не  опре-
делен.  В частности, компилятор может вычислять подвыражения
в том порядке, который он находит наиболее эффективным, даже
если эти подвыражения приводят к побочным эффектам. Порядок,
в котором происходят побочные эффекты,  не  специфицируется.
Выражения, включающие коммутативные и ассоциативные операции
( "*","+","&","|","^"), могут  быть  переупорядочены  произ-
вольным образом даже при наличии круглых скобок; в этом слу-
чае необходимо использовать явные промежуточные переменные.

   При вычислении выражений обработка переполнения и провер-
ка при делении являются машинно-зависимыми. Большинство  ре-
ализаций языка "Си" (в том числе и в  ОС  ДЕМОС)  игнорируют
переполнение  целых; обработка ошибки при делении на 0 и при
всех особых случаях в операциях с вещественными числами  ме-
няется  от  машины  к  машине и обычно выполняется с помощью
библиотечной функции.


   5.1. Первичные выражения


   Первичные выражения, включающие ".", "->",  индексацию  и
обращения к функциям, группируются слева направо.

первичное выражение:
   идентификатор
   константа
   строка
   (выражение)
   первичное_выражение  [выражение]
   первичное_выражение  (список_выражений)
                                       необ
   первичное_l_значение . Идентификатор
   первичное_выражение -> идентификатор
список_выражений:
   выражение
   список_выражений, выражение

Идентификатор является первичным выражением при условии, что
он  описан подходящим образом, как это обсуждается ниже. Тип
идентификатора определяется  его  описанием.  Если,  однако,
типом идентификатора является "массив ...", то значением вы-
ражения, состоящего из этого идентификатора, является указа-
тель  на  первый  об'ект  в  этом массиве, а типом выражения


14

будет "указатель на ...". Более того, идентификатор  массива
не  является  выражением  l_значения.  Подобным  образом ин-
терпретируется идентификатор, который описан  как  "функция,
возвращающая  ...". За исключением того случая, когда он ис-
пользуется в позиции имени функции при обращении, преобразу-
ется в "указатель на функцию, которая возвращает ...".

   Константа является первичным выражением. В зависимости от
ее формы типом константы может быть int, long или double.

   Строка является первичным выражением. Исходным  ее  типом
является "массив символов"; но следуя тем же самым правилам,
которые приведены выше для идентификаторов, он модифицирует-
ся  в  "указатель на символы", и результатом является указа-
тель на первый символ строки. (имеется исключение в  некото-
рых инициализаторах; см. ниже.)

   Выражение в круглых скобках является первичным  выражени-
ем,  тип и значение которого идентичны типу и значению этого
выражения без скобок. Наличие круглых скобок  не  влияет  на
то, является ли выражение l_значением или нет.

   Первичное выражение, за которым следует выражение в квад-
ратных скобках, является первичным выражением. Это выражение
с индексом. Обычно первичное выражение имеет тип  "указатель
на  ...", индексное выражение имеет тип int, а типом резуль-
тата является "...". Выражение e1[e2] по  определению  иден-
тично выражению * ((e1) + (e2)). Все, что необходимо для по-
нимания этой записи, содержится  в  этом  разделе;  вопросы,
связанные  с  понятием  идентификаторов  и  операций  *  и +
рассматриваются в п.п. 5.1, 5.2 и 5.4 соответственно; выводы
суммируются ниже.

   Обращение к функции является первичным выражением, за ко-
торым  следует  заключенный в круглые скобки возможно пустой
список выражений, разделенных запятыми, которые и  представ-
ляют  собой фактические аргументы функции. Первичное выраже-
ние должно быть типа "функция, возвращающая ...", а  резуль-
тат  обращения  к  функции  имеет тип "...". Как указывается
ниже, ранее не встречавщийся идентификатор, за  которым  не-
посредственно  следует  левая круглая скобка, считается опи-
санным по контексту, как представляющий  функцию,  возвраща-
ющую  целое;  следовательно  чаще всего встречающийся случай
функции, возвращающей целое значение, не нуждается в  описа-
нии.

   Перед обращением любые фактические аргументы  типа  float
преобразуются  к  типу double, любые аргументы типа char или
short преобразуются к типу int, и, как обычно, имена  масси-
вов преобразуются в указатели. Никакие другие преобразования
не выполняются автоматически; в частности,  не  сравниваются
типы  фактических аргументов с типами формальных аргументов.
Если преобразование необходимо, используйте явное преобразо-
вание.

   При подготовке к вызову функции  делается  копия  каждого
фактического параметра; таким образом, все передачи аргумен-
тов в языке "Си" осуществляются строго по значению.  Функция
может  изменять значения своих формальных параметров, но эти
изменения не влияют на значения  фактических  параметров.  С
другой  стороны,  имеется  возможность передавать указатель,
при этом функция может изменять значение об'екта, на который


                                                          15

этот  указатель  указывает.  Порядок вычисления аргументов в
языке не определен; различные компиляторы вычисляют по  раз-
ному.

   Допускаются рекурсивные обращения к любой функции.

   Первичное выражение, за которым следует точка и идентифи-
катор,  является  выражением.  Первое  выражение должно быть
l_значением, именующим структуру или об'единение, а  иденти-
фикатор  должен быть именем члена структуры или об'единения.
Результатом является l_значение, ссылающееся на  поименован-
ный член структуры или об'единения.

   Первичное выражение, за которым следует стрелка  (состав-
ленная  из знаков "-" и ">") и идентификатор, является выра-
жением. Первое выражение должно быть указателем на структуру
или  об'единение, а идентификатор должен именовать член этой
структуры или об'единения. Результатом является  l_значение,
ссылающееся на поименованный член структуры или об'единения,
на который указывает указательное выражение.

   Следовательно, выражение e1->mos является тем  же  самым,
что  и выражение (*e1).mos. Структуры и об'единения рассмат-
риваются  ниже.  Приведенные  здесь  правила   использования
структур и об'единений не навязываются строго, для того что-
бы иметь возможность обойти механизм  типов  (см.  "Дополни-
тельная информация о типах").


   5.2. Унарные операции


   Выражение с унарными операциями группируется справо нале-
во.

   унарное_выражение:
             *  выражение
             &  l_значение
             -  выражение
             !  Выражение
             ~ выражение
             ++ l_значение
             -- l_значение
             l_значение ++
             l_значение --
             (имя-типа) выражение
             sizeof     выражение
             sizeof    (имя_типа)

Унарная операция "*" означает косвенную адресацию: выражение
должно  быть  указателем, а результатом является l_значение,
ссылающееся на тот об'ект, на который  указывает  выражение.
Если  типом  выражения  является "указатель на...", то типом
результата будет "...".

   Результатом унарной операции "&"  является  указатель  на
об'ект,  к  которому  ссылается  l_значение. Если l_значение
имеет тип "...", то типом  результата  будет  "указатель  на
...".

   Результатом унарной операции "-" (минус) является ее опе-
ранд,  взятый  с  противоположным  знаком. Для величины типа


16

unsigned результат получается вычитанием ее значения из 2**n
(два в степени n), где n-число битов в int. Унарной операции
"+" (плюс) не существует.

   Результатом операции логического отрицания  "!"  является
1,  если значение ее операнда равно 0, и 0, если значение ее
операнда отлично от нуля. Результат имеет тип int. Эта  опе-
рация  применима  к любому арифметическому типу или указате-
лям.

   Операция "~" (символ "тильда", находится на клавише "^" в
нижнем регистре) дает обратный код, или дополнение до едини-
цы, своего операнда. Выполняются обычные арифметические пре-
образования. Операнд должен быть целочисленного типа.

   Об'ект,на который ссылается операнд l_значения префиксной
операции  "++", увеличивается. Значением является новое зна-
чение операнда, но это не l_значение. Выражение ++х  эквива-
лентно х += 1 . Информацию о преобразованиях смотри в разбо-
ре операции сложения (п. 5.4) и  операции  присваивания  (п.
5.14).

   Префиксная операция "--" аналогична  префиксной  операции
"++", но приводит к уменьшению своего операнда l_значения.

   При применении постфиксной операции "++" к l_значению ре-
зультатом  является  значение  об'екта, на который ссылается
l_значение. После того, как  результат  принят  к  сведению,
об'ект  увеличивается точно таким же образом, как и в случае
префиксной операции ++. Результат имеет тот же  тип,  что  и
выражение l_значения.

   При применении постфиксной операции "--" к l_значению ре-
зультатом  является  значение  об'екта, на который ссылается
l_значение. После того, как  результат  принят  к  сведению,
об'ект  уменьшается  точно  таким же образом, как и в случае
префиксной операции "--". Результат имеет тот же тип, что  и
выражение l_значения.

   Заключенное в круглые скобки  имя  типа  данных,  стоящее
перед выражением, вызывает преобразование значения этого вы-
ражения  к указанному типу. Эта конструкция называется пере-
вод (cast). Имена типов описываются в следующем разделе.

   Операция sizeof выдает размер своего операнда  в  байтах.
(понятие байт в языке не определено, разве только как значе-
ние операции sizeof. Однако во всех существующих реализациях
байтом   является  пространство,  необходимое  для  хранения
об'екта типа char). При применении к массиву результатом яв-
ляется полное число байтов в массиве. Размер определяется из
описаний об'ектов в выражении.  Это  выражение  семантически
является  целой константой и может быть использовано в любом
месте, где требуется константа. Основное применение эта опе-
рация  находит при вызове процедур, подобных распределителям
памяти, и в системах ввода- вывода.

   Операция sizeof может быть также применена и к  заключен-
ному  в  круглые скобки имени типа. В этом случае она выдает
размер в байтах об'екта указанного типа.

   Конструкция sizeof (тип) рассматривается как  целое,  так
что   выражение  "sizeof (тип) - 2"  эквивалентно  выражению


                                                          17

"(sizeof (тип)) - 2".


   5.3. Мультипликативные операции


   Мультипликативные операции "*", "/", и  "%"  группируются
слева направо. Выполняются обычные арифметические преобразо-
вания.

   мультипликативное_выражение:
            выражение * выражение
            выражение / выражение
            выражение % выражение


   Бинарная операция "*" означает  умножение.  Операция  "*"
ассоциативна, и выражения с несколькими умножениями на одном
и том же уровне могут быть перегруппированы компилятором.

   Бинарная операция "/" означает деление. При делении поло-
жительных  целых  осуществляется  усечение  по направлению к
нулю, но если один из операндов отрицателен, то форма усече-
ния  зависит  от  используемой  машины. Остаток имеет тот же
знак, что и делимое.  Всегда  справедливо,  что  (a/b)*b+a%b
равно a (если  b не равно 0).

   Бинарная операция "%" выдает остаток от  деления  первого
выражения на второе. Выполняются обычные арифметические пре-
образования. Операнды должны быть целого типа.


   5.4. Аддитивные операции


   Аддитивные операции "+" и "-" группируются слева направо.
Выполняются   обычные   арифметические  преобразования.  Для
каждой операции имеются некоторые дополнительные  возможнос-
ти, связанные с типами операндов.

     аддитивное_выражение:
          выражение + выражение
          выражение - выражение


Результатом операции "+"  является  сумма  операндов.  Можно
также  складывать  указатель  на об'ект в массиве и значение
любого целочисленного типа. Последнее преобразуется в адрес-
ное  смещение посредством умножения его на длину об'екта, на
который указывает этот указатель. Результатом является  ука-
затель  того же самого типа, что и исходный указатель, кото-
рый указывает на другой об'ект в том же  массиве,  смещенный
соответствующим  образом относительно первоначального об'ек-
та. Таким образом, если p является указателем об'екта в мас-
сиве,  то  выражение  p+1  является  указателем на следующий
об'ект в этом массиве.

   Никакие другие комбинации типов для указателей не  разре-
шаются.

   Операция "+" ассоциативна, и выражение с несколькими сло-
жениями  на одном и том же уровне могут быть переупорядочены


18

компилятором.

   Результатом операции  "-"  является  разность  операндов.
Выполняются  обычные  арифметические  преобразования.  Кроме
того, из указателя может быть вычтено значение любого  цело-
численного типа, причем, проводятся те же самые преобразова-
ния, что и при операции сложения.

   Если вычитаются  два  указателя  на  об'екты  одинакового
типа, то результат преобразуется (делением на длину об'екта)
к типу int, представляя собой  число  об'ектов,  разделяющих
указываемые об'екты. Если эти указатели не на об'екты из од-
ного и того же массива, то такое преобразование, вообще  го-
воря, даст неожиданные результаты, потому что даже указатели
на об'екты одинакового типа не обязаны отличаться на величи-
ну, кратную длине об'екта.


   5.5. Операции сдвига


   Операции сдвига "<<" и ">>" группируются  слева  направо.
Для  обеих операций проводятся обычные арифметические преоб-
разования их операндов, каждый из которых должен быть  цело-
численного  типа.  Затем правый операнд преобразуется к типу
int; результат имеет тип левого операнда. Результат не опре-
делен, если правый операнд отрицателен или больше или равен,
чем длина об'екта в битах.

    выражение_сдвига:
          выражение << выражение
          выражение >> выражение

Значением выражения e1<<e2 является e1 (интерпретируемое как
комбинация  битов),  сдвинутое влево на e2 битов; освобожда-
ющиеся биты заполняются нулем.  Значением  выражения  e1>>e2
является e1, сдвинутое вправо на e2 битовых позиций. Если e1
имеет тип unsigned, то сдвиг вправо гарантированно будет ло-
гическим  (заполнение нулем); в противном случае сдвиг может
быть (и так и есть на CM-ЭВМ) арифметическим  (освобождающи-
еся биты заполняются копией знакового бита).


   5.6. Операции отношения


   Операции отношения группируются слева  направо,  но  этот
факт не очень полезен; выражение a<b<c не означает того, что
оно ,казалось бы, должно означать, а означает ((a<b)<c).

     выражение_отношения:
          выражение < выражение
          выражение > выражение
          выражение <= выражение
          выражение >= выражение

Операции "<" (меньше), ">" (больше), "<=" (меньше или равно)
и  ">=" (больше или равно)  дают 0, если указанное отношение
ложно, и 1, если  оно  истинно.  Результат  имеет  тип  int.
Выполняются  обычные  арифметические  преобразования.  Могут
сравниваться два указателя; результат зависит от относитель-
ного    расположения   указываемых   об'ектов   в   адресном


                                                          19

пространстве. Сравнение указателей переносимо только  в  том
случае, если указатели указывают на об'екты из одного и того
же массива.


   5.7. Операции равенства


     выражение_равенства:
          выражение == выражение
          выражение != выражение

Операции "==" (равно) и "!=" (не равно) в точности аналогич-
ны  операциям  отношения, за исключением того, что они имеют
более низкий уровень старшинства. (поэтому значение  выраже-
ния  а<в==с<d  равно 1 всякий раз, когда выражения а<в и с<d
имеют одинаковое значение истинности).

   Указатель можно сравнивать с целым,  но  результат  будет
машинно-независимым только в том случае, если целым является
константа 0. Гарантируется, что указатель, которому  присво-
ено  значение 0, не указывает ни на какой об'ект  и на самом
деле оказывается равным 0; общепринято считать такой  указа-
тель нулем.


   5.8. Побитовая операция 'и'


     выражение_и:
          выражение & выражение

Операция "&" является ассоциативной, и включающие "&"  выра-
жения  могут  быть переупорядочены компилятором. Выполняются
обычные арифметические преобразования; результатом  является
побитовая  функция  'и'  операндов.  Эта  операция применима
только к операндам целочисленного типа.


   5.9. Побитовая операция исключающего 'или'


     выражение_исключающего_или:
          выражение ^ выражение

Операция "^" (знак надчеркивания, код в КОИ-8  0136) являет-
ся  ассоциативной, и включающие "^" выражения могут быть пе-
реупорядочены компилятором. Выполняются обычные арифметичес-
кие  преобразования;  результатом является побитовая функция
исключающего 'или' операндов. Операция  применима  только  к
операндам целочисленного типа.


   5.10. Побитовая операция включающего 'или'


     выражение_включающего_или:
          выражение | выражение


Операция "|" является ассоциативной, и содержащие "|"  выра-
жения  могут быть переупорядочены. Выполняются обычные ариф-


20

метические преобразования;  результатом  является  побитовая
функция  включающего  'или'  операндов.  Операция  применима
только к операндам целочисленного типа.


   5.11. Логическая операция 'и'


     выражение_логического_и:
          выражение && выражение

Операция "&&" группируется слева направо. Она возвращает  1,
если  оба  ее операнда отличны от нуля, и 0 в противном слу-
чае. В отличие от "&" операция "&&"  гарантирует  вычисление
слева  направо;  более того, если первый операнд равен 0, то
значение второго операнда вообще не вычисляется

   Операнды не обязаны быть одинакового типа, но  каждый  из
них должен быть либо одного из основных типов, либо указате-
лем. Результат всегда имеет тип int.


   5.12. Операция логического 'или'


         выражение_логического_или:
              выражение || выражение

Операция "||" группируется слева направо. Она возвращает  1,
если один из операндов отличен от нуля, и 0 в противном слу-
чае. В отличие от операции "|" операция "||" гарантирует вы-
числение  слева направо; более того, если первый операнд от-
личен от нуля, то значение второго операнда вообще не вычис-
ляется.

   Операнды не обязаны быть одинакового типа, но  каждый  из
них должен быть либо одного из основных типов, либо указате-
лем. Результат всегда имеет тип int.


   5.13. Условная операция


   условное_выражение:
        выражение ? выражение : выражение

Условные выражения группируются слева  направо.  Вычисляется
значение  первого  выражения, и если оно отлично от нуля, то
результатом будет значение второго  выражения;  в  противном
случае  результатом  будет значение третьего выражения. Если
это возможно, проводятся обычные арифметические преобразова-
ния, с тем, чтобы привести второе и третье выражения к обще-
му типу; в противном случае,  если  оба  выражения  являются
указателями одинакового типа, то результат имеет тот же тип;
в противном случае одно выражение должно быть указателем,  а
другое  - константой 0, и результат будет иметь тип указате-
ля. Вычисляется только одно из второго и третьего выражений.







                                                          21

   5.14. Операция присваивания


   Имеется ряд  операций  присваивания,  каждая  из  которых
группируется  слева направо. Все операции требуют в качестве
своего левого операнда l_значение, а типом выражения присва-
ивания является тип его левого операнда. Значением выражения
присваивания является значение, хранимое  в  левом  операнде
после  того,  как  присваивание  уже  будет произведено. Две
части составной операции  присваивания  являются  отдельными
лексемами.

  выражение_присваивания:
          l_значение = выражение
          l_значение += выражение
          l_значение -= выражение
          l_значение *= выражение
          l_значение /= выражение
          l_значение %= выражение
          l_значение >>= выражение
          l_значение <<= выражение
          l_значение &= выражение
          l_значение ^= выражение
          l_значение |= выражение


   Когда производится простое присваивание '=', значение вы-
ражения  заменяет  значение  об'екта,  на  которое ссылается
l_значение. Если оба операнда имеют арифметический  тип,  то
перед  присваиванием правый операнд преобразуется к типу ле-
вого операнда.

   В выражение вида e1 оп= e2, где оп - одна из  перечислен-
ных выше операций, эквивалентно выражению e1 = e1 оп (e2), с
тем отличием, что выражение e1 вычисляется только один  раз.
В  случае операций += и -= левый операнд может быть указате-
лем, причем при этом (целочисленный) правый операнд преобра-
зуется  таким  образом,  как  об'яснено в п. 5.4; все правые
операнды и все отличные от указателей левые операнды  должны
иметь арифметический тип.

   Используемые в ОС ДЕМОС  компиляторы допускают присваива-
ние указателя целому, целого указателю и указателя указателю
другого типа. Такое присваивание является чистым копировани-
ем  без каких-либо преобразований. Такое употребление опера-
ций присваивания является непереносимым и может приводить  к
указателям,  которые при использовании вызывают ошибки адре-
сации. Тем не менее гарантируется, что присваивание указате-
лю  константы  0 дает нулевой указатель, который можно отли-
чать от указателя на любой об'ект.


   5.15. Присваивание структуры


   Структуры могут быть присвоены, а также переданы функциям
в  качестве аргументов и возвращены функциями. Типы участву-
ющих операндов должны совпадать.






22

   5.16. Операция 'запятая'


     выражение_с_запятой:
          выражение , выражение

Пара выражений, разделенных запятой, вычисляется слева  нап-
раво и значение левого выражения отбрасывается. Типом и зна-
чением результата является тип и значение правого  операнда.
Эта  операция  группируется  слева направо. В контексте, где
запятая имеет специальное значение, как, например, в  списке
фактических  аргументов функций  или в списках инициализато-
ров, операция запятая, описываемая в этом разделе, может по-
являться только в круглых скобках; например, функция

       f(a,(t=3,t+2),c)

имеет три аргумента, второй из которых имеет значение 5.


   5.17. Старшинство и порядок вычисления.


   В приводимой ниже таблице сведены правила  старшинства  и
ассоциативности всех операций. Операции, расположенные в од-
ной строке, имеют один и тот же уровень старшинства;  строки
расположены  в  порядке убывания старшинства. Так, например,
операции "*", "/"  и  "%"  имеют  одинаковый  уровень  стар-
шинства, который выше, чем уровень операций "+" и "-".



































                                                          23


                                                   Таблица 1
------------------------------------------
| Оператор           |   Ассоциативность |
|____________________|___________________|
| () [] -> .         |   слева направо   |
|____________________|___________________|
| ! ~   ++  --  -  f |   справа налево   |
|(type)  *  &  sizeof|                   |
|____________________|___________________|
| *  /  %            |   слева направо   |
|____________________|___________________|
| +  -               |   слева направо   |
|____________________|___________________|
| <<  >>             |   слева направо   |
|____________________|___________________|
| <  <=  >  >=       |   слева направо   |
|____________________|___________________|
| ==  !=             |   слева направо   |
|____________________|___________________|
| &                  |   слева направо   |
|____________________|___________________|
| ^                  |   слева направо   |
|____________________|___________________|
| |                  |   слева направо   |
|____________________|___________________|
| &&                 |   слева направо   |
|____________________|___________________|
| ||                 |   слева направо   |
|____________________|___________________|
| ?:                 |   справа налево   |
|____________________|___________________|
| =  +=  -=  и т.п.  |   справа налево   |
|____________________|___________________|
| ,                  |   слева направо   |
|____________________|___________________|


   Отметим, что  уровень  старшинства  побитовых  логических
операций &, ^ и | ниже уровня операций == и !=. Это приводит
к тому, что осуществляющие побитовую проверку выражения, по-
добные

        if ((х & mask) == 0) ...

для получения правильных результатов  должны  заключаться  в
круглые скобки, в противном случае оно будет понято так:

выражение:    x &   mask == 0
понято как:   x & ( mask == 0 )














24




                        6. ОПИСАНИЯ


   Описания используются для указания интерпретации, которую
язык "Си" будет давать каждому идентификатору; они не обяза-
тельно резервируют память,  соответствующую  идентификатору.
Описания имеют форму

описание:
  спецификаторы_описания список_описателей;
                                       необ

Описатели в списке описателей содержат описываемые идентифи-
каторы. Спецификаторы описания представляют собой последова-
тельность спецификаторов типа и спецификаторов класса  памя-
ти.

 Спецификаторы_описания:
    с_типа с_описания
                    необ
    с_класса_памяти с_описания
                             необ
где c_... - спецификатор_...

Список описателей должен быть согласованным в смысле, описы-
ваемом ниже.


   6.1. Спецификаторы класса памяти


   ниже перечисляются спецификаторы класса памяти:

   спецификатор_класса_памяти:
             auto
             static
             extern
             register
             typedef


   Спецификатор typedef не резервирует память  и  называется
"спецификатором  класса памяти" только по синтаксическим со-
ображениям; это обсуждается ниже.  Смысл  различных  классов
памяти был обсужден ранее (см. "Об'екты языка 'Си'").

   Описания auto, static и register служат также в  качестве
определений  в  том  смысле, что они вызывают резервирование
нужного количества  памяти.  В  случае  extern  должно  при-
сутствовать  внешнее определение указываемых идентификаторов
где то вне функции, в которой они описаны.

   Описание register лучше всего представлять себе как  опи-
сание auto вместе с намеком компилятору, что описанные таким
образом переменные будут  часто  использоваться.  Эффективны
только  несколько  первых  таких описаний. Кроме того, в ре-
гистрах  могут  храниться  только  переменные   определенных
типов;  на  CM-ЭВМ это int, char или указатель. Существует и
другое ограничение на использование регистровых  переменных:


                                                          25

к  ним  нельзя применять операцию взятия адреса "&". При ра-
зумном использовании регистровых описаний можно ожидать  по-
лучения  меньших  по  размеру и более быстрых программ, но в
будующем улучшение генерирования кодов может сделать их  не-
нужными.


   В компиляторе для СМ ЭВМ воспринимаются первые 3 опи-   |
сания register в каждой функции.                           |


   Описание может содержать не  более  одного  спецификатора
класса памяти. Если описание не содержит спецификатора клас-
са памяти, то считается, что он имеет  значение  auto,  если
описание находится внутри некоторой функции, и extern в про-
тивном случае. Исключение: функции никогда не бывают автома-
тическими.


   6.2. Спецификаторы типа


   Ниже перечисляются спецификаторы типа.

спецификатор_типа:
    char
    short
    int
    long
    unsigned
    float
    double
    спецификатор_структуры_или_об'единения
    спецификатор_перечисления
    определяющее_тип_имя

Слова long, short и unsigned можно рассматривать как  прила-
гательные; допустимы следующие комбинации:

      short int
      long int
      usigned int
      long float

Последняя комбинация означает то же, что и double. В осталь-
ном  описание  может содержать не более одного спецификатора
типа. Если описание не содержит спецификатора типа, то  счи-
тается, что он имеет значение int.

   Спецификаторы структур и  об'единений  обсуждаются  в  п.
6.5,  спецификация  перечислимого типа - в п.6.6; описания с
определяющими тип именами typedef обсуждаются в п. 6.9.


   6.3. Описатели


   Входящий в описание список описателей представляет  собой
последовательность  разделенных  запятыми описателей, каждый
из которых может иметь инициализатор.




26

 список_описателей:
       инициализируемый_описатель
       инициализируемый_описатель,спи-
                          сок_описателей
 инициализируемый_описатель:
       описатель инициализатор
                           необ

Инициализаторы описываются в п.6.6. Спецификаторы и описания
указывают  тип и класс памяти об'ектов, на которые ссылаются
описатели. Описатели имеют следующий синтаксис:

 описатель:
      идентификатор
      ( описатель )
      * описатель
      описатель ()
      описатель [константное-выражение]
                                     необ

Группирование такое же, как и в выражениях.


   6.4. Смысл описателей


   Каждый описатель рассматривается  как  утверждение  того,
что  когда  конструкция той же самой формы, что и описатель,
появляется в выражении, то она выдает об'ект указанного типа
и  указанного класса памяти. Каждый описатель содержит ровно
один идентификатор; это именно тот идентификатор, который  и
описывается.

   Если в качестве описателя появляется  просто  идентифика-
тор, то он имеет тип, указываемый в специфицирующем заголов-
ке описания.

   Описатель в круглых скобках идентичен описателю без круг-
лых скобок, но круглые скобки могут изменять связи в состав-
ных описателях. Примеры смотри ниже.

   Представим себе описание

          t     di

где t - спецификатор типа (подобный int и т.д.), а di - опи-
сатель.  Предположим,  что это описание приводит к тому, что
соответствующий идентификатор имеет тип  "...t",  где  "..."
пусто, если di просто отдельный идентификатор (так что тип х
в "int х" просто int). Тогда , если di имеет форму

         *d

то содержащийся идентификатор будет иметь тип "... указатель
на t".

   Если di имеет форму







                                                          27

         d()

то  содержащийся  идентификатор  имеет  тип  "...   функция,
возвращающая t".

   Если di имеет форму

        d[константное_выражение]

или

        d[ ]

то содержащийся идентификатор имеет тип "...  массив  t".  В
первом  случае  константным  выражением  является выражение,
значение которого можно определить во время компиляции и ко-
торое  имеет тип int. (точное определение константного выра-
жения дано ниже). Когда несколько спецификаций вида  "массив
из"   оказываются  примыкающими,  то  создается  многомерный
массив; константное выражение,  задающее  границы  массивов,
может  отсутствовать  только у первого члена этой последова-
тельности. Такое опускание полезно,  когда  массив  является
внешним  или формальным и его фактическое определение, кото-
рое выделяет  память,  приводится  в  другом  месте.  Первое
константное  выражение может быть опущено также тогда, когда
за описателем следует инициализация. В  этом  случае  размер
определяется  по  числу приведенных инициализируемых элемен-
тов.

   Массив может быть образован из элементов одного из основ-
ных типов, из указателей, из структур или об'единений или из
других массивов (чтобы образовать многомерный массив).

   Не все возможности, которые разрешены с точки зрения ука-
занного  выше синтаксиса, фактически допустимы. Имеются сле-
дующие ограничения: функции не могут возвращать массивы  или
функции,  хотя они могут возвращать указатели на такие вещи;
не существует массивов функций, хотя могут быть массивы ука-
зателей на функции. Аналогично, структуры или об'единения не
могут содержать функцию, но они могут содержать указатель на
функцию.

   В качестве примера рассмотрим описание

    int i, *ip, f(), *fip(), (*pfi)();

в котором  описывается  целое  i,  указатель  ip  на  целое,
функция  f,  возвращающая  целое,  функция fip, возвращающая
указатель на целое, и  указатель  pfi  на  функцию,  которая
возвращает  целое.  Особенно  полезно сравнить два последних
описателя. Связь в *fip() можно представить в виде *(fip()),
так  что описанием предполагается, что в выражении требуется
обращение к функции fip и последующее использование  косвен-
ной  адресации  для  выдачи с помощью полученного результата
(указателя)  целого.  В  описателе  (*pfi)()  дополнительные
скобки необходимы, поскольку они точно так же, как и в выра-
жении, указывают, что косвенная  адресация  через  указатель
выдает  функцию,  которая  затем  вызывается;  эта вызванная
функция возвращает целое.

   В качестве другого примера приведем описание



28

       float fa[17], *afp[17];

в котором описывается массив чисел типа float и массив  ука-
зателей на числа типа float. Наконец,

       static int х3d[3][5][7];

описывает  статический  трехмерный  массив  целых   размером
3*5*7. Более подробно, х3d является массивом из трех элемен-
тов; каждый элемент является массивом пяти массивов;  каждый
последний  массив является массивом из семи целых. Каждое из
выражений х3d, х3d[i], х3d[i][j] и х3d[i][j][к] может разум-
ным  образом  появляться  в выражениях. Первые три имеют тип
"массив", последнее имеет тип int.


   6.5. Описание структур и об'единений


   Структура - это об'ект, состоящий  из  последовательности
именованных  членов.  Каждый  член  может быть произвольного
типа. Об'единение - это  об'ект,  который  в  данный  момент
может  содержать любой из нескольких членов. Спецификаторы и
об'единения имеют одинаковую форму.

 спецификатор_структуры_или_об'единения:

    структура_или_об'единение   { спи-
         сок_описаний_структуры }
    идентификатор_структуры_или_об'едине-
         ния { список-описаний-структуры }
    идентификатор_структуры_или_об'единения

 структура_или_об'единение:
               struct
               union

Список_описаний_структуры является последовательностью  опи-
саний членов структуры или об'единения:

  список_описаний_структуры:
       описание_структуры
       описание_структуры спи-
                сок_описаний_структуры

  описание_структуры:
       спецификатор_типа спи-
              сок_описателей_структуры

  список_описателей_структуры:
       описатель_структуры
       описатель_структуры,список_опи-
                      сателей_структуры

В обычном случае описатель структуры является просто  описа-
телем  члена структуры или об'единения. Член структуры может
также  состоять из  специфицированного  числа  битов.  Такой
член  называется  также полем; его длина отделяется от имени
поля двоеточием.





                                                          29

  описатель_структуры:
       описатель
       описатель: константное_выражение
       : константное_выражение


Внутри структуры описанные в ней об'екты имеют адреса, кото-
рые увеличиваются в соответствии с чтением описаний об'ектов
слева направо. Каждый член структуры,  который  не  является
полем,  начинается  с  адресной границы, соответствующей его
типу; следовательно в структуре могут оказаться  неименован-
ные  дыры.  Члены,  являющиеся полями, помещаются в машинные
целые; они не перекрывают границы слова.  Поле,  которое  не
умещается  в оставшемся в данном слове пространстве, помеща-
ется в следующее слово. Поля  выделяются  справа  налево  на
CM-ЭВМ, но могут выделяться слева направо на других машинах.

   Описатель структуры, который  не  содержит  описателя,  а
только двоеточие и ширину, указывает неименованное поле, по-
лезное для заполнения свободного пространства с целью  соот-
ветствия  задаваемым извне схемам. Специальный случай неиме-
нованного поля с шириной 0 используется для указания  о  вы-
равнивании  следующего поля на границу слова. При этом пред-
полагается,  что  "следующее  поле"  действительно  является
полем,  а не обычным членом структуры, поскольку в последнем
случае выравнивание осуществляется автоматически.

   Сам язык не накладывает  ограничений  на  типы  об'ектов,
описанных  как поля, но от реализаций не требуется обеспечи-
вать что-либо отличное от целых полей. Более того, даже поля
типа  int  могут  рассматриваться  как  не имеющие знака. На
CM-ЭВМ поля не имеют знака и могут  принимать  только  целые
значения.  Во всех реализациях отсутствуют массивы полей и к
полям не применима операция взятия адреса "&",  так  что  не
существует и указателей на поля.

   Об'единение можно представить  себе  как  структуру,  все
члены которой начинаются со смещения 0 и размер которой дос-
таточен, чтобы содержать любой из ее членов. В каждый момент
об'единение может содержать не более одного из своих членов.

   Спецификатор структуры или об'единения во  второй  форме,
т.е. один из:

  struct идент {список_описаний_структуры}
  union идент {список-описаний-структуры}

описывает идент в  качестве  ярлыка  структуры  (или  ярлыка
об'единения)  для структуры, специфицированной этим списком.
Последующее описание может затем использовать  третью  форму
спецификатора, один из

   struct идент
   union идент

Ярлыки структур дают возможность определения структур, кото-
рые ссылаются на самих себя; они также позволяют неоднократ-
но использовать приведенную только один  раз  длинную  часть
описания.  Запрещается  описывать структуру или об'единение,
которые содержат  образец  самого  себя,  но  структура  или
об'единение  могут  содержать  указатель  на  структуру  или
об'единение такого же вида, как они сами.


30


   Имена членов и ярлыков структур могут совпадать с именами
обычных  переменных.  Однако  имена  ярлыков и членов должны
быть взаимно различными.

   Две структуры могут иметь общую начальную  последователь-
ность  членов; это означает, что тот же самый член может по-
явиться в двух различных структурах, если он имеет  одинако-
вый тип в обеих структурах и если все предыдущие члены обеих
структур одинаковы. Фактически компилятор только  проверяет,
что  имя  в двух различных структурах имеет одинаковый тип и
одинаковое смещение, но если предшествующие члены  отличают-
ся, то конструкция оказывается непереносимой.

   Вот простой пример описания структуры:

         struct tnode {
              char tword[20];
              int count;
              struct tnode *left;
              struct tnode *right;
         };

такая структура содержит массив из 20 символов, целое и  два
указателя  на такие же структуры. Как только приведено такое
описание, описание

          struct tnode s, *sp;

говорит о том, что s является структурой указанного вида,  а
sp является указателем на структуру указанного вида. При на-
личии этих описаний выражение

         sp->count

ссылается на поле count структуры, на которую указывает  sp;
выражение

         s.left

ссылается на указатель левого поддерева в структуре s, а вы-
ражение

         s.right->tword[0]

ссылается на первый символ члена tword правого поддерева  из
s.


   6.6. Перечислимый тип


   Перечислимый тип данных аналогичен  скалярным типам языка
паскаль.  Спецификатор  перечислимого  типа  имеет следующий
вид:

спецификатор_перечисления:
   enum список_перечисления
   enum идентификатор  список_перечисления
   enum идентификатор

список_перечисления:


                                                          31

   перечисляемое
   список_перечисления, перечисляемое

перечисляемое:
   идентификатор
   идентификатор = константное выражение



   Роль  идентификатора  в  спецификаторе_перечисления  пол-
ностью  аналогична  роли  ярлыка  структуры  в  спецификато-
ре_структуры; идентификатор обозначает определенное перечис-
ление. Например, описание

    enum color {red, white, black, blue };
    . . .
    enum color *ср, col;

об'являет идентификатор  color  ярлыком  перечисления  типа,
описывающего различные цвета и затем об'являет ср указателем
на об'ект этого типа, а col - об'ектом этого типа.

   Идентификаторы в списке_перечисления становятся  констан-
тами  и  могут  появляться там, где требуются (по контексту)
константы. Если не используется вторая форма  перечисляемого
(с  равенством  "="),  то величины констант начинаются с 0 и
возрастают на 1 в соответствии с прочтением их описания сле-
ва  направо.  Перечисляемое  с присвоением "=" придает соот-
ветствующему идентификатору указанную величину;  последующие
идентификаторы  продолжают прогрессию от приписанной величи-
ны.

   Ярлыки перечислений и имена констант должны быть  различ-
ными и не совпадать с именами ярлыков и членов структур.

   Об'екты данного  типа  перечисления  рассматриваются  как
об'екты,  имеющие тип, отличный от любых типов и контролиру-
ющая  программа  lint  сообщает  об  ошибках  несоответствия
типов.  В реализации на CM_ЭВМ со всеми перечисляемыми пере-
менными оперируют так, как если бы они имели тип int.


   6.7. Инициализация


   Описатель может указывать начальное значение описываемого
идентификатора.  Инициализатор состоит из выражения или зак-
люченного в фигурные скобки списка значений, перед  которыми
ставится знак "=".

инициализатор:
   = выражение
   = {список_иниц}
   = {список_иниц,}
список_иниц:
  выражение
  список_иниц,список_иниц
  {список_иниц}

 где

список_иниц - список_инициализаторов


32



   Все выражения, входящие в инициализатор  статической  или
внешней  переменной, должны быть либо константными выражени-
ями, либо выражениями, которые сводятся к адресу ранее  опи-
санной  переменной, смещенному на константное (возможно, ну-
левое) выражение. Автоматические  и  регистровые  переменные
могут быть инициализированы произвольными выражениями, вклю-
чающими константы и ранее описанные переменные и функции.

   Гарантируется,  что  неинициализированные  статические  и
внешние переменные получают в качестве начальных значений 0;
неинициализированные автоматические и регистровые переменные
в качестве начальных значений содержат мусор.

   Когда инициализатор применяется к скаляру (указателю  или
об'екту арифметического типа), то он состоит из одного выра-
жения, возможно заключенного в  фигурные  скобки.  Начальное
значение  об'екта  находится из выражения; выполняются те же
самые преобразования, что и при присваивании.

   Когда описываемая переменная является агрегатом (структу-
рой  или массивом), то инициализатор состоит из заключенного
в фигурные скобки и разделенного запятыми списка инициализа-
торов для членов агрегата. Этот список составляется в поряд-
ке возрастания индекса или в соответствии с порядком членов.
Если агрегат содержит подагрегаты, то это правило применяет-
ся рекурсивно к членам агрегата. Если количество инициализа-
торов  в списке оказывается меньше числа членов агрегата, то
оставшиеся члены агрегата  заполняются  нулями.  Запрещается
инициализировать об'единения или автоматические агрегаты.

   Фигурные скобки могут интерпретироваться следующим  обра-
зом.  Если инициализатор начинается с левой фигурной скобки,
то последующий разделенный запятыми  список  инициализаторов
инициализирует  члены агрегата; будет ошибкой, если в списке
окажется больше инициализаторов, чем членов  агрегата.  Если
однако  инициализатор не начинается с левой фигурной скобки,
то из списка берется только нужное для членов данного  агре-
гата  число  элементов; оставшиеся элементы используются для
инициализации следующего члена агрегата, частью которого яв-
ляется  настоящий агрегат. Следовательно, скобки в некоторых
случаях  можно опускать.

   Последнее сокращение допускает возможность  инициализации
массива типа char с помощью строки. В этом случае члены мас-
сива последовательно инициализируются символами строки.

   Например,

            int х[] = {1,3,5};

описывает и инициализирует х как одномерный массив; посколь-
ку размер массива не специфицирован, а список инициализитора
содержит три элемента, считается, что массив состоит из трех
членов.

   Вот пример инициализации с полным использованием фигурных
скобок:





                                                          33

  float *y[4][3] = {
          ( 1, 3, 5 ),
          ( 2, 4, 6 ),
          ( 3, 5, 7 ),
    };

Здесь 1, 3 и 5 инициализируют первую строку массива y[0],  а
именно  y[0][0], y[0][1] и y[0][2]. Аналогичным образом сле-
дующие две строчки инициализируют y[1] и y[2]. Инициализатор
заканчивается  преждевременно, и, следовательно, массив y[3]
инициализируется нулями. В точности такого же эффекта  можно
было бы достичь, написав

    float y[4][3] = {
          1, 3, 5, 2, 4, 6, 3, 5, 7
    };

Инициализатор для y начинается с левой фигурной  скобки,  но
инициализатора для y[0] нет. Поэтому используется 3 элемента
из списка. Аналогично следующие  три  элемента  используются
последовательно для y[1] и y[2]. Следующее описание

            float y[4][3] = {
                  {1}, {2}, {3}, {4}
            };

инициализирует первый столбец y (если его рассматривать  как
двумерный массив), а остальные элементы заполняются нулями.

   И наконец, описание

 char msg[] = "syntax error on line %s\n";

демонстрирует инициализацию элементов символьного массива  с
помощью строки.


   6.8. Имена типов


   В двух случаях (для явного указания типа преобразования в
конструкции перевода и для аргументов операции sizeof) жела-
тельно иметь  возможность  задавать  тип  данных.  Это  осу-
ществляется  с помощью "имени типа", которое по существу яв-
ляется описанием об'екта такого типа, в котором опущено  имя
самого об'екта.

 Имя типа:
    спецификатор_типа абстрактный_описатель
 абстрактный_описатель:
    пусто
    (абстрактный_описатель)
    *абстрактный описатель
    абстрактный_описатель ()
    абстрактный_описатель [констант-
                     ное выражение]
                               необ

Во избежании двусмысленности в конструкции





34

        (абстрактный_описатель)

требуется, чтобы абстрактный_описатель был непуст. При  этом
ограничении  возможно  однозначено  определить  то  место  в
абстрактном_описателе, где должен  появиться  идентификатор,
если  бы  эта конструкция была описателем в описании. Имено-
ванный тип совпадает тогда с типом гипотетического идентифи-
катора. Например, имена типов

         int
         int *
         int *[3]
         int (*)[3]
         int *()
         int (*)()

именуют соответственно типы "целый", "указатель  на  целое",
"массив  из  трех указателей на целое", "указатель на массив
из трех целых", " функция, возвращающая указатель на  целое"
и "указатель на функцию, возвращающую целое".


   6.9. Описатель typedef


   Описания, в  которых  "класс памяти"  специфицирован  как
typedef,  не вызывают выделения памяти. Вместо этого они оп-
ределяют идентификаторы, которые позднее можно  использовать
так,  словно они являются ключевыми словами, имеющими основ-
ные или производные типы.

   Определяющее_тип_имя:
             идентификатор

В  пределах  области  действия  описания  со  спецификатором
typedef  каждый  идентификатор,  описанный в нем, становится
синтаксически эквивалентным ключевому  слову,  имеющему  тот
тип,  который ассоциирует с идентификатором в описанном в п.
6.4 смысле. Например, после описаний

 typedef int miles, *klicksp;
 typedef struct { double re, im;} complex;

конструкции

         miles distance;
         extern klicksp metricp;
         complex z, *zp;

становятся законными описаниями; при этом типом distance яв-
ляется  int,  типом  metricp - "указатель на int", типом z -
специфицированная структура и типом zp - указатель на  такую
структуру.

   Спецификатор  typedef  не  вводит  каких-либо  совершенно
новых типов, а только определяет синонимы для типов, которые
можно было бы специфицировать и другим способом. Так в  при-
веденном  выше примере переменная distance считается имеющей
точно такой же тип, что и любой другой об'ект,  описанный  в
int.




                                                          35




                        7. ОПЕРАТОРЫ


   За исключением особо оговариваемых случаев, операторы вы-
полняются последовательно.


   7.1. Операторное выражение


   большинство операторов являются операторными выражениями,
которые имеют форму

            выражение;

Обычно операторные выражения являются присваиваниями или об-
ращениями к функциям.


   7.2. Составной оператор (или блок)


   С тем, чтобы допустить возможность использования несколь-
ких операторов там, где ожидается присутствие только одного,
предусматривается составной оператор (который также называют
"блоком"):

 составной оператор:
      {список_описаний  список_операторов}
                  необ               необ

 список_описаний:
      описание
      описание список_описаний

 список_операторов:
      оператор
      оператор список_операторов

Если какой-либо идентификатор из списка_описаний был  описан
ранее,  то во время выполнения блока внешнее описание подав-
ляется и снова вступает в силу после выхода из блока.

   Любая инициализация автоматических и регистровых перемен-
ных  проводится  при каждом входе в блок через его начало. В
компиляторе ОС ДЕМОС разрешается (но  это  плохая  практика)
передавать  управление внутрь блока; в таком случае эти ини-
циализации не выполняются. Инициализации  статических  пере-
менных проводятся только один раз, когда начинается выполне-
ние программы.

   Находящиеся внутри блока внешние описания не  резервируют
памяти, так что их инициализация не разрешается.








36

   7.3. Условные операторы


   Имеются две формы условных операторов:

     if (выражение) оператор
     if (выражение) оператор else оператор

В обоих случаях вычисляется выражение и, если оно отлично от
нуля,  то  выполняется первый подоператор. Во втором случае,
если выражение равно нулю, выполняется  второй  подоператор.
Как  обычно,  двусмысленность "else" разрешается связыванием
else с последним встречающимся if, у которого нет else.


   7.4. Оператор while


   Оператор while имеет форму

       while (выражение) оператор

Подоператор выполняется повторно до тех пор,  пока  значение
выражения  остается  отличным от нуля. Проверка производится
перед каждым выполнением оператора.


   7.5. Оператор do


   Оператор do имеет форму

        do оператор while (выражение)

Оператор выполняется повторно до тех пор, пока значение  вы-
ражения  не  станет равным нулю. Проверка производится после
каждого выполнения оператора.


   7.6. Оператор for


   Оператор for имеет форму

(выражение1;выражение2;выражение3)оператор
        необ       необ       необ

Оператор for эквивалентен следующему:

        выражение1;
           while   (выражение2) {
                   оператор
                   выражение3;
        }

Таким образом,  первое  выражение  определяет  инициализацию
цикла;  второе  специфицирует  проверку,  выполняемую  перед
каждой итерацией, так что выход из цикла  происходит  тогда,
когда  значение выражения становится нулем; третье выражение
часто задает приращение параметра, которое проводится  после
каждой итерации.



                                                          37

   Любое выражение или даже все они могут быть опущены. Если
отсутствует  второе выражение, то предложение с while счита-
ется эквивалентным while(1); другие отсутствующие  выражения
просто опускаются из приведенного выше расширения.


   7.7. Оператор switch


   Оператор switch (переключатель), вызывает передачу управ-
ления  к  одному  из нескольких операторов, в зависимости от
значения выражения. Оператор имеет форму

        switch (выражение) оператор

В выражении проводятся обычные  арифметические  преобразова-
ния, результат должен иметь тип int. "Оператор" обычно явля-
ется составным. Любой оператор внутри этого оператора  может
быть помечен одним или более вариантным префиксом case, име-
ющим форму:

        case константное выражение:

Где константное выражение должно иметь тип int. Никакие  две
вариантные константы в одном и том же переключателе не могут
иметь одинаковое значение. Точное  определение  константного
выражения приводится ниже.

   Кроме того, может присутствовать один операторный префикс
вида

        default:


   При выполнении оператора switch  вычисляется  входящее  в
него  выражение  и сравнивается с каждой вариантной констан-
той. Если одна из  вариантных  констант  оказывается  равной
значению  этого выражения, то управление передается операто-
ру, который следует  за  совпадающим  вариантным  префиксом.
Если ни одна из вариантных констант не совпадает со значени-
ем выражения и если при этом присутствует  префикс  default,
то управление передается оператору, помеченному этим префик-
сом. Если ни один из вариантов не подходит и префикс default
отсутствует, то ни один из операторов в переключателе не вы-
полняется.

   Сами по себе префиксы case и default не изменяют выполне-
ния  программы,  программа выполняется последовательно, пока
не встретится явная передача управления. Для выхода  из  пе-
реключателя имеется оператор break (п.7.8).

   Обычно оператор, который входит в переключатель, является
составным. Описания могут появляться в начале этого операто-
ра, но инициализации автоматических и регистровых переменных
будут неэффективными.

   Пример:







38

 switch (regim) {
 case 'x': regx++;
 case 'X': case 'Y': regY++; break;
 case '-': regx = 0; break;
 default: err("Ошибка"); goto next;
 }



   7.8. Оператор break


   Оператор

        break;

вызывает  завершение  выполнения  наименьшего  охватывающего
этот  оператор оператора while, do, for или switch; управле-
ние передается оператору, следующему за завершенным операто-
ром.


   7.9. Оператор continue


   Оператор

        continue;

приводит к передаче управления на  продолжающую  цикл  часть
наименьшего  охватывающего этот оператор оператора while, do
или for; то есть на конец цикла. Более точно,  в  каждом  из
операторов

 while(...) { | do {          | for(...) {
    ...       |   ...         |      ...
 contin: ;    |  contin: ;    |   contin: ;
 }            | } while(...); | }

оператор continue эквивалентен оператору  goto  contin.  (за
contin: следует пустой оператор; см. п. 7.13.).


   7.10. Оператор возврата


   Возвращение из функции в вызывающую программу осуществля-
ется  с помощью оператора return, который имеет одну из сле-
дующих форм

          return;
          return выражение;

В первом случае возвращаемое значение неопределено. Во  вто-
ром  случае в вызывающую функцию возвращается значение выра-
жения.  Если  требуется,  выражение  преобразуется  к   типу
функции,  в  которой оно появляется, как в случае присваива-
ния. Попадание на конец функции  эквивалентно  возврату  без
возвращаемого значения.

   Возвращать можно значение арифметического типа,  а  также
структуру (но не массив).


                                                          39

   7.11. Оператор goto


   Управление можно передавать безусловно с помощью операто-
ра

       goto идентификатор1

Идентификатор должен быть меткой (п. 7.12), локализованной в
данной функции.


   7.12. Помеченный оператор


   Перед любым оператором может стоять метка, имеющая вид:

           идентификатор:

Метки используются только для указания места, куда передает-
ся управление оператором goto. Областью действия метки явля-
ется данная функция, за исключением тех подблоков, в которых
тот же идентификатор описан снова.


   7.13. Пустой оператор


   Пустой оператор имеет форму:

                ;

Пустой оператор оказывается полезным, так как  он  позволяет
поставить  метку  перед  закрывающей  скобкой "}" составного
оператора или указать пустое тело в операторах цикла,  таких
как while.




























40




                   8. ВНЕШНИЕ ОПРЕДЕЛЕНИЯ


   Си-программа представляет собой последовательность  внеш-
них определений. Внешнее определение описывает идентификатор
как имеющий класс памяти extern (по умолчанию), или возможно
static,  и  специфицированный  тип. Спецификатор типа  также
может быть пустым; в этом случае считается, что тип является
типом  int. Область действия внешних определений распростра-
няется до конца файла, в котором они  приведены,  точно  так
же,  как  влияние описаний простирается до конца блока. Син-
таксис внешних определений не отличается от синтаксиса  опи-
саний,  за исключением того, что только на этом уровне можно
приводить текст функций.


   8.1. Внешнее определение функции


   Определение функции имеет форму

определение_функции:
    спецификаторы_описания описа-
                       необ
               тель_функции тело_функции

Единственными спецификаторами класса памяти, допускаемыми  в
качестве   спецификаторов-описания,   являются   extern  или
static; о различии между ними смотри  в  следующем  разделе.
Описатель  функции подобен описателю для "функции, возвраща-
ющей...", за исключением того, что он перечисляет формальные
параметры определяемой функции.

 описатель_функции:
      описатель (список_параметров)
                               необ
 список параметров:
      идентификатор
      идентификатор, список_параметров

Тело_функции имеет форму

  тело_функции:
       список_описаний составной_оператор

Идентификаторы из списка параметров  могут  быть  описаны  в
списке  описаний.  Любой  идентификатор из этого списка, тип
которого не указан, считается имеющим тип int.  Единственным
допустимым   здесь  спецификатором  класса  памяти  является
register; если такой класс памяти специфицирован, то в нача-
ле  выполнения функции  соответствующий фактический параметр
копируется, если это возможно, в регистр.

   Вот простой пример полного определения функции:







                                                          41

         int max(a, в, с)
         int a, в, с;
         {
             int m;
             m = (a>b) ? a:b;
             return((m>c) ? m:c);
         }

Здесь  int  -  спецификатор-типа,  мaх(a,b,c)  -  описатель-
_функции,  int  a,b,c; - список-описаний формальных парамет-
ров, { ... } - блок, содержащий текст оператора.

   В языке "Си" все фактические параметры типа float  преоб-
разуются к типу double, так что описания формальных парамет-
ров, об'явленных как float,  могут  работать  с  параметрами
типа  double. Аналогично, поскольку ссылка на массив в любом
контексте (в частности в фактическом параметре) рассматрива-
ется  как указатель на первый элемент массива, описания фор-
мальных параметров вида "массив ..." могут работать с факти-
ческими параметрами типа "указатель на ...". И наконец, пос-
кольку функции не могут быть переданы функции,  бессмысленно
описывать  формальный параметр как функцию (указатели на та-
кие об'екты, конечно, допускаются).

П_Р_И_М_Е_Ч_А_Н_И_Е.
     В некоторых версиях языка Си, в  частности,  в  версиях
     для  микропроцессоров,  могут  быть  запрещены передача
     структур и об'единений через параметры функции.


   8.2. Внешние определения данных


   Внешнее определение данных имеет форму:

    определение_данных:
                описание

Классом памяти таких данных может быть extern (в  частности,
по умолчанию) или static, но не auto или register.
























42




            9. ОБЛАСТЬ ДЕЙСТВИЯ ИДЕНТИФИКАТОРОВ


   Вся Си-программа необязательно компилируется  одновремен-
но;  исходный  текст  программы может храниться в нескольких
файлах и ранее скомпилированные процедуры могут  загружаться
из библиотек. Связь между функциями может осуществляться как
через явные обращения, так и в результате  работы  редактора
связей.

   Поэтому следует рассмотреть два вида  областей  действия:
во  первых,  ту,  которая может быть названа лексической об-
ластью  действия идентификатора и которая по существу  явля-
ется  той областью в программе, где этот идентификатор можно
использовать, не вызывая диагностического сообщения "неопре-
деленный  идентификатор"; и во-вторых, область действия, ко-
торая связана с внешними идентификаторами и которая характе-
ризуется правилом, что ссылки на один и тот же внешний иден-
тификатор являются ссылками на один и тот же об'ект.


   9.1. Лексическая область действия


   Лексическая область действия  идентификаторов,  описанных
во  внешних  определениях,  простирается  от  определения до
конца исходного файла, в котором он  находится.  Лексическая
область действия идентификаторов, являющихся формальными па-
раметрами, распространяется на ту функцию, к которой они от-
носятся.  Лексическая область действия идентификаторов, опи-
санных в начале блока, простирается до  конца  этого  блока.
Лексической  областью  действия меток является та функция, в
которой они находятся.

   Поскольку все ссылки на один и тот же внешний идентифика-
тор  относятся к одному и тому же об'екту, компилятор прове-
ряет все описания одного и того же  внешнего  идентификатора
на  совместимость;  в  действительности  их область действия
распространяется на весь файл, в котором они находятся.

   Во всех случаях, однако, если некоторый идентификатор яв-
ным  образом  описан в начале блока, включая и блок, который
образует функцию, то действие любого описания этого  иденти-
фикатора вне блока приостанавливается до конца этого блока.

   Напомним также, что идентификаторы, соответствующие обыч-
ным  переменным,  с  одной  стороны, и идентификаторы, соот-
ветствующие членам и ярлыкам структур и об'единений, с  дру-
гой  стороны, формируют два непересекающихся класса, которые
не вступают в противоречие. Члены и ярлыки структур подчиня-
ются  тем  же  самым правилам определения областей действия,
как и другие идентификаторы. Имена,  специфицируемые  с  по-
мощью  typedef, входят в тот же класс, что и обычные иденти-
фикаторы. Они могут быть переопределены во  внутренних  бло-
ках, но во внутреннем описании тип должен быть указан явно:






                                                          43

        typedef float distance;
        ...
        {
                auto int distance;
                ...

Во втором описании спецификатор типа int должен  присутство-
вать,  так как в противном случае это описание будет принято
за описание без описателей с типом distance.


   9.2. Область действия внешних идентификаторов


   Если функция ссылается на  идентификатор,  описанный  как
extern,  то  где-то  среди  файлов или библиотек, образующих
полную программу,  должно  содержаться  внешнее  определение
этого  идентификатора. Все функции данной программы, которые
ссылаются на один и тот же внешний идентификатор,  ссылаются
на один и тот же об'ект, так что следует позаботиться, чтобы
специфицированные в этом определении тип и размер были  сов-
местимы  с  типом и размером, указываемыми в каждой функции,
которая ссылается на эти данные.

   Появление ключевого слова extern во  внешнем  определении
указывает  на то, что память для описанных в нем идентифика-
торов будет выделена в другом файле. Следовательно, в состо-
ящей  из многих файлов программе внешнее определение иденти-
фикатора, не содержащее спецификатора extern,  должно  появ-
ляться  только  в  одном из этих файлов. Любые другие файлы,
которые желают дать внешнее определение этого  идентификато-
ра,  должны включать в это определение слово extern. Иденти-
фикатор может быть инициализирован только  в  том  описании,
которое приводит к выделению памяти.


   Из этого правила в ОС ДЕМОС имеется исключение. Внеш-   |
ний  об'ект  может присутствовать в нескольких описаниях   |
без "extern". При этом длина об'екта в разных  описаниях   |
должна совпадать, а инициализация, если она есть, должна   |
проводиться ровно в одном  из  описаний.  При  нарушении   |
этих  правил будет выдана ошибка на этапе редактировании   |
связей программы.                                          |


   Идентификаторы, внешнее определение которых начинается со
слова  static,  недоступны  из  других файлов. Функции могут
быть описаны как static.


   9.3. Неявные описания


   Не всегда необходимо специфицировать и класс памяти и тип
идентификатора  в описании. Во внешних определениях и описа-
ниях формальных параметров и членов  структур  класс  памяти
определяется по контексту. Если в находящемся внутри функции
описании не указан тип, а только класс памяти, то  предпола-
гается,  что  идентификатор  имеет  тип  int; если не указан
класс памяти, а только тип, то идентификатор  предполагается
описанным  как auto. Исключение из последнего правила дается
для функций, потому что спецификатор auto для функций  явля-


44

ется  бессмысленным  (язык "Си" не в состоянии компилировать
программу в стек); если идентификатор  имеет  тип  "функция,
возвращающая ...", то он предполагается неявно описанным как
extern.

   Входящий в выражение и неописанный  ранее  идентификатор,
за  которым  следует скобка "(", считается описанным по кон-
тексту как "функция, возвращающая int".


   /* extern */ int tab[100];
   static /* int */ t1;
   /* int */ func(i) /* int i; */
   { register /* int */ k;
     /* auto */ char buf[512];
     /* extern int f1(); */
     ... f1(a,b) ...















































                                                          45




                10. ПРЕПРОЦЕССОР ЯЗЫКА 'СИ'


   Компилятор языка "Си" содержит препроцессор, который поз-
воляет  осуществлять макроподстановки, условную компиляцию и
включение именованных файлов. Строки, начинающиеся с #,  яв-
ляются  командами  этого препроцессорa. Синтаксис этих строк
не связан с остальным языком; они могут появляться  в  любом
месте  и  их влияние распространяется (независимо от области
действия) до конца исходного программного файла.  Фактически
препроцессор  расширяет возможности языка "Си", реализуя та-
кие функции, которые в других языках входят в состав  самого
языка (например, параметрические константы в Фортране-77).


   10.1. Замена лексем


   Команда

#define идентификатор строка_лексем

(обратите внимание на отсутствие в конце  точки  с  запятой)
приводит к тому, что препроцессор заменяет последующие вхож-
дения этого идентификатора на указанную строку лексем. Стро-
ка вида

#define идентификатор(идентифика-
    тор,...,идентификатор) строка_лексем

где между первым идентификатором и открывающейся скобкой "("
нет  пробела, представляет собой макроопределение с аргумен-
тами. В дальнейшем первый идентификатор, за которым  следует
открывающая скобка "(", последовательность разделенных запя-
тыми лексем и закрывающая  скобка  ")",  заменяются  строкой
лексем из определения. Каждое вхождение идентификатора, упо-
мянутого в списке формальных параметров в определении, заме-
няется  соответствующей  строкой лексем из обращения. Факти-
ческими аргументами в обращении являются строки лексем, раз-
деленные  запятыми;  однако запятые, входящие в закавыченные
строки или заключенные в круглые скобки, не разделяют  аргу-
ментов.   Количество  формальных  и  фактических  параметров
должно  совпадать.  Текст  внутри  строки   или   символьной
константы не подлежит замене.

   В обоих случаях замененная строка просматривается снова с
целью  обнаружения других идентификаторов, известных препро-
цессору. В обоих случаях слишком длинная строка  определения
может  быть  продолжена  на  другой строке, если поместить в
конце продолжаемой строки обратную косую черту "\".

   Описываемая возможность особенно полезна для  определения
"об'являемых констант", как, например,

#define TABSIZE 100
int table[TABSIZE];

или для замены некоторых функций с помощью макроподстановки:



46

#define max(a,b) ((a)>(b)?(a):(b))
x = max(y,20)

(в последнем определении a и b взяты  в  скобки,  для  того,
чтобы  фактическими  параметрами  макро могли бы быть произ-
вольные выражения.

   Команда

#undef идентификатор

приводит к отмене препроцессорного определения данного иден-
тификатора.


   Определить идентификатор можно не  только  с  помощью   |
команды  "#define", но также и при вызове компилятора, с   |
помощью параметров команды "cc".                           |



   10.2. Включение файлов


   Команда

#include "filename"


приводит к замене этой строки на все содержимое файла с име-
нем  filename.  Файл  с этим именем сначала ищется в текущем
справочнике, а затем в других "стандартных" местах,  опреде-
ляемых  пользователем  при  вызове компилятора. В отличие от
этого команда

#include <filename>

ищет файл только в стандартном справочнике системы.


   В ОС ДЕМОС файл ищется в справочнике "/usr/include".    |


   Команды #include могут быть вложенными.


   10.3. Условная компиляция


   Команда препроцессора

 #if константное выражение

проверяет, отлично ли от нуля значение константного  выраже-
ния. Команда:

#ifdef идентификатор

проверяет,  определен  ли  этот  идентификатор  в  настоящий
момент в препроцессоре, т.е. определен ли этот идентификатор
с помощью команды #define. Команда:



                                                          47

#ifndef идентификатор

проверяет, является ли этот идентификатор в данный момент не
определенным для препроцессора.

   За каждым из трех перечисленных видов строк может  следо-
вать  произвольное  число строк, возможно содержащих команду
препроцессора

#else

а затем должна следовать команда:

#endif

Если проверяемое условие  истинно,  то  любые  строки  между
#else и #endif игнорируются. Если проверяемое условие ложно,
то любые строки между проверяемой строкой и #else  или,  при
отсутствии #else, #endif игнорируются.

   Эти конструкции могут быть вложенными.

   Например:

#ifdef DEBUG
fprintf(stderr,"i=%o j=%d\n",i,j);
#endif

Переменная препроцессора может быть определена не  только  в
самой программе, но и при вызове транслятора.


   10.4. Команда #line


   Для других препроцессоров,  генерирующих  "Си"-программы,
полезна следующая команда:

#line константа "имя_файла"

которая сообщает компилятору (для диагностических сообщений-
), что следующая строка исходного файла имеет номер, задава-
емый константой, и что текущий входной файл именуется  "име-
нем_файла".  Если  "имя_файла"  отсутствует, то запоминаемое
имя файла не изменяется. Пример:

#line 250 "gram.y"

















48




           11. ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ О ТИПАХ


   В этом разделе обобщаются сведения об операциях,  которые
можно применять только к об'ектам определенных типов.


   11.1. Структуры и об'единения


   Со структурами и об'единениями могут производиться следу-
ющие операции: ссылка на один из их членов (с помощью опера-
ции "."), получение адреса (с помощью унарной операции "&"),
присваивание  структуры  структуре, передача структуры в ка-
честве формального параметра,  возврат  структуры  функцией.
Все остальные операции запрещены.


   В реализации возвращения структур функциями на CM-ЭВМ   |
имеется коварный дефект: если во время возврата происхо-   |
дит прерывание и та же самая функция реентерабельно  вы-   |
зывается  во время этого прерывания, то значение возвра-   |
щаемое из первого  вызова,  может  быть  испорчено.  Эта   |
трудность  может возникнуть только при наличии истинного   |
прерывания, как из операционной системы, так и из  прог-   |
раммы  пользователя,  прерывания,  которое действительно   |
асинхронно; обычные рекурсивные вызовы совершенно  безо-   |
пасны.                                                     |


   В разделе "Выражения" говорится, что при прямой или  кос-
венной  ссылке  на  структуру  (с  помощью "." или "->") имя
справа должно быть членом конструкции, названной или указан-
ной выражением слева. Это ограничение не навязывается строго
компилятором, чтобы дать возможность  обойти  правила  соот-
ветствия типов. В действительности перед '.' допускается лю-
бое l_значение и затем предполагается,  что  это  l_значение
имеет  форму структуры, для которой стоящее справа имя явля-
ется членом. Таким же образом, от выражения, стоящего  перед
"->",  требуется  только быть указателем или целым. В случае
указателя предполагается, что он указывает на структуру, для
которой  стоящее справа имя является членом. В случае целого
оно рассматривается  как  абсолютный  адрес  соответствующей
структуры, заданный в единицах машинной памяти.

   Такие структуры не являются переносимыми.


   11.2. Функции


   Только две вещи можно сделать с функцией: вызвать ее  или
извлечь  ее  адрес. Если имя функции входит в выражение не в
позиции имени функции, соответствующей обращению к  ней,  то
генерируется  указатель на эту функцию. Следовательно, чтобы
передать одну функцию другой, можно написать





                                                          49

        int f();
        ...
        g(f);

тогда определение функции g могло бы выглядеть так:

        g(funcp)
        int(*funcp)();
        {
                ...
                (*funcp)();
                ...
        }

Обратите внимание, что  в  вызывающей  процедуре  функция  f
должна быть описана явно, потому что за ее появлением в g(f)
не следует скобка "(".


   11.3. Массивы, указатели и индексация


   Каждый раз, когда идентификатор, имеющий тип массива, по-
является в выражении, он преобразуется в указатель на первый
член этого массива. Из-за этого  преобразования  массивы  не
являются l_значениями. По определению операция индексации []
интерпретируется таким образом, что е1[е2]  считается  иден-
тичным  выражению *((е1)+(е2)). Согласно правилам преобразо-
ваний, применяемым при операции "+", если е1 - массив, а  е2
- целое, то е1[е2] ссылается на е2-й член массива е1. Поэто-
му, несмотря на несимметричный вид, операция индексации  яв-
ляется коммутативной.

   В случае  многомерных  массивов  применяется  аналогичное
правило.   Если   е   является   n-мерным  массивом  размера
i*j*...*к, то при появлении в выражении  е  преобразуется  в
указатель  на (n-1)-мерный массив размера j*...*к. Если опе-
рация "*" либо явно, либо неявно, как результат  индексации,
применяется к этому указателю, то результатом операции будет
указанный (n-1)-мерный массив, который сам немедленно преоб-
разуется в указатель.

   Рассмотрим, например, описание:

        int u[3][5];

Здесь u - массив целых размера 3*5. При появлении в  выраже-
нии  u  преобразуется в указатель на первый из трех массивов
из 5 целых. В выражении u[i], которое  эквивалентно  *(u+i),
сначала  u  преобразуется в указатель так, как описано выше;
затем i преобразуется к типу u, что вызывает умножение i  на
длину об'екта, на который указывает указатель, а именно на 5
целых об'ектов. Результаты складываются, и  применение  кос-
венной  адресации  дает  массив (из 5 целых), который в свою
очередь преобразуется в указатель на первое из  этих  целых.
Если  в выражение входит и другой индекс, то та же самая ар-
гументация применяется снова; результатом на этот раз  будет
целое.

   Из всего этого следует, что массивы в языке "Си" хранятся
построчно  (последний индекс изменяется быстрее всего) и что
первыйиндекс в описании помогает определить общее количество


50

памяти, требуемое для хранения массива, но не играет никакой
другой роли в вычислениях, связанных с индексацией.


   11.4. Явные преобразования указателей


   Разрешаются определенные преобразования с  использованием
указателей.  Они имеют некоторые зависящие от конкретной ре-
ализации аспекты. Все эти преобразования задаются с  помощью
операции явного преобразования типа.

   Указатель может быть преобразован в любой из  целочислен-
ных типов, достаточно большой для его хранения. Требуется ли
при этом int или long, зависит от конкретной  машины  (в  ОС
ДЕМОС  для  СМ  ЭВМ  требуется "int"). Преобразующая функция
также является машинно-зависимой, но она  будет  вполне  ес-
тественной  для тех, кто знает структуру адресации в машине.
Детали для некоторых конкретных машин приводятся ниже.

   Об'ект целочисленного типа может быть явным образом  пре-
образован в указатель. Такое преобразование всегда переводит
преобразованное из указателя целое в тот же самый указатель,
но в других случаях оно будет машинно-зависимым.

   Указатель на один тип может быть преобразован в указатель
на  другой тип. Если преобразуемый указатель не указывает на
об'екты, которые подходящим образом выравнены в  памяти,  то
результирующий  указатель  может  при использовании вызывать
ошибки адресации. Гарантируется, что указатель на об'ект за-
данного  размера  может  быть  преобразован  в  указатель на
об'ект меньшего размера и снова обратно,  не  претерпев  при
этом изменения.

   Например, процедура распределения памяти "alloc" могла бы
принимать  запрос  на размер выделяемого об'екта в байтах, а
возвращать указатель на символы; это можно было бы использо-
вать следующим образом.

        extern char *alloc();
        double *dp;
        dp=(double*) alloc(sizeof(double));
        *dp=22.0/7.0;

Функция alloc должна обеспечивать (машинно-зависимым  спосо-
бом), что возвращаемое ею значение будет подходящим для пре-
образования в указатель на double; в таком случае  использо-
вание этой функции будет переносимым.

   Представление  указателя  на  CM-ЭВМ  соответствует   16-
битовому  целому и измеряется в байтах. Об'екты типа char не
имеют никаких ограничений  на  выравнивание;  все  остальные
об'екты должны иметь четные адреса.











                                                          51




                 12. КОНСТАНТНЫЕ ВЫРАЖЕНИЯ


   В нескольких местах в языке "Си" требуются выражения, ко-
торые  после  вычисления становятся константами: после вари-
антного префикса case, в качестве границ массивов и в иници-
ализаторах.  В первых двух случаях выражение может содержать
только целые константы,  символьные  константы  и  выражения
sizeof, возможно связанные либо бинарными операциями

   + - * / . % & | ^ << >> == 1= <> <= >=

либо унарными операциями

        - ~

либо тернарной операцией

        ?:

Круглые скобки могут использоваться для группировки,  но  не
для обращения к функциям.

   В случае инициализаторов допускается большая (ударение на
букву о) свобода; кроме перечисленных выше константных выра-
жений можно также применять унарную операцию "&"  к  внешним
или  статическим об'ектам и к внешним или статическим масси-
вам, имеющим  в  качестве  индексов  константное  выражение.
Унарная  операция  "&"  может быть также применена неявно, в
результате появления неиндексированных массивов  и  функций.
Основное  правило  заключается  в  том, что после вычисления
инициализатор должен становится либо константой, либо  адре-
сом  ранее описанного внешнего или статического об'екта плюс
или минус константа.



























52




              13. СООБРАЖЕНИЯ О ПЕРЕНОСИМОСТИ


   Одним из достоинств языка  "Си"  считается  переносимость
программ на "Си", которая связана как с относительной машин-
ной независимостью самого языка, так и с совместимостью сре-
ды, обеспечиваемой совместимыми с ОС UNIX операционными сис-
темами. Вместе с тем, при написании на языке Си таких  прог-
рамм,  которые не должны зависеть от конкретной ЭВМ, необхо-
димо учитывать то, что некоторые части языка "Си"  по  своей
сути  машинно-зависимы. Следующее ниже перечисление потенци-
альных трудностей хотя и не являются всеоб'емлющими, но  вы-
деляет основные из них.

   Вопросы, целиком связанные  с  аппаратным  оборудованием,
такие  как  размер слова, свойства вещественной арифметики и
целого деления, не представляют особенных затруднений.  Дру-
гие аспекты аппаратных средств находят свое отражение в раз-
личных реализациях. Некоторые из них, в частности,  знаковое
расширение (преобразующее отрицательный символ в отрицатель-
ное целое) и порядок, в котором помещаются  байты  в  слове,
представляют  собой  неприятность,  которая должна тщательно
отслеживаться. Большинство остальных проблем этого  типа  не
вызывает сколько_нибудь значительных затруднений.

   Число переменных типа register, которое фактически  может
быть помещено в регистры, меняется от машины к машине, также
как и набор допустимых для них типов. Тем не менее все  ком-
пиляторы  на своих машинах работают надлежащим образом; лиш-
ние или недопустимые регистровые описания игнорируются.

   Некоторые трудности возникают  только  при  использовании
сомнительной  практики программирования, или при использова-
нии особенностей конкретной  реализации.  Писать  программы,
которые  зависят от таких особенностей, чрезвычайно неразум-
но.

   Языком  не  указывается  порядок  вычисления   аргументов
функций;  они  вычисляются  справа  налево  на  CM-ЭВМ и ЭВМ
PDP-11 и VAX-11 фирмы DEC и слева  направо  на   большинстве
остальных  машин. Порядок, в котором происходят побочные эф-
фекты, также не специфицируется.

   Так как символьные константы в действительности  являются
об'ектами  типа  int,  допускается  использование символьных
констант, состоящих из нескольких символов. Однако, посколь-
ку порядок, в котором символы приписываются к слову, меняет-
ся от машины к  машине,  конкретная  реализация  оказывается
весьма машинно_зависимой.

   Порядок присваивания полей к словам и  символов  к  целым
также  зависит от ЭВМ. Такие различия незаметны для изолиро-
ванных программ, в которых не разрешено смешивать типы (пре-
образуя,  например,  указатель  на int в указатель на char и
затем проверяя указываемую память),  но  должны  учитываться
при согласовании с накладываемыми извне схемами памяти.

   Язык,  принятый  на  различных  компиляторах,  отличается
только незначительными деталями. Самое заметное отличие сос-


                                                          53

тоит в том, что используемый в настоящее время компилятор на
CM-ЭВМ  не  инициализирует  структуры, которые содержат поля
битов, не имеет типа "unsigned char" и имеет некоторые огра-
ничения  на операции присваивания в определенных контекстах,
связанных с использованием значения присваивания структур.


   13.1. Анахронизмы


   В старых программах можно встретить некоторые  устаревшие
конструкции. Хотя большинство версий компилятора поддержива-
ет такие анахронизмы, они в конце концов  исчезнут,  оставив
за собой только проблемы переносимости.

   В ранних версиях "Си" для проблем присваивания  использо-
валась  форма =оп, а не оп=, приводя к двусмысленностям, ти-
пичным примером которых является

        х =-1

где х фактически уменьшается, поскольку операции = и -  при-
мыкают  друг  к другу, но что вполне могло рассматриваться и
как присваивание -1 к х.

   Синтаксис  инициализаторов  изменился:  раньше  знак  ра-
венства,  с которого начинается инициализатор, отсутствовал,
так что вместо

        int х = 1;

использовалось

        int х 1;


изменение было внесено из_за инициализации

        int f (1+2)

которая достаточно сильно  напоминает  определение  функции,
чтобы смутить компиляторы.






















54




         14. СТАНДАРТНАЯ БИБЛИОТЕКА ВВОДА И ВЫВОДА


   Средства ввода/вывода не являются составной частью  языка
"Си".  В  этой  главе  будет описана "стандартная библиотека
ввода/вывода", то  есть  набор  функций,  разработанных  для
обеспечения стандартной системы ввода/вывода для "Си"- прог-
рамм. Эти функции отражают только те операции, которые могут
быть  обеспечены  на  большинстве  современных  операционных
систем. Процедуры  достаточно  эффективны  для  того,  чтобы
пользователи редко чувствовали необходимость обойти их "ради
эффективности", как бы ни была важна конкретная  задача.  И,
наконец, эти процедуры были авторами языка задуманы "перено-
симыми" в том смысле, что они должны существовать в  совмес-
тимом  виде  на  любой системе, где имеется язык "Си", и что
программы, которые ограничивают свои взаимодействия с систе-
мой возможностями, предоставляемыми стандартной библиотекой,
можно будет переносить с одной системы на другую по существу
без изменений.

   Далее описываются основные принципы организации ввода/вы-
вода  в  программах  на  языке "Си", использующих библиотеку
ввода/вывода. Полное описание этой библиотеки имеется в  ру-
ководстве  программиста (часть 4) или в оперативной докумен-
тации ("man(3)"). Программы, работающие в  ОС  ДЕМОС,  могут
также  обращатся к функциям ввода/вывода низкого уровня, ко-
торые реализованы непосредственно в ядре ОС ДЕМОС, но  такая
необходимость возникает достаточно редко.


   14.1. Обращение к стандартной библиотеке


   Каждый исходный файл, который  обращается  к  функции  из
стандартной  библиотеки,  должен  где  то в начале содержать
строку

        #include <stdio.н>

В файле stdio.h определяются некоторые макросы и переменные,
используемые библиотекой ввода/вывода.


   14.2. Стандартный ввод и вывод  -  функции  getchar  и
         putchar


   Самый простой механизм ввода заключается в чтении по  од-
ному символу за раз из "стандартного ввода" (обычно с терми-
нала  пользователя)  с  помощью  функции  getchar.   Функция
getchar()  целого типа при каждом к ней обращении возвращает
следующий вводимый символ.  В  большинстве  систем,  которые
поддерживают  язык "Си", терминал может быть заменен некото-
рым файлом с помощью обозначения "<". Если  некоторая  прог-
рамма prog использует функцию getchar, то командная строка






                                                          55

        prog <infile

приведет к тому, что prog будет читать из файла infile, а не
с  терминала. Переключение ввода делается таким образом, что
сама программа prog не замечает изменения; в частности стро-
ка  "<infile"  не  включается  в командную строку аргументов
(см. следующую главу). Переключение ввода оказывается  неза-
метным и в том случае, когда вывод поступает из другой прог-
раммы через межпроцессный канал. Например, командная строка

        otherprog | prog

прогоняет две программы, otherprog и prog,  так,  что  стан-
дартным вводом для prog служит стандартный вывод otherprog.

   Функция getchar возвращает значение EOF, когда достигает-
ся  конец  файла,  какой  бы ввод она при этом не считывала.
Стандартная библиотека полагает символическую константу  EOF
равной -1 (посредством #define в файле stdio.h), но проверки
следует писать в терминах EOF, а не -1, чтобы избежать зави-
симости от конкретного значения.

   Вывод можно осуществлять с  помощью  функции  putchar(с),
помещающей  символ  'с'  в  "стандартный  вывод", который по
умолчанию является терминалом. Вывод можно при вызове  прог-
раммы  направить в некоторый файл с помощью обозначения ">".
Если prog использует putchar, то командная строка

        prog > outfile


приведет к записи стандартного вывода в файл outfile,  а  не
на  терминал.  В  системе  ДЕМОС  можно  также  использовать
межпроцессный канал.

   В стандартной библиотеке ввода/вывода "функции" getchar и
putchar  на  самом  деле могут быть макросами. Это позволяет
избежать накладных расходов на обращение к функции для обра-
ботки каждого символа.


   14.3. Форматный вывод - функция printf


   Две функции: printf для вывода и scanf для ввода  (следу-
ющий  раздел) позволяют преобразовывать численные величины в
символьное представление и обратно. Они также позволяют  ге-
нерировать и интерпретировать форматные строки. Функция

        printf(control, arg1, arg2, ...)

преобразует аргументы в текстовую  форму  в  соответствии  с
форматами,  заданными в управляющей строке control, и выдает
результат в стандартный вывод. Управляющая  строка  содержит
два типа об'ектов: обычные символы, которые просто копируют-
ся в выходной поток, и спецификации  преобразований,  каждая
из которых вызывает преобразование и печать очередного аргу-
мента printf.

   Каждая спецификация преобразования начинается  с  символа
"%" и заканчивается символом преобразования (буквой, опреде-
ляющей тип преобразования). Между "%" и символом  преобразо-


56

вания могут находиться:

   - Знак минус, который вызывает выравнивание преобразован-
     ного аргумента по левому краю поля.

   - Строка цифр, задающая минимальную ширину поля. Преобра-
     зованное  число будет напечатано в поле по крайней мере
     этой ширины, а если необходимо, то и в  более  широком.
     Если  преобразованный  аргумент  имеет меньше символов,
     чем указанная ширина поля, то он будет  дополнен  слева
     (или  справа,  если было указано выравнивание по левому
     краю) заполняющими символами до этой  ширины.  Заполня-
     ющим  символом  обычно  является  пробел, а если ширина
     поля указывается с лидирующим нулем, то  этим  символом
     будет нуль (лидирующий нуль в данном случае не означает
     восьмеричной ширины поля).

   - Точка, которая отделяет ширину поля от следующей строки
     цифр.

   - Строка цифр (точность);  указывает  максимальное  число
     символов  строки,  которые  должны быть напечатаны, или
     число печатаемых справа от десятичной  точки  цифр  для
     переменных типа float или double.

   - Модификатор  длины  l,  который  указывает,  что  соот-
     ветствующий элемент данных имеет тип long, а не int.

   Ниже приводятся символы преобразования и их смысл:

d  - аргумент преобразуется к десятичному виду;

o  - аргумент преобразуется в беззнаковую восьмеричную форму
     (без лидирующего нуля);

x  - аргумент преобразуется в беззнаковую  шестнадцатеричную
     форму (без лидирующих 0х);

u  - аргумент преобразуется в беззнаковую десятичную форму;

c  - аргумент рассматривается как отдельный символ;

s  - аргумент является строкой: символы строки печатаются до
     тех  пор, пока не будет достигнут нулевой символ или не
     будет напечатано количество символов, указанное в  спе-
     цификации точности;

e  - аргумент, рассматриваемый как переменная типа float или
     double,   преобразуется   в  десятичную  форму  в  виде
     [-]м.nnnnnne[+-]хх, где длина строки из n  определяется
     указанной точностью. Точность по умолчанию равна 6;

f  - аргумент, рассматриваемый как переменная типа float или
     double,   преобразуется   в  десятичную  форму  в  виде
     [-]ммм.nnnnn, где длина строки из n  определяется  ука-
     занной  точностью. Точность по умолчанию равна 6. Отме-
     тим, что эта точность не определяет количество  печата-
     емых в формате f значащих цифр;

g  - используется или формат %е или %f, какой короче; незна-
     чащие нули не печатаются.



                                                          57

Вместо "ld"можно использовать "D", вместо "lo" - "O", вместо
"lx" - "X".

   Если идущий за % символ не является символом преобразова-
ния,  то  печатается сам этот символ; следовательно,символ %
можно напечатать, указав %%.

   Большинство   из   форматных   преобразований   очевидно.
Единственным  исключением  является то, как точность взаимо-
действует со строками. Следующая таблица демонстрирует  вли-
яние  различных  спецификаций  на  печать "hello, world" (12
символов). Вокруг каждого поля помещены двоеточия для  того,
чтобы можно было определить его протяженность.

  :%10s:      :hello, world:
  :%10-s:     :hello, world:
  :%20s:      :        hello, world:
  :%-20s:     :hello, world        :
  :%20.10s:   :          hello, wor:
  :%-20.10s:  :hello, wor          :
  :%.10s:     :hello, wor:


ПРЕДОСТЕРЕЖЕНИЕ: printf использует свой первый аргумент  для
определения  числа  последующих  аргументов и их типов. Если
количество аргументов окажется недостаточным или  они  будут
иметь  несоответствующие  типы,  то возникнет путаница и ре-
зультаты будут неверными.


   14.4. Форматный ввод - функция scanf


   Осуществляющая  ввод  функция  scanf  является   аналогом
printf  и  позволяет проводить в обратном направлении многие
из тех же самых преобразований. Функция

        scanf(control, arg1, arg2, ...)

читает символы из стандартного ввода,  интерпретирует  их  в
соответствии  с  форматом,  указанном в аргументе control, и
помещает результаты в остальные аргументы. Управляющая стро-
ка  описывается  ниже;  другие  аргументы, каждый из которых
должен быть указателем, определяют, куда  следует  поместить
соответствующим образом преобразованный ввод.

   Управляющая строка обычно содержит спецификации  преобра-
зования, которые используются для непосредственной интерпре-
тации входных последовательностей. Управляющая строка  может
содержать:

   - пробелы, табуляции или символы новой  строки  ("символы
     пустых промежутков"), которые игнорируются;

   - обычные символы (не %), которые предполагаются совпада-
     ющими  со следующими отличными от "символов пустых про-
     межутков" символами входного потока;

   - спецификации преобразования, состоящие  из  символа  %,
     необязательного  символа подавления присваивания *, не-
     обязательного числа, задающего максимальную ширину поля
     и символа преобразования:


58


   Спецификация  преобразования  управляет   преобразованием
следующего  поля  ввода. Обычно результат помещается в пере-
менную,  которая  указывается  соответствующим   аргументом.
Если,  однако , с помощью символа * указано подавление прис-
ваивания, то это поле ввода просто пропускается  и  никакого
присваивания  не  производится.  Поле ввода определяется как
строка символов, которые отличны от "символов простых проме-
жутков"; оно продолжается либо до следующего символа пустого
промежутка, либо пока не будет исчерпана ширина  поля,  если
она  указана. Отсюда следует, что при поиске нужного ей вво-
да, функция scanf будет пересекать границы строк,  поскольку
символ новой строки является одним из символов пустых проме-
жутков.


   Имеется возможность задания более сложного  алгоритма   |
выделения  полей  ввода,  которая  описана в руководстве   |
программиста ("scanf(3)").                                 |


   Символ преобразования определяет интерпретацию поля  вво-
да;  поскольку  в Си аргументы передаются по значению, аргу-
менты "scanf" должны быть указателями. Допускаются следующие
символы преобразования:

d  - На вводе ожидается  десятичное  целое;  соответствующий
     аргумент должен быть указателем на целое.

o  - На вводе ожидается  восьмеричное  целое  (с  лидирующим
     нулем  или  без  него); соответствующий аргумент должен
     быть указателем на целое.

x  - На вводе ожидается шестнадцатеричное целое  (с  лидиру-
     ющими  0х или без них); соответствующий аргумент должен
     быть указателем на целое.

h  - На вводе ожидается целое  типа  short;  соответствующий
     аргумент должен быть указателем на целое типа short.

c  - Ожидается отдельный  символ;  соответствующий  аргумент
     должен  быть  указателем на символы; следующий вводимый
     символ помещается в указанное  место.  Обычный  пропуск
     символов  пустых промежутков в этом случае подавляется;
     для чтения следующего символа, который не является сим-
     волом  пустого  промежутка,  пользуйтесь  спецификацией
     преобразования %1s.

s  - Ожидается символьная строка;  соответствующий  аргумент
     должен  быть  указателем символов, который указывает на
     массив символов, достаточно большой для принятия строки
     и добавляемого в конце символа \0.

f  - Ожидается число с вещественной точкой;  соответствующий
     аргумент  должен  быть  указателем  на  переменную типа
     float.

e  - Символ  преобразования  e  является  синонимом  для  f.
     Формат  ввода  переменной  типа float включает необяза-
     тельный знак, строку цифр, возможно содержащую десятич-
     ную  точку  и необязательное поле экспоненты, состоящее
     из буквы e, за которой следует целое, возможно  имеющее


                                                          59

     знак.

   Перед символами преобразования d,  o  и  x  может  стоять
буква  l,  которая  означает, что в списке аргументов должен
находиться указатель на переменную типа long, а не типа int.
Аналогично,  буква l может стоять перед символами преобразо-
вания е или f, говоря о том, что в списке аргументов  должен
находиться  указатель  на  переменную типа double, а не типа
float.

   Например, обращение

         int  1;
         float х;
         char name[50];
         scanf("&d %f %s", &i, &х, name);

со строкой на вводе

         25    54.32e-1   thompson

приводит к присваиванию i значения 25, х - значения 5.432  и
name  -  строки  "thompson",  надлежащим образом законченной
символом \0. Эти три поля ввода можно разделить произвольным
числом  пробелов, табуляций и символов новой строки, сколько
вы пожелаете. Обращение

     int   i;
     float х;
     char name[50];
     scanf("%2d %f %*d %2s", &i, &х, name);

с вводом

         56789 0123 45а72

присвоит i значение 56, х - 789.0, пропустит 0123 и поместит
в name строку "45". При следующем обращении к любой процеду-
ре ввода рассмотрение начнется с буквы a. В этих двух приме-
рах  name является указателем и, следовательно, перед ним не
нужно помещать знак &.

   В качестве другого примера приведем программу для  сумми-
рования чисел, вводимых с терминала:

#include  <stdio.н>
 main()    /* Примитивный калькулятор */
 {
      double sum, v;
      sum =0;
      while (scanf("%lf", &v) !=EOF)
           printf("\t%.2f\n", sum += v);
 }

Выполнение функции scanf заканчивается либо тогда, когда она
исчерпывает  свою  управляющую  строку, либо когда некоторый
элемент ввода не соответствует очередной спецификации преоб-
разования.  В  качестве своего значения она возвращает число
правильно распознанных элементов ввода. Это число может быть
использовано  для определения количества найденных элементов
ввода. При выходе на  конец  файла  возвращается  EOF;  под-
черкнем,  что  это  значение  отлично от 0, означающего, что


60

следующий вводимый символ не удовлетворяет первой специфика-
ции  в  управляющей  строке. При следующем обращении к scanf
поиск возобновляется непосредственно за последним  введенным
символом.

   ПРЕДОСТЕРЕЖЕНИЕ: аргументы функции scanf должны быть ука-
зателями.  Несомненно, наиболее распространенная ошибка сос-
тоит в написании

        scanf("%d", n);

вместо

        scanf("%d", &n);




   14.5. Форматное преобразование в памяти


   От функции scanf и printf происходят  функции  sscanf   и
sprintf, которые осуществляют аналогичные преобразования, но
оперируют со строкой,  а  не  с  файлом.  Обращения  к  этим
функциям имеют вид:

  sprintf(string, control, arg1, arg2, ...)
  sscanf(string, control, arg1, arg2, ...)

Как и раньше , функция sprintf  преобразует  свои  аргументы
arg1,  arg2  и  т.д.  в соответствии с форматом, указанным в
control, но помещает результаты в string, а не в стандартный
вывод. Конечно, строка string должна быть достаточно велика,
чтобы принять результат. Например, если name - это  символь-
ный массив, а n - целое, то

        sprintf(name, "temp%d", n);

создает в name строку вида "tempnnn", где nnn - значение n.

   Функция sscanf выполняет обратные  преобразования  -  она
просматривает  строку string в соответствии с форматом в ар-
гументе control и помещает результирующие значения  в  аргу-
менты arg1, arg2 и т.д. Эти аргументы должны быть указателя-
ми. В результате обращения

        sscanf(name, "temp%d", &n);

переменная n получает значение  строки  цифр,  следующих  за
temp в name.


   14.6. Доступ к файлам


   Описанные в начале данного раздела  программы  читают  из
стандартного ввода и пишут в стандартный вывод, которые пре-
доставляются программе операционной системой.

   Для программ, которые сами должны организовывать связь  с
файлами,  в библиотеке ввода/вывода действуют следующие пра-
вила.


                                                          61


   Прежде чем  считывать из некоторого файла или  записывать
в него, этот файл должен быть открыт с помощью функции fopen
из стандартной библиотеки. Функция fopen берет  внешнее  имя
(подобное  х.с  или  "temp002") и возвращает внутреннее имя,
которое должно использоваться  при  последующих  чтениях  из
файла или записях в него.

   Это внутреннее имя, называемое "указателем файла", факти-
чески является указателем структуры, которая содержит инфор-
мацию о файле, такую как место  размещения  буфера,  текущая
позиция  символа в буфере, происходит ли чтение из файла или
запись в него и тому подобное. Пользователи не обязаны знать
эти  детали,  потому  что  среди  определений, получаемых из
файла  stdio.h,  содержится  определение   этой   структуры.
Единственное  необходимое  для  указателя файла описание де-
монстрируется примером:

                         FILE *fp;


   Здесь говорится, что  fp  является  указателем  на  FILE.
Обратите  внимание,  что file является именем типа, подобным
int,  а  не  ярлыком  структуры;   это   реализовано   через
"#define".

   Обращение к функции fopen в программе имеет вид:

                    fp=fopen(name,mode);

Первым аргументом функции fopen является "имя" файла,  кото-
рое  задается в виде символьной строки. Второй аргумент mode
("режим") также является символьной строкой, которая  указы-
вает,  как этот файл будет использоваться. Допустимыми режи-
мами являются:  чтение  ("r"),  запись  ("w")  и  добавление
("a"),  возможен еще символ "+" справа (например, "r+"), ко-
торый означает, что возможно и чтение, и запись в файл.

   Если вы откроете файл, который еще не существует, для за-
писи  или  добавления,  то такой файл будет создан (если это
возможно). Открытие существующего файла на запись приводит к
отбрасыванию  его  старого содержимого. Попытка чтения несу-
ществующего файла является ощибкой. Ошибки могут быть  обус-
ловлены  и  другими  причинами  (например, попытка чтения из
файла, не имея на то  разрешения).  При  наличии  какой-либо
ошибки  функция  возвращает  нулевое значение указателя NULL
(которое для удобства также определяется в файле stdio.h).

   Другой необходимой вещью является способ чтения или запи-
си, если файл уже открыт. Здесь имеется несколько возможнос-
тей, из которых getc и putc  являются  простейшими.  Функция
getc  считывает из файла следующий символ; ей необходим ука-
затель файла, чтобы знать, из какого файла  читать.  Обраще-
ние:

                         с=getc(fp)

помещает в "c" следующий символ из  файла,  указанного  пос-
редством fp, и EOF, если достигнут конец файла.





62

   Функция putc:

                         putc(с,fp)

помещает символ "c" в файл  fp  и  возвращает  "с".  Подобно
функциям  getchar и putchar, getc и putc могут быть макроса-
ми, а не функциями.

   При  запуске  программы  автоматически  открываются   три
файла,  которые  снабжены  определенными указателями файлов.
Этими файлами являются стандартный ввод, стандартный вывод и
стандартный  вывод  ошибок; соответствующие указатели файлов
называются stdin, stdout и stderr. Обычно все эти  указатели
связаны  с терминалом, но stdin и stdout могут быть перенап-
равлены на файлы или в межпроцессный канал.

   Функции getchar и putchar могут быть определены в  терми-
нах getc, putc, stdin и stdout следующим образом:

  #define getchar()    getc(stdin)
  #define putchar(с)   putc(с, stdout)

При работе с файлами для форматного ввода и вывода можно ис-
пользовать функции fscanf  и  fprintf. Они идентичны функци-
ям scanf  и  printf, за исключением того, что  первым  аргу-
ментом  является указатель файла, определяющий тот файл, ко-
торый будет читаться или куда будет вестись запись; управля-
ющая строка будет вторым аргументом.

   Указатели файлов stdin  и  stdout  заранее  определены  в
библиотеке  ввода-вывода  как стандартный ввод и стандартный
вывод; они могут быть использованы в любом месте, где  можно
использовать  об'ект  типа  FILE  *.  Они,  однако, являются
константами, а не переменными, так что их нельзя изменять.

   Функция fclose является обратной по  отношению  к  fopen;
она разрывает связь между указателем файла и внешним именем,
установленную функцией fopen, и высвобождает указатель файла
для другого файла. В операционной системе имеются  ограниче-
ния на число одновременно открытых  файлов,  которыми  может
распоряжаться  программа.  Функция  fclose закрывает файл, а
также вызывает выдачу информации из буфера, в  котором  putc
собирает  вывод (при нормальном завершении программы функция
fclose  вызывается  автоматически  для   каждого   открытого
файла).


   14.7. Обработка ошибок - stderr  и  exit


   При печати диагностических  сообщений  желательно,  чтобы
они  поступали на терминал, даже если стандартный вывод пос-
тупает в некоторый файл или в межпроцессный канал.

   Чтобы лучше  обрабатывать  такую  ситуацию,  к  программе
точно  таким же образом, как stdin  и  stdout, автоматически
присоединяется второй выходной файл, называемый stderr. Если
это вообще возможно, вывод, записанный в файле stderr, появ-
ляется на  терминале  пользователя,  даже  если  стандартный
вывод  направляется  в  другое  место (на самом деле имеется
возможность направить такие сообщения в файл,  но  этого  не
происходит при простом перенаправлении стандартного вывода).


                                                          63


   Программа может также использовать функцию exit из  стан-
дартной  библиотеки, обращение к которой вызывает завершение
выполнения программы. Аргумент функции exit  доступен  прог-
рамме,  вызвавшей программу пользователя в качестве подзада-
чи, так что она может проверить успешное или  неудачное  за-
вершение  данной  программы. По соглашению, величина 0 в ка-
честве возвращаемого значения свидетельствует о том, что все
в порядке, а различные ненулевые значения являются признака-
ми ненормальных ситуаций.

   Функция exit вызывает функцию fclose для каждого открыто-
го выходного файла, с тем чтобы вывести всю помещенную в бу-
феры выходную информацию, а затем  вызывает  функцию  _exit.
Функция _exit приводит к немедленному завершению без очистки
каких-либо буферов; конечно,  при  желании  к  этой  функции
можно обратиться непосредственно.


   14.8. Ввод и вывод строк


   Стандартная библиотека содержит функцию fgets. В  резуль-
тате обращения

        fgets(line, maxline, fp)

следующая строка ввода (включая символ новой строки)  считы-
вается  из  файла fp в символьный массив line; самое большее
maxline-1 символ будет прочитан. Результирующая  строка  за-
канчивается  символом  \0.  Обычно  функция fgets возвращает
line; в конце файла она возвращает NULL.

   Предназначенная для вывода функция fputs записывает стро-
ку  (которая  не  обязана  содержать  символ новой строки) в
файл:

        fputs(line, fp)


   Функции  gets  и  puts  являются  упрощенными  вариантами
fgets  и fputs, которые работают с файлами стандартного вво-
да и вывода и не проверяют длину строки; gets не  записывает
символ новой строки в память, а  puts дописывает этот символ
в  файл в конце строки:

        gets(line)
        puts(line)



   14.9. Функция ungetc


   Стандартная  библиотека  содержит  функцию,  возвращающую
последний считанный символ. В результате обращения

         ungetc(с,fp)

символ "c" возвращается в файл fp. Позволяется возвращать  в
каждый файл только один символ.



64

   14.10. Разные стандартные функции


   Стандартная библиотека предоставляет  множество  разнооб-
разных  функций,  некоторые  из которых оказываются особенно
полезными.


   14.10.1. Управление памятью


   Функция calloc служит для запросов памяти.  В  результате
обращения

         calloc(n, sizeof(objеct))

возвращается либо указатель пространства,  достаточного  для
размещения  n  об'ектов  указанного размера, либо NULL, если
запрос не может быть удовлетворен. Отводимая  память  иници-
ализируется нулевыми значениями. Функция malloc делает то же
самое, но память задается в байтах:

        malloc(size)


   Указатель обладает нужным  для  рассматриваемых  об'ектов
выравниванием,  но  ему  следует приписывать соответствующий
тип, как в следующем примере

         char *calloc();
         int *ip;
         ip=(int*) calloc(n,sizeof(int));


   Функция free(р) освобождает пространство, на которое ука-
зывает  "р",  причем указатель "р" первоначально должен быть
получен в результате обращения к calloc. Здесь  нет  никаких
ограничений  на  порядок освобождения пространства, но осво-
бождение чего либо, не  полученного  с  помощью  calloc  или
malloc, приводит к тяжелым ошибкам.


   14.10.2. Стандартные функции языка Си


   В стандартную библиотеку функций на языке Си входит,  по-
мимо  описанных,  множество  самых разных функций. Подробное
описание их  приведено  в  руководстве  программисту  по  ОС
ДЕМОС, часть 4 (библиотечные функции), и в оперативной доку-
ментации ("man(3)"). Ниже в скобках приведены названия  раз-
делов  оперативной  документации,  в  которых  имеются соот-
ветствующие описания:

   - операции со строками (string);

   - преобразование данных без "sscanf" и  "sprintf"  (atoi,
     itoa, atof, ftoa);

   - математические функции (sin, exp, ...);





                                                          65

   - проверка и преобразование символов (ctype);

   - и многое другое.





























































66




         15. ВЗАИМОДЕЙСТВИЕ С ОПЕРАЦИОННОЙ СИСТЕМОЙ



   15.1. Подготовка программ на 'Си' в ОС ДЕМОС


   В операционной системе ДЕМОС программы могут состоять  из
одного  или  нескольких  модулей,  написанных  на языках Си,
Фортран-77, Ассемблер. Для трансляции и сборки  программ  на
языке "Си" служит команда "cc". В простейшем случае трансля-
ция осуществляется по команде:

 cc файл1.c файл2.c ...

где "файл1.c", "файл2.c", ...  -  имена  файлов,  содержащих
программы  на  языке "Си" (имена таких файлов должны оканчи-
ваться на суффикс ".c"). Команда осуществляет трансляцию пе-
речисленных  программ  и  их  об'единение редактором связей.
Если трансляция прошла  без  ошибок,  создается  исполняемый
файл  "a.out", который можно запустить на счет, введя коман-
ду:

 a.out

(то есть набрав просто имя этого  файла).  Трансляцию  часто
проводят в два этапа: сначала транслируют отдельные програм-
мы, получая об'ектные модули, а затем об'единяют  их  вместе
(в  предыдущем примере это было сделано автоматически коман-
дой "cc"). Раздельная трансляция выглядит примерно так:

 cc файл1.c файл2.c ...
 cc файлN.c файлN1.c ...
 cc файл1.o файл2.o ... файлN.o ...

В более сложном случае программа может состоять  из  модулей
на  разных языках, результат трансляции может быть записан в
файл, отличный от "a.out", можно  оттранслировать  программу
для  отладки  с  помощью  отладчика "cdeb", и т.п. Подробное
описание вызова компилятора имеется в  руководстве  програм-
миста  (cc(1), ld(1)). В общем случае программы на Си запус-
каются интерпретаторами shell или cshell командой:

имя_файла аргументы назначение_ввода_вывода

где любая часть, кроме  имени файла, может отсутствовать.

   Любая программа на Си в ОС ДЕМОС должна содержать  голов-
ную  функцию  с именем "main". Работа программы начинается с
этой функции, причем информация о аргументах команды переда-
ется через ее формальные параметры.










                                                          67

   15.2. Доступ к аргументам команды


   Операционная система ДЕМОС позволяет передавать аргументы
команды начинающей выполняться программе. Когда функция main
вызывается системой, она  вызывается  с  двумя  аргументами.
Первый аргумент (типа int, условно называемый argc) указыва-
етчисло аргументов в командной строке, с которыми происходит
обращение  к программе; второй аргумент (argv) является ука-
зателемна массив символьных строк, содержащих эти аргументы,
по одному в строке.

   Самую простую иллюстрацию этой возможности и  необходимых
при  этом описаний дает программа еcho, которая просто печа-
тает в одну строку аргументы командной строки,  разделяя  их
пробелами. , Если дана команда

        echo hello, world

 то в результате получим:

        hello, world


   По соглашению argv[0] является именем, по которому  вызы-
вается  программа,  так  что argc по меньшей мере равен 1. В
приведенном выше примере argc равен 3, а argv[0], argv[1]  и
argv[2]  равны  соответственно  "есно",  "hello," и "world".
Первым фактическим агументом является argv[1], а последним -
argv[argc-1].  Если  argc равен 1, то за именем программы не
следует никакой командной строки аргументов. Все это показа-
но в echo:

 main(argc, argv)
 int argc;
 char *argv[];
 {
    int i;
    for (i = 1; i < argc; i++)
        printf("%s%с", argv[i],
          (i<argc-1) ? ' ' : '\n');
 }

Поскольку argv является указателем на массив указателей,  то
существует  несколько способов написания этой программы, ис-
пользующих работу с указателем, а не с индексацией  массива.
Следующий пример демонстрирует другой вариант:

 main(argc, argv)
 int argc;
 char **argv;
 {
    while (--argc > 0)
        printf("%s%c",*++argv,
        (argc > 1)     ? ' ' : '\n');
 }


   Кроме строки аргументов, программа  получает  от  системы
набор  переменных, описывающих среду, в которой она выполня-
ется. Каждая переменная состоит из имени и значения (тексто-
вой  строки). Например, переменная  "TERM" передает тип тер-


68

минала, с которого программа запущена. Для запроса  значения
переменной по имени используется функция "getenv":

char *getenv();
par = getenv("имя_переменной")

Функция возвращает указатель на строку -  значение  перемен-
ной, либо NULL, если имя не найдено в описании среды.
























































                                                          69




                16. ИНТЕРФЕЙС СИСТЕМЫ ДЕМОС


   Все без исключения возможности операционной системы ДЕМОС
доступны  из программ на языке Си. Материал этой главы отно-
сится к интерфейсу между Си-программами и операционной  сис-
темой  ДЕМОС. Материал  делится на следующие части: ввод/вы-
вод, система файлов, процессы, сигналы. Предполагается  зна-
ние  основных  концепций  ОС  ДЕМОС, а также понятий "файл",
"процесс", "сигнал". Подробное описание системных вызовов  и
соответствующих им функций из стандартной библиотеке имеется
в руководстве программиста по ОС ДЕМОС и в оперативной доку-
ментации  (части 2 и 3). Например, если в описании говорится
о функции "popen(3)",  то подробное описание следует  искать
в руководстве программиста, часть 4, или в оперативной доку-
ментации, часть 3; справку о функции можно получить на  тер-
минал, набрав "man 3 popen".


   16.1. Ввод/вывод


   В описании библиотеки ввода/вывода был описан универсаль-
ный  интерфейс, который одинаков для всего многообразия опе-
рационных систем. На каждой конкретной операционной  системе
функции стандартной библиотеки должны быть написаны в терми-
нах ввода-вывода, доступных на данной  машине.  В  следующих
разделах  описан  набор функций ввода/вывода нижнего уровня,
поддерживаемых ядром операционной системы ДЕМОС.


   16.1.1. Дескрипторы файлов


   В операционной системе  ДЕМОС  весь  ввод  и  вывод  осу-
ществляется  посредством чтения файлов или их записи, потому
что все периферийные устройства, включая  терминал пользова-
теля,  являются  файлами  определенной файловой системы. Это
означает, что один однородный интерфейс управляет всеми свя-
зями между программой и периферийными устройствами.

   В наиболее общем случае перед чтением из  файла  или  за-
писью в файл необходимо сообщить системе о намерении сделать
это; этот процесс называется "открытием" файла. Система  вы-
ясняет,  имеет  ли  программа  право поступать таким образом
(существует ли этот файл? имеется ли  разрешение на  обраще-
ние  к  нему?), и если все в порядке, возвращает в программу
небольшое положительное целое число, называемое дескриптором
файла.  Всякий  раз,  когда этот файл используется для ввода
или вывода, для идентификации файла употребляется дескриптор
файла,  а  не его имя (здесь существует примерная аналогия с
использованием read (5,...) и write (6,...) в Фортране). Вся
информация об открытом файле содержится в системе; программа
пользователя обращается  к  файлу  только  через  дескриптор
файла.

   Для удобства выполнения обычных операций ввода и вывода с
помощью терминала пользователя существуют специальные согла-
шения. Когда интерпретатор команд ("shell") прогоняет  прог-


70

рамму,  он  открывает три файла, называемые стандартным вво-
дом, стандартным выводом и стандартным выводом ошибок, кото-
рые  имеют соответственно числа 0, 1 и 2 в качестве дескрип-
торов этих файлов. В нормальном состоянии все они связаны  с
терминалом,  так  что  если  программа читает с дескриптором
файла 0 и пишет с дескрипторами файлов 1 и 2, то  она  может
осуществлять  ввод  и вывод с помощью терминала, не заботясь
об открытии соответствующих файлов.

   Пользователь программы может перенаправлять ввод и  вывод
на  файлы,  используя  в интерпретаторе команд символы "<" и
">":

        prog <infile >outfile

В этом  случае  интерпретатор  команд   изменит  определение
дескрипторов  файлов  0  и 1 с терминала на указанные файлы.
Обычно дескриптор файла 2 остается связанным  с  терминалом,
так  что сообщения об ошибках могут поступать туда. Подобные
замечания справедливы и тогда, когда ввод и вывод  связан  с
межпроцессным  каналом.  Следует отметить, что в этом случае
связь программы с файлами изменяется  интерпретатором  shell
(или  cshell), а не программой. Сама программа, пока она ис-
пользует файл 0 для ввода и файлы 1 и 2 для вывода, не знает
ни откуда приходит ее ввод, ни куда поступает ее выдача.


   16.1.2. Низкоуровневый ввод/вывод - операторы  read  и
           write.


   Самый низкий уровень ввода/вывода в системе ДЕМОС не пре-
дусматривает  ни какой-либо буферизации, ни какого-либо дру-
гого сервиса; он по существу является непосредственным обра-
щением к операционной системе. Весь ввод и вывод осуществля-
ется двумя функциями: read и write. Первым аргументом  обеих
функций является дескриптор файла. Вторым аргументом являет-
ся буфер в вашей программе, откуда или куда должны поступать
данные.  Третий  аргумент  -  это число подлежащих пересылке
байтов. Обращения к этим функциям имеют вид:

        n_read=read(fd,buf,n);
        n_written=write(fd,buf,n);

При каждом обращении возвращается счетчик  байтов,  указыва-
ющий фактическое число переданных байтов. При чтении возвра-
щенное число байтов может оказаться меньше, чем  запрошенное
число.  Возвращенное  нулевое  число  байтов  означает конец
файла, а "-1" указывает на наличие  какой-либо  ошибки.  При
записи возвращенное значение равно числу фактически записан-
ных байтов; несовпадение этого числа с числом байтов,  кото-
рое предполагалось записать, обычно свидетельствует об ошиб-
ке.

   Количество байтов, подлежащих чтению  или  записи,  может
быть совершенно произвольным. Двумя самыми распространенными
величинами являются "1", что означает передачу одного симво-
ла  за  обращение  (т.е. без использования буфера), и "512",
что соответствует физическому размеру блока на многих  пери-
ферийных  устройствах.  Этот последний размер будет наиболее
эффективным, но даже ввод или вывод по одному символу за об-
ращение не будет слишком дорогим.


                                                          71


   Пример. Копирование ввода на вывод. В системе  ДЕМОС  эта
программа  будет  копировать  что угодно куда угодно, потому
что ввод и вывод могут быть перенаправлены на любой файл или
устройство.

#define BUFSIZE 512
main() /*copy input то output*/
{
     char buf[BUFSIZE];
     int n;
     while((n=read(0,buf,BUFSIZE))>0)
          write(1,buf,n);
}

Если размер файла не будет кратен BUFSIZE, то при  очередном
обращении  к read будет возвращено меньшее число байтов, ко-
торые затем записываются  с  помощью  write;  при  следующем
после этого обращении к read будет возвращен нуль.


   16.1.3. Открытие,  создание,   закрытие   и   удаление
           (unlink)


   Во всех случаях, если только не используются определенные
по  умолчанию  стандартные  файлы ввода, вывода и ошибок, вы
должны явно открывать файлы, чтобы затем читать из  них  или
писать  в  них. Для этой цели существуют две функции: open и
creat.

   Функция open весьма сходна с функцией fopen,  рассмотрен-
ной выше, за исключением того, что вместо возвращения указа-
теля файла она возвращает дескриптор файла, который является
просто целым типа int.

        int fd;
        fd=open(name,rwmode);

Как и в случае  fopen,  аргумент  name  является  символьной
строкой,  соответствующей внешнему имени файла. Однако аргу-
мент, определяющий режим доступа, отличен: rwmode равно: 0 -
для  чтения,  1  - для записи, 2 - для чтения и записи. Если
происходит какая-то ошибка, функция open возвращает "-1";  в
противном  случае  она возвращает неотрицательный дескриптор
файла.

   Попытка открыть файл,  который  не  существует,  является
ошибкой.  Функция  creat  предоставляет возможность создания
новых файлов или перезаписи старых. В результате обращения:

        fd=creat(name,pmode);

возвращает  дескриптор  файла,  если   оказалось   возможным
создать  файл с именем name, и "-1" в противном случае. Соз-
дание файла, который уже существует,  не  является  ошибкой:
creat усечет его до нулевой длины.

   Если файл ранее не существовал, то creat  создает  его  с
определенным   режимом  защиты,  специфицируемым  аргументом
pmode. В системе файлов ОС ДЕМОС с файлом связываются девять
битов  защиты  информации,  которые управляют разрешением на


72

чтение, запись и выполнение для владельца файла, для  группы
владельцев  и  для всех остальных пользователей. Таким обра-
зом, трехзначное восьмеричное число наиболее удобно для  за-
писи  режима  защиты. Например, число 0755 свидетельствует о
разрешении на чтение, запись и выполнение для владельца и  о
разрешении  на чтение и выполнение для группы и всех осталь-
ных.

   Существует ограничение (обычно 15  -  25)  на  количество
файлов,  которые программа может иметь открытыми одновремен-
но. В соответствии с этим любая программа, собирающаяся  ра-
ботать  со  многими файлами, должна быть подготовлена к пов-
торному использованию дескрипторов файлов.  Процедура  close
прерывает связь между дескриптором файла и открытым файлом и
освобождает дескриптор  файла  для  использования  с  другим
файлом. Завершение выполнения программы через exit или в ре-
зультате возврата из головной функции  приводит  к  закрытию
всех открытых файлов.

   Функция удаления unlink(filename) удаляет из системы файл
с именем filename (Точнее, удаляет имя "filename", файл уда-
ляется, если на него не остается ссылок под другими именам).


   16.1.4. Произвольный доступ - lseek


   Обычно при работе с файлами ввод и  вывод  осуществляется
последовательно:  при  каждом  обращении  к  функциям read и
write чтение или запись начинаются с позиции, непосредствен-
но следующей за предыдущей обработанной. Но при необходимос-
ти файл может читаться или записываться в любом произвольном
порядке.  Обращение к системе с помощью функции lseek позво-
ляет передвигаться по файлу, не производя фактического  чте-
ния или записи. В результате обращения

         lseek(fd,offset,origin);

текущая позиция в файле с дескриптором fd  передвигается  на
позицию  offset  (смещение), которая отсчитывается от места,
указываемого аргументом origin (начало отсчета). Последующее
чтение  или  запись  будут теперь начинаться с этой позиции.
Аргумент offset имеет тип long; fd и origin имеют  тип  int.
Аргумент  origin может принимать значения 0, 1 или 2, указы-
вая на то, что величина offset  должна  отсчитываться  соот-
ветственно  от начала файла, от текущей позиции или от конца
файла. Например, чтобы дополнить файл, следует перед записью
найти его конец:

         lseek(fd,0l,2);

чтобы вернуться к началу, можно написать:

         lseek(fd,0l,0);

Обратите внимание на аргумент 0l; его можно было бы записать
и в виде (long) 0.

   Функция lseek позволяет обращаться с файлами примерно так
же,  как с большими массивами, только ценой более медленного
доступа.



                                                          73

Пример. Функция, считывающая любое количество байтов,  начи-
ная с произвольного места в файле.

/*читать n байтов с позиции pos в buf */
    get(fd,pos,buf,n)
    int fd, n;
    long pos;
    char *buf;
    {
         lseek(fd,pos,0); /*get to pos */
         return(read(fd,buf,n));
    }



   16.2. Управление процессами


   В операционной системе Демос часто требуется  вызвать  из
программы  и  выполнить  в  виде  отдельного процесса другую
программу. Следующий раздел описывает простейший способ сде-
лать  это, а далее будут рассмотрены базовые средства управ-
ления процессами, имеющиеся в ОС ДЕМОС.


   16.2.1. Функция 'system'


   Простейший способ вызвать другую программу - использовать
стандартную функцию "system":

 system("командная строка")

Функция имеет один параметр - строку, которую она анализиру-
ет и выполняет точно так же, как выполняются команды, вводи-
мые интерпретатором "shell" с терминала.  Функция  выполняет
команду  и  возвращает  целое число - код ответа выполненной
команды (0, если  все  кончилось  нормально).  В  "командной
строке" воспринимаются любые символы управления вводом/выво-
дом ">", "<", и т.п.

   Следует учесть, что, если в программе вывод буферизуется,
то  перед вызовом функции "system" необходимо вытолкнуть бу-
фера, например вызвав функцию "fflush".


   16.2.2. Вызов программы на низком уровне - execl


   Вызов программы в ОС ДЕМОС осуществляется с помощью  нес-
кольких  элементарных  функций,  одна  из  которых - функция
execl - осуществляет вызов новой программы вместо уже выпол-
няющейся,  без  возврата в вызывающую программу. Обращение в
ней имеет вид:

 execl(команда,арг0,арг1,...,аргN,NULL);

где "команда" - строка символов, точно именующая файл  вызы-
ваемой команды. Например, для вызова команды "pr" необходимо
указать имя "/bin/pr". Остальные аргументы также представля-
ют  собой  строки символов и просто передаются команде в ка-
честве аргументов, при этом "арг0" обычно представляет собой


74

просто  сокращенное имя команды, а остальные аргументы - па-
раметры данной команды.

   Вызов "execl" в случае нормального запуска новой програм-
мы  заменяет  ею  текущую  программу,  управление из функции
"execl" возвращается только в случае  ошибки  (например,  не
найдена  команда  с  указанным именем). В библиотеке имеется
целый набор функций, осуществляющих то же  самое  и  отлича-
ющихся   только   представлением   параметров   ("execl(2)",
"execv(2)", "execvp(2)", ...) и тем, что  некоторые  функции
осуществляют  поиск  команды в стандартном наборе справочни-
ков.


   16.2.3. Порождение нового процесса - fork


   Для того, чтобы запустить  параллельно  новую  программу,
необходимо  прежде  всего  уметь запускать параллельный про-
цесс. Для этого в ОС ДЕМОС служит  функция  "fork"  (развет-
виться):

 proc_id = fork()

Программа разделяется на две идентичные копии, которые  про-
должают  выполняться  как  два независимых процесса. Одна из
программ - процесс "сын" - получает от  функции  "fork"  код
ответа  0, другая - "родитель" - получает номер, под которым
запущен процесс "сын". В простейшем случае для  запуска  па-
раллельной  программы  вызов  "fork" комбинируется с "execl"
следующим образом:

 if( fork() == 0)
 { /* Это процесс - сын */
 ... настройка файлов ...
 execl(... );
 /*Сюда мы попадаем при ошибке в "execl"*/
 perror("Не могу запустить процесс");
 exit(1);
 }
 ... продолжение основной программы ...

Здесь программа после вызова  "fork"  анализирует,  в  каком
процессе ("родитель" или "сын") она выполняется и, в зависи-
мости от этого, ведет себя по разному. Если  основная  прог-
рамма  должна  ждать окончания "сына", то она должна вызвать
функцию "wait":

 int status;
 ...
 if( fork() == 0)
 { ... execl(...); exit(1);
 }
 wait(&status));

Функция "wait" возвращает идентификатор процесса - "сына", и
засылает  в переменную "status" код завершения этого процес-
са. Код завершения состоит из двух частей - младшие 8  битов
формируются  системой и обозначают причину окончания процес-
са; в случае нормального окончания по функции "exit" они со-
держат  0.  Старшие 8 битов в случае, если программа окончи-
лась в результате вызова "exit", берутся из аргумента вызова


                                                          75

функции  "exit"; обычно передается 0 при нормальном заверше-
нии и число, отличное от нуля, в случае каких либо ошибок.

   Ни "fork", ни "execl"  не  затрагивают  открытых  файлов,
после  "fork"  ранее  открытые файлы начинают использоваться
обоими процессами совместно, то есть используются одни и  те
же  указатели  позиции  чтения/записи.  Если новому процессу
требуется передать какие то  открытые  файлы,  или  изменить
файлы  стандартного ввода/вывода, настройка программы на эти
файлы делается после вызова "fork" в процессе - сыне до  вы-
зова  "execl". Следует заметить, что при буферизованном вво-
де/выводе необходимо сбросить буфера перед вызовом "fork()",
иначе  вывод накопленной информации может произойти дважды -
и в "родительском", и в новом процессе.


   16.2.4. Канал межпроцессной связи


   Межпроцессный канал - это особый файл,  устроенный  таким
образом,  что  один  процесс неограниченно записывает в него
информацию, а другой читает, причем система обеспечивает бу-
феризацию  данных  и  синхронизацию процессов. Межпроцессные
каналы могут создаваться интерпретатором команд "shell"  или
"cshell", например:

 ls | pr

Существуют библиотечные функции "popen" и "pclose", позволя-
ющие  запустить  параллельный  процесс, который будет читать
информацию, записываемую в указанный файл данным  процессом,
или,  напротив,  будет  поставлять  породившему его процессу
данные для чтения (см. "popen(3)"). Эти  функции  используют
базовые  возможности построения каналов, которые поддержива-
ются операционной системой.

   Для создания канала межпроцессной  связи  служит  функция
"pipe":

 int fd[2];
 ...
 stat = pipe(fd);
 if(stat == -1) /* Была ошибка */...

Здесь fd - массив,  в  который  засылается  два  дескриптора
файлов - fd[1] для записи в канал, fd[0] для чтения из кана-
ла. Эти дескрипторы могут использоваться наравне с  дескрип-
торами обычных файлов.

   Синхронизация обменов построена таким образом, что,  если
процесс  читает  пустой  канал,  он  будет  ждать  появления
данных; если в канале осталось много несчитанной информации,
записывающий  процесс будет ждать освобождения места в кана-
ле. Наконец, если у канала сторона для записи  закрыта,  при
чтении будет получен код ответа "0" - конец файла.

   Как правило, программа создает канал по  запросу  "pipe",
после  чего  разделяется  на  две  копии  с  помощью функции
"fork". Затем в одном из получившихся процессов  закрывается
сторонаканала для чтения,  в другом - закрывается дескриптор
записи в канал. Теперь после вызова "execl" начинается обмен
информацией  по  межпроцессному каналу между параллельно вы-


76

полняющимися программами.

   В случае, если обмен должен происходить через стандартный
ввод  или  вывод,  используется функция "dup" для связывания
дескрипторов файлов. Например, следующий фрагмент  программы
служит для запуска программы "pr" так, чтобы данные на стан-
дартный ввод программы "pr" поступали из стандартного вывода
основной программы:

 int fd[2];
#define R 0
#define W 1
 pipe(fd);
 if(fork() == 0)
 { close(fd[W]); close(0); dup(fd[R]);
   close(fd[R]);
   execl("/bin/pr","pr",NULL);
   _exit(1);  /* Если ошибка в execl */
 }
 close(fd[R]); close(1); dup(fd[W]);
 close(fd[W]);
 .... счет, при записи проверяем, не было
 .... ли ошибки записи.
 close(1);

В этом примере полностью опущена обработка возможных ошибок.
Для  связывания дескрипторов стандартного ввода или вывода с
каналом  межпроцессной  связи  здесь  использована   функция
"dup(fd)",  которая  возвращает  дупликат  дескриптора "fd",
причем используется наименьший свободный  дескриптор  файла.
Следовательно, после закрытия файла с дескриптором 0 ближай-
шее обращение к функции "dup" свяжет дескриптор 0 с заданным
в  аргументе "dup" дескриптором. После вызова "dup" ненужный
больше дескриптор "fd[0]" или "fd[1]" закрывают.


   16.3. Сигналы и прерывания


   Нормальный ход выполнения программы в ОС ДЕМОС может пре-
рываться "сигналами". Сигналы могут появляться как в резуль-
тате действия внешних причин (например, в результате нажатия
на  терминале клавиши, интерпретируемой системой как "преры-
вание" - "interupt"), так и в результате ошибок программы.

   Функция, изменяющая принятые  по  умолчанию  действия  по
сигналу,  называется  "signal" и имеет два аргумента. Первый
специфицирует сигнал, а второй представляет собой либо ссыл-
ку на функцию, либо специальное выражение, означающее требо-
вание "игнорировать" сигнал  либо  "стандартная  реакция  на
сигнал".  Условные  обозначения  записаны  в  файле  вставок
"signal.h":

#include <signal.h>
 signal(СИГНАЛ,РЕАКЦИЯ)

СИГНАЛ - это один из стандартных  кодов  сигналов,  например
SIGINT,  SIGKILL, ... (подробнее см. "signal(2)"). РЕАКЦИЯ -
это либо ссылка на функцию, которая будет вызвана при  полу-
чении сигнала, либо один из идентификаторов:




                                                          77

 SIG_IGN - игнорировать,
 SIG_DFL - по умолчанию.

Во всех случаях функция "signal" возвращает старое  значение
описателя  РЕАКЦИЯ.  Существуют  некоторые тонкости, которые
иллюстрируются следующим фрагментом программы:

#include <signal.h>
main()
{
 int onintr(); /* Описание обязательно */
 if(signal(SIGINT,SIG_IGN) != SIG_IGN)
 { signal(SIGINT, onintr); }
 ...
  exit(0);
}

onintr()
{ unlink(tempfile);
  exit(1);
}

Проверка ("if(signal...") связана с тем, что сигнал "SIGINT"
посылается  на  все  процессы,  начатые с данного терминала.
Если программа выполняется в фоновом  режиме,  интерпретатор
"shell"  при запуске программы устанавливает в ней игнориро-
вание сигнала "SIGINT", для того, чтобы с терминала прерыва-
лись  только  интерактивные процессы. Переключение обработки
сигнала "SIGINT" на  функцию  "onintr"  без  проверки  пере-
черкнуло  бы  все действия "shell" по защите фоновых процес-
сов.

   Еще одна особенность связана с возвратом из программы об-
работки сигнала. Если прерывание произошло во время выполне-
ния программы, возврат из функции обработки прерывания  при-
ведет к нормальному продолжению ее выполнения. Если, однако,
прерывание пришло во время операции чтения с терминала, опе-
рация чтения будет прервана, и произойдет возврат из функции
чтения "read"  с  нулевым  счетчиком  байтов.  Как  правило,
функция обработки прерываний должна в таких случаях устанав-
ливать какой либо флаг, а программа чтения, получив  нулевой
счетчик  байтов  после операции "read", может проверить этот
флаг и установить, что же произошло - достигнут конец  файла
или было прерывание.

   Если программа обладает средствами реакции на  прерывания
и,  в то же время, вызывает другие программы, желательно уп-
равлять реакцией на прерывание примерно таким образом:

 signal(SIGINT, onintr);
 ...
 if(fork() == 0)
 { signal(SIGINT, SIG_DFL);
   execl(...)
   ...
 }
 signal(SIGINT, SIG_IGN);
 wait(&status);
 signal(SIGINT, onintr);

В этом случае прерывания, посылаемые с  терминала  во  время
выполнения запущенной параллельно программы, будут прерывать


78

только эту программу.































































                                                          79


     ЛИТЕРАТУРА


1. Б. Керниган. Д. Ритчи. Язык программирования Си.  А.  Фь-
   юэр.  Задачи  по  языку  Си.  М., "Финансы и статистика",
   1985.

2. А.Г. Иванов. Язык программирования Си. В сборнике  "Прик-
   ладная информатика" под ред. В.М. Савинкова.  М., "Финан-
   сы и статистика", 1985, выпуск 1(8).





















































80

                                                 ПРИЛОЖЕНИЕ 


              1. Сводка синтаксических правил


   эта сводка синтаксиса языка "Си" предназначена скорее для
облегчения понимания и не является точной формулировкой язы-
ка.


   1.1. Выражения


   Основными выражениями являются следующие:

выражение:
       первичное_выражение
     * выражение
     & выражение
     - выражение
     ! выражение
     ~ выражение
    ++ l_значение
    -- l_значение
       l_значение ++
       l_значение --
       sizeof выражение
       (имя типа) выражение
       выражение бинарная_операция
                          выражение
       выражение ? выражение : выражение
       l_значение операция_присваивания
                           выражение
       выражение , выражение
первичное_выражение:
     идентификатор
     константа
     строка
     (выражение)
     первичное_выражение (список выражений)
                                      необ
     первичное_выражение [выражение]
     l_значение . Идентификатор
     первичное выражение -> идентификатор
l_значение:
     идентификатор
     первичное_выражение [выражение]
     l_значение . Идентификатор
     первичное_выражение -> идентификатор
     * выражение
     (l_значение)

Операции первичных выражений

         ()  []  .  ->

имеют самый высокий приоритет и группируются слева  направо.
Унарные операции





                                                          81

  *  &  -  !  ~  ++  --  sizeof(имя типа)

имеют более низкий приоритет, чем операции первичных выраже-
ний,  но  более высокий, чем приоритет любой бинарной опера-
ции. Эти операции группируются справа налево. Условная  опе-
рация  группируется  справа  налево,  все  бинарные операции
группируются слева направо и их приоритет убывает  в  следу-
ющем порядке:

    бинарная операция:
                   *   /   %
                   +   -
                   >>  <<
                   <   >  <=    >=
                   ==  !=
                   &
                   ~
                   |
                   &&
                 ||
                   ?:

Все операции присваивания имеют одинаковый приоритет и груп-
пируются справа налево:

=  +=  -=  *=  ?=  %= >>=  <<=  &=  ~=  |=

Операция запятая имеет самый низкий приоритет и группируется
слева направо.


   1.2. Описания


Описание:

спецификаторы_описания список_инициа-
                     лизируемых_описателей;
                                       необ


Спецификаторы_описания:

  спецификатор_типа спецификаторы_описания
                                       необ
    спецификатор_класса_памяти специфи-
                            каторы_описания
                                       необ
спецификатор_класса_памяти:
         auto
         static
         extern
         register
         typedef

спецификатор_типа:
         char
         short
         int
         long
         unsigned
         float


82

         double
    спецификатор_структуры_или_об'единения
    определяющее_тип_имя
    спецификатор_перечисления

список_инициализируемых_описателей:
    инициализируемый_описатель
    инициализируемый_описатель,спи-
          сок_инициализируемых_описателей

инициализируемый_описатель
         описатель_инициализатор
                             необ

описатель:
    идентификатор
    (описатель)
    * описатель
    описатель ()
    описатель [константное выражение ]
                                 необ

спецификатор_структуры_или_об'единения:
    struct список_описателей_структуры
    struct идентификатор {список_опи-
                          саний_структуры}
    struct идентификатор
    union {список_описаний_структуры}
    union идентификатор {список_опи-
                         саний_структуры}
    union идентификатор

список_описаний_структуры:
    описание_структуры
    описание_структуры список_опи-
                       саний_структуры

описание структуры:
    спецификатор_типа список_описа-
                      телей_структуры

список_описателей_структуры
    описатель_структуры
    описатель_структуры,список_описа-
                        телей_структуры

описатель_структуры:
    описатель
    описатель: константное выражение
    :константное_выражение

инициализатор:
    = выражение
    = {список_инициализатора}
    = {список_инициализатора}

список инициализатора:
    выражение
    список_инициализатора,список_ини-
                          циализатора
    {список_инициализатора}



                                                          83

имя_типа:
    спецификатор_типа абстракт-
                      ный_описатель

абстрактный_описатель:
    пусто
    {абстрактный_описатель}
    * абстрактный_описатель
    абстрактный_описатель ()
    абстрактный_описатель [констант-
                           ное_выражение]
                                    необ

определяющее_тип_имя:
    идентификатор

спецификатор_перечисления:
   enum список_перечисления
   enum идентификатор  список_перечисления
   enum идентификатор

список_перечисления:
   перечисляемое
   список_перечисления, перечисляемое

перечисляемое:
   идентификатор
   идентификатор = константное выражение




   1.3. Операторы


составной_оператор:
    {список_описаний список_операторов}
                 необ              необ

список_описаний:
    описание
    описание список_описаний

список_операторов:
    оператор
    оператор список_операторов

оператор:
    составной оператор
    выражение;
    if (выражение) оператор
    if (выражение) оператор else оператор
    while (выражение) оператор
    do оператор while (выражение);
    for(выражение1;выражение2;выражение3)
               необ       необ       необ
         оператор
    switch (выражение) оператор
    case константное_выражение : оператор
    default: оператор
    break;
    continue;


84

    return;
    return выражение;
    goto идентификатор;
    идентификатор : оператор
    ;




   1.4. Внешние определения


программа:
    внешнее_определение
    внешнее_определение программа

внешнее_определение:
    определение_функции
    определение_данных

определение_функции:
    спецификатор_типа  описатель_функ-
                  необ
                       ции тело_функции

описатель_функции:
    описатель (список_параметров)
                             необ
список_параметров:
    идетификатор
    идентификатор , список_параметров

тело_функции:
    список_описаний_типа оператор_функции

оператор_функции:
    {список описаний список_операторов}
                 необ

определение данных:
    extern    спецификатор_типа    спи-
       необ                 необ
           сок инициализируемых описателей;
                                       необ
    static    спецификатор типа     список
          необ                 необ
              инициализируемых описателей;
                                      необ




   1.5. Препроцессор


#define идентификатор строка_лексем
#define идентификатор(идентифика-
       тор,...,идентификатор) строка_лексем
#undef идентификатор
#include "имя_файла"
#include <имя_файла>
#if константное_выражение


                                                          85

#ifdef идентификатор
#ifndef идентификатор
#else
#endif
#line константа "имя_файла"
                        необ


























































86

                                                 ПРИЛОЖЕНИЕ 


                 2. Примеры программ на Си


   Пример 1: функции  fgets и fputs (см. раздел "Стандартная
библиотека ввода/вывода. Ввод/вывод строк").

#include  <stdio.н>
char *fgets(s,n,iop) /*взять<=n символов*/
char *s;             /* из iop */
int n;
register FILE *iop;
{
     register int с;
     register char *cs;
     cs = s;
     while(--n>0&&(с=getc(iop)) !=EOF)
          if ((*cs++ = с)=='\n')
               break;
     *cs = '\0';
     return((с==EOF && cs==s) ? NULL : s);
}
fputs(s,iop) /*поместить строку s в */
register char *s;  /* файл iop */
register FILE *iop;
{
     register int с;
     while (с = *s++)
          putc(с,iop);
}


Пример 2. Программа для разделения одного большого файла  на
несколько частей так, чтобы каждая часть начиналась со стро-
ки ".sh 1 ...".

#include <stdio.h>
#define NEWH ".sh 1" /*Признак разделения*/

/* Трансляция:
  cc -o ds ds.c
   Запуск:
ds откуда кудапреф кудасуфф
   результат:
ds a pref suff
переписывает файл a в файлы
pref00.suff, pref01.suff, ...
*/

main(ac,av)
char **av;
{
 int nfile=0;   /* Порядковый номер файла*/
 char str[512]; /*Буфер для строки*/
 if(ac != 4)
 {
  fprintf(stderr,
      "Неверное число аргументов0);
  exit(1);
 }


                                                          87

/* freopen аналогично fopen, но изменяет
указанный описатель файла, а не создает
новый. Здесь мы переопределяем
"stdin" */
 if(!freopen(av[1],"r",stdin))
 {
  fprintf(stderr,
         "Не могу открыть:%s0,av[1]);
         exit(2);
 }
/* Переопределили файл станд. вывода */
 of(av[2],nfile,av[3]);

 while( gets(str))
 {
/* strncmp(s1,s2,l) сравнивает две строки
 и возвращает 0, если первые l символов
 совпадают */
  if(strncmp(str,NEWH,strlen(NEWH))== 0)
  {
   fclose(fp);
   nfile++;
/* Это просто информационное сообщение */
   fprintf(stderr,
        "Начало части %d0,nfile);
   fp = of(av[2],nfile,av[3]);
   }
  puts(str);
  if(ferror(stdout)) {
    fprintf(stderr,
    "Ош записи в файл номер %.2d0,nfile);
    exit(4);
   }
 }
 exit (0);
}

/* Эта функция создает имя файла
 из трех частей и открывает его
 как стандартный вывод */

of(s1,n,s2)
char *s1,*s2;
{
 register FILE *f;
 char buf[100];
/* sprintf возвращает свой первый аргумент
*/
 if(( f = freopen(
  sprintf(buf,"%s%02d.%s",s1,n,s2)
  ,"w",stdout))== NULL)
 {
   fprintf(stderr,
    "Не могу открыть файл:%s0,buf);
   exit(4);
 }
 return;
}






88



                         СОДЕРЖАНИЕ



1.  ВВЕДЕНИЕ...........................................    3

2.  СИНТАКСИЧЕСКАЯ НОТАЦИЯ.............................    5

3.  ЛЕКСИКА ЯЗЫКА 'СИ'.................................    6
    3.1. Комментарии...................................    6
    3.2. Идентификаторы (имена)........................    6
    3.3. Ключевые слова................................    6
    3.4. Константы.....................................    7
    3.4.1. Целые константы.............................    7
    3.4.2. Длинные (long) константы....................    7
    3.4.3. Символьные константы........................    7
    3.4.4. Вещественные константы......................    8
    3.5. Строки........................................    8
    3.6. Характеристики аппаратных средств.............    9

4.  ОБ'ЕКТЫ ЯЗЫКА 'СИ'.................................   10
    4.1. Интерпретация идентификаторов.................   10
    4.2. Об'екты и l_значения..........................   11
    4.3. Преобразования................................   11
    4.3.1. Символы и целые.............................   12
    4.3.2. Типы float и double - вещественной и двойной
           точности....................................   12
    4.3.3. Вещественные и целочисленные величины.......   12
    4.3.4. Указатели и целые...........................   13
    4.3.5. Целое без знака.............................   13
    4.3.6. Арифметические преобразования...............   13

5.  ВЫРАЖЕНИЯ..........................................   14
    5.1. Первичные выражения...........................   14
    5.2. Унарные операции..............................   16
    5.3. Мультипликативные операции....................   18
    5.4. Аддитивные операции...........................   18
    5.5. Операции сдвига...............................   19
    5.6. Операции отношения............................   19
    5.7. Операции равенства............................   20
    5.8. Побитовая операция 'и'........................   20
    5.9. Побитовая операция исключающего 'или'.........   20
    5.10.Побитовая операция включающего 'или'..........   20
    5.11.Логическая операция 'и'.......................   21
    5.12.Операция логического 'или'....................   21
    5.13.Условная операция.............................   21
    5.14.Операция присваивания.........................   22
    5.15.Присваивание структуры........................   22
    5.16.Операция 'запятая'............................   23
    5.17.Старшинство и порядок вычисления..............   23

6.  ОПИСАНИЯ...........................................   25
    6.1. Спецификаторы класса памяти...................   25
    6.2. Спецификаторы типа............................   26
    6.3. Описатели.....................................   26
    6.4. Смысл описателей..............................   27
    6.5. Описание структур и об'единений...............   29
    6.6. Перечислимый тип..............................   31
    6.7. Инициализация.................................   32
    6.8. Имена типов...................................   34


                                                          89

    6.9. Описатель typedef.............................   35

7.  ОПЕРАТОРЫ..........................................   36
    7.1. Операторное выражение.........................   36
    7.2. Составной оператор (или блок).................   36
    7.3. Условные операторы............................   37
    7.4. Оператор while................................   37
    7.5. Оператор do...................................   37
    7.6. Оператор for..................................   37
    7.7. Оператор switch...............................   38
    7.8. Оператор break................................   39
    7.9. Оператор continue.............................   39
    7.10.Оператор возврата.............................   39
    7.11.Оператор goto.................................   40
    7.12.Помеченный оператор...........................   40
    7.13.Пустой оператор...............................   40

8.  ВНЕШНИЕ ОПРЕДЕЛЕНИЯ................................   41
    8.1. Внешнее определение функции...................   41
    8.2. Внешние определения данных....................   42

9.  ОБЛАСТЬ ДЕЙСТВИЯ ИДЕНТИФИКАТОРОВ...................   43
    9.1. Лексическая область действия..................   43
    9.2. Область действия внешних идентификаторов......   44
    9.3. Неявные описания..............................   44

10. ПРЕПРОЦЕССОР ЯЗЫКА 'СИ'............................   46
    10.1.Замена лексем.................................   46
    10.2.Включение файлов..............................   47
    10.3.Условная компиляция...........................   47
    10.4.Команда #line.................................   48

11. ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ О ТИПАХ..................   49
    11.1.Структуры и об'единения.......................   49
    11.2.Функции.......................................   49
    11.3.Массивы, указатели и индексация...............   50
    11.4.Явные преобразования указателей...............   51

12. КОНСТАНТНЫЕ ВЫРАЖЕНИЯ..............................   52

13. СООБРАЖЕНИЯ О ПЕРЕНОСИМОСТИ........................   53
    13.1.Анахронизмы...................................   54

14. СТАНДАРТНАЯ БИБЛИОТЕКА ВВОДА И ВЫВОДА..............   55
    14.1.Обращение к стандартной библиотеке............   55
    14.2.Стандартный ввод и вывод - функции  getchar  и
         putchar.......................................   55
    14.3.Форматный вывод - функция printf..............   56
    14.4.Форматный ввод - функция scanf................   58
    14.5.Форматное преобразование в памяти.............   61
    14.6.Доступ к файлам...............................   61
    14.7.Обработка ошибок - stderr  и  exit............   63
    14.8.Ввод и вывод строк............................   64
    14.9.Функция ungetc................................   64
    14.10.Разные стандартные функции...................   65
    14.10.1.Управление памятью.........................   65
    14.10.2.Стандартные функции языка Си...............   65

15. ВЗАИМОДЕЙСТВИЕ С ОПЕРАЦИОННОЙ СИСТЕМОЙ.............   67
    15.1.Подготовка программ на 'Си' в ОС ДЕМОС........   67
    15.2.Доступ к аргументам команды...................   68



90

16. ИНТЕРФЕЙС СИСТЕМЫ ДЕМОС............................   70
    16.1.Ввод/вывод....................................   70
    16.1.1.Дескрипторы файлов..........................   70
    16.1.2.Низкоуровневый ввод/вывод - операторы read и
           write.......................................   71
    16.1.3.Открытие,  создание,  закрытие  и   удаление
           (unlink)....................................   72
    16.1.4.Произвольный доступ - lseek.................   73
    16.2.Управление процессами.........................   74
    16.2.1.Функция 'system'............................   74
    16.2.2.Вызов программы на низком уровне - execl....   74
    16.2.3.Порождение нового процесса - fork...........   75
    16.2.4.Канал межпроцессной связи...................   76
    16.3.Сигналы и прерывания..........................   77

ЛИТЕРАТУРА.............................................   80

ПРИЛОЖЕНИЕ 1.  Сводка синтаксических правил............   81
    1.1. Выражения.....................................   81
    1.2. Описания......................................   82
    1.3. Операторы.....................................   84
    1.4. Внешние определения...........................   85
    1.5. Препроцессор..................................   85

ПРИЛОЖЕНИЕ 2.  Примеры программ на Си..................   87







































                                                          91

