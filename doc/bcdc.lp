
            дддд   ееееее   м     м    oooo     сссс
           д   д   е        мм   мм   o    o   с    с
          д    д   е        м м м м   o    o   с    с
          д    д   еееее    м  м  м   o    o   с
          д    д   е        м     м   o    o   с
          д    д   е        м     м   o    o   с    с
         дддддддд  ееееее   м     м    oooo     сссс



          демосдемосдемосдемосдемосдемосдемосдемосде
          емосдемосдемосдемосдемосдемосдемосдемосдем
          мо                                      мо
          ос                                      ос
          сд        ОПЕРАЦИОННАЯ СИСТЕМА          сд
          де                                      де
          ем               ДЕМОС                  ем
          мо                                      мо
          ос                                      ос
          сд                                      сд
          де             Версия 1.0               де
          ем                                      ем
          мо                                      мо
          сдемосдемосдемосдемосдемосдемосдемосдемосд
          демосдемосдемосдемосдемосдемосдемосдемосде







                 ПРОГРАММЫ ДЛЯ ВЫЧИСЛЕНИЙ С
              ПРОИЗВОЛЬНОЙ ТОЧНОСТЬЮ - BC И DC






                Школьников Юрий Владимирович












                       МОСКВА - 1985









                                                           1













   Данный документ содержит описание программы  BC,  которая
позволяет производить арифметические вычисления с произволь-
ной точностью над числами произвольной  величины.  Программа
BC  содержит  также  некоторые языковые возможности. Имеются
средства для перевода чисел из  одной  системы  счисления  в
другую.

   В данном документе содержится  также  описание  программы
DC,  которая также позволяет производить арифметические дей-
ствия с числами произвольной величины и  точности,  а  также
другие  возможности,  предоставляемые программой BC. Отличие
состоит в том, что программа DC работает, используя обратную
польскую запись.










































     ВВЕДЕНИЕ

BC - это язык и компилирующая программа для выполнения ариф-
метических  операций  с произвольной точностью на ЭВМ СМ-4 в
операционной системе ДЕМОС.

   Язык имеет завершенную структуру управления, режим немед-
ленного  выполнения операций. Могут быть определены и сохра-
нены функции для последующего их выполнения.

   Имеется свойство масштабирования, которое  позволяет  ис-
пользовать  запись  с десятичной точкой, а также возможность
для ввода и вывода чисел в системах счисления,  отличных  от
десятичной. Числа могут быть переведены из десятичной систе-
мы счисления, например, в восьмеричную просто установкой вы-
ходного основания системы счисления в 8.

   Доступен небольшой набор библиотечных функций, таких  как
sin,  cos, arctan, log, exp и функции Бесселя целочисленного
порядка.

   BC рекомендуется применять, когда необходимо  осуществить
вычисления  с  большими целыми числами, с очень высокой точ-
ностью и когда необходимы преобразования чисел из одной сис-
темы счисления в другую.

   Фактический предел количества цифр,  которые  могут  быть
обработаны,  зависит  от об'ема памяти, доступной на машине.
Манипуляции с числами с более чем сотней цифр возможны  даже
на минимальных версиях ОС ДЕМОС.

   Два числа, состоящие из пяти сотен цифр могут быть перем-
ножены, и результат, состоящий из числа из тысячи цифр будет
получен примерно через пятнадцать секунд.

   Синтаксис языка BC в значительной мере похож на синтаксис
языка Си. Те, кто знаком с языком Си легко освоят язык BC.

   DC - это арифметический пакет также для вычислений с про-
извольной точностью. Он работает по принципу стекового каль-
кулятора, используя обратную польскую запись. Обычно DC опе-
рирует с целыми десятичными числами, но он также может рабо-
тать с числами в системах счисления отличных от  десятичной,
а также с числами с дробной частью.

   Компилятор BC воспринимает программы, написанные на языке
BC  и компилирует вывод, который интерпретируется программой
DC. Некоторые из команд, о которых рассказывается в описании
DC, были разработаны для взаимодействия компиляторов и труд-
ны для восприятия и работы человеком.

   Числа, которые вводятся в DC, помещаются в стек.  Команды
DC работают, производя действия над двумя верхними числами в
стеке и помещают результат обратно в стек.

   Если в командной строке ОС ДЕМОС указан аргумент, который
является  именем файла, то сначала считывается этот файл или
файлы, а затем ввод переключается на стандартный (клавиатуру
терминнала).





                                                           3

              1. ИНТЕРАКТИВНЫЙ КАЛЬКУЛЯТОР BC



   1.1. Простые действия с целыми числами


   Простейшим типом выражения является арифметическое  выра-
жение в самой строке. Например, если вы введете строку:


      123456789+987654321

программа почти мгновенно выдает ответ:

      1111111110


   Могут использоваться следующие операции +, -, *, /, %,  и
^, которые означают действия сложения, вычитания, умножения,
деления, определения остатка и возведения  в  степень  соот-
ветственно.  Результатом  деления целых чисел является целое
число без дробной части. При делении на ноль появляется  со-
общение об ошибке.

   Перед любым членом выражения может стоять знак минус, ко-
торыйуказывает на то, что данный член отрицателен ("унарный"
знак минус). Выражение:

      1985+-68

означает, что число -68 должно быть добавлено к числу 1985.

   Более сложные выражения с несколькими операциями и  скоб-
ками  интерпретируются  также  как  и в Фортране. Операция ^
(возведение в степень) имеет наибольший  приоритет  выполне-
ния, затем следуют операции * (умножение), % (нахождение ос-
татка), / (деление) и наконец, операции  +  (сложение)  и  -
(вычитание). В первую очередь оценивается содержимое выраже-
ний, стоящих в скобках.  Возведение  в  степень  выполняется
справа налево, а остальные операции слева направо. Следующие
два выражения:

      a^b^c и a^(b^c)

эквивалентны, также как эквивалентны и выражения:

      a*b*c и (a*b)*c


   Для запоминания чисел  используются  внутренние  регистры
(переменные), которые имеют имена, состоящие из одной строч-
ной латинской буквы. Регистру может  быть  обычным  способом
присвоено значение выражения. Выражение:

      s=s+10

выполняет увеличение на 10  значения,  содержащегося  в  ре-
гистре  с именем s. Если, как и в данном случае, самым внеш-
ним является оператор =, то осуществляется присваивание,  но
результат  не  печатается. Разрешается использовать не более
26 регистров.


4


   Имеется встроенная функция извлечения  квадратного  корня
(sqrt),  причем  дробная часть результата отбрасывается (вы-
числения с большей точностью описаны в разделе  "Масштабиро-
вание"). Если ввести следующие строки

      q=sqrt(624)
      q

то напечатается результат

      24



   1.2. Основания систем счисления


   Существуют специальные внутренние переменные,  называемые
"ibase"  и  "obase". Содержимое "ibase", первоначально уста-
новленное в 10, определяет основание системы счисления,  ис-
пользуемое для вводимых чисел. Например, в результате выпол-
нения следующих строк:

      ibase=9
      11

появится выходная строка:

      10

и, установив таким образом основание системы счисления  вво-
димых  чисел в 9, можно будет осуществлять преобразования из
девятиричной  системы  в  десятичную.  Заметим,  что  нельзя
вернуть обратно входное основание в десятичное, набрав стро-
ку

      ibase=10

так как число 10 будет интерпретироваться как  девятиричное,
и входное основание останется без изменения.

   Чтобы работать в шестнадцатиричной системе счисления, ис-
пользуются  символы  A-F  для  обозначения цифр 10-15, соот-
ветственно. Использование символов  A-F  разрешается  в  ка-
честве чисел независимо от того, какая система счисления ус-
тановлена в данный момент.

   Выражение

      ibase=A

изменит на десятичное входное основание, независимо от того,
каким  было текущее основание. Ввод произвольных чисел в ос-
нованиях меньше единицы и больше шестнадцати не  поддержива-
ется.

   Содержимое "obase" первоначально установленное в 10,  ис-
пользуется,  как  основание для выводимых чисел. Так, напри-
мер, введя строки

      obase=16


                                                           5

      654321

получим в результате

      9FBF1

что является, как мы и хотели, пятизначным шестнадцатиричным
числом.  Очень  большие  выходные основания допустимы, и они
иногда бывают полезны. Например, большие  числа  могут  быть
выведены  в  группах по три цифры, если установить "obase" в
1000. Например, если ввести следующие строки

   obase=1000
   1234567890987654321234567890

то результат напечатется в виде

   1 234 567 890 987 654 321 234 567 890

Необычные (т.е. 1,  0  или  отрицательные)  основания  также
воспринимаются.

   Очень большие числа расщепляются при выводе на печать  по
70  символов  на  строку.  Строки, не являющиеся последними,
оканчиваются символом "\".  Десятичный  результат  выводится
практически  мгновенно,  но  вывод очень больших чисел (т.е.
более чем 100 цифр) с другими основаниями происходит доволь-
но  медленно. Вывод в недесятичных основаниях осуществляется
примерно со скоростью 100 цифр за шесть секунд.

   Рекомендуем запомнить, что на процесс внутренних вычисле-
ний "ibase" и "obase" не влияют, так как вычисления выполня-
ются в десятичной системе счисления, а "ibase" и "obase" ис-
пользуются только во время перевода в нужную систему счисле-
ния при вводе и выводе, соответственно.


   1.3. Масштабирование


   Еще одна специальная  внутренняя  переменная,  называемая
"scale"  используется  для того, чтобы определить количество
знаков после запятой при вычислениях. Числа могут  содержать
до  99  десятичных цифр после запятой. Это количество знаков
сохраняется в дальнейших вычислениях до  тех  пор,  пока  не
будет изменено.

   Когда над двумя  масштабированными  числами  производится
одно  из  арифметических действий, результат имеет точность,
определяемую следующими правилами. Для сложения и  вычитания
точность  результата - большая из точности операндов. В этом
случае  результат  никогда  не  усекается.   Для   умножения
точность  результата никогда не меньше, чем максимум точнос-
тей двух операндов, и не больше, чем сумма точностей операн-
дов.  Точность частного равна значению внутренней переменной
"scale". Точность остатка есть сумма  точностей  частного  и
делителя.  Результат возведения в степень масштабируется так
же, как и при  умножении.  Показатель  степени  должен  быть
целым. Точность квадратного корня устанавливается максималь-
ной из точности аргумента и "scale".




6

   Все внутренние действия фактически выполняются в целых  с
отбрасыванием  цифр,  если  необходимо. В каждом случае, где
отбрасываются цифры, производится усечение, а не округление.

   Содержимое "scale" должно быть не больше 99 и  не  меньше
нуля. Первоначально она устанавливается в 0. В случае, когда
требуется более 99 дробных цифр, вы можете приспособить свое
собственное масштабирование.

   Внутренние переменные "scale", "ibase", "obase" могут ис-
пользовться  в  выражениях  также  как  и другие переменные.
Строка

      scale=scale+1

увеличивает значение "scale" на единицу а строка

      scale

вызывает печать значения "scale".

   При вычислениях значение "scale" используется, как  коли-
чество десятичных цифр, даже если "ibase" и "obase" не равны
10. Напомним еще раз, что внутренние вычисления производятся
в  десятичной  системе счисления, а перевод в нужную систему
счисления осуществляется при вводе и выводе числа.


   1.4. Функции


   Имя функции также состоит  из  одной  строчной  латинской
буквы.  Разрешается, чтобы имена функций и переменных совпа-
дали. Можно иметь двадцать шесть  различных  функций  также,
как и двадцать шесть различных переменных. Строка

      define a(x){

начинает определение функции с  одним  аргументом.  За  этой
строкой должны следовать одно или более предложений, которые
составляют  тело  функции,  оканчивающееся  правой  фигурной
скобкой  "}". Возврат из функции осуществляется тогда, когда
выполняется оператор return или достигается  конец  функции.
Оператор return может быть в одной из двух форм

      return
      return(x)

В первом случае значением функции является ноль, а во втором
значение выражения в скобках.

   Переменные,используемые в функциях, могут быть об'явлены,
как автоматические, используя выражение типа

      auto x,y,z

В функции может быть только одно  выражение  "auto",  и  оно
должно  быть первым в определении. Автоматические переменные
размещаются в памяти и инициализируются в ноль при  входе  в
функцию и сбрасываются при выходе из нее. Значения любых пе-
ременных с именами,  совпадающими  с  именами  переменных  в
функции, не портятся, так как переменные в функциях являются


                                                           7

локальными. Функции могут быть вызваны рекурсивно, и автома-
тические  переменные на каждом уровне вызова защищены. Имена
параметров в определении функции обрабатываются таким же об-
разом, что и автоматические переменные с единственным исклю-
чением, что им присваиваются конкретные значения при входе в
функцию. Пример определения функции:

      define f(x,y){
          auto z
          z=x*y
          return(z)
      }

Значение этой функции, когда она будет вызвана получится  из
произведения двух ее аргументов.

   Функция вызывается при появлении  ее  имени,  за  которым
следуют  аргументы, заключенные в скобки и разделенные запя-
тыми. Если использовалось неверное число аргументов, то  ре-
зультат непредсказуем.

   Функции без аргументов определяются и вызываются, исполь-
зуя пустые скобки: р().

   Если набрать строку

      f(3.14159,2,71828)

где f - функция, которая была описана выше, то  напечатается
результат:

      8.53972

а если набрать

      y=f(f(12,34),56)

то переменной "y" присвоится значение 22848.


   1.5. Индексированные переменные


   Имя переменной, состоящее  из  одной  строчной  латинской
буквы,за которым следует выражение, заключенное в квадратные
скобки, называется индексированной переменной (элемент  мас-
сива). Имя переменной называется именем массива, а выражение
в квадратных скобках называется индексом. Допускаются только
одномерные массивы. Имена массивов могут пересекаться с име-
нами простых переменных и именами функций. Если  у  значения
индекса  имеется  дробная  часть, то она отбрасывается перед
использованием. Индекс должен быть больше либо равен нулю  и
меньше либо равен 2047.

   Индексированные переменные могут свободно  использоваться
в выражениях, в вызовах функций и в операторах return.

   Имя массива может использоваться, как  аргумент  функции,
или  может  быть  описано,  как  автоматическое  в  описании
функции, используя пустые квадратные скобки:

      p(c[])


8

      define p(c[])
      auto c[]


   Когда имя массива используется таким образом,  копируется
все содержимое массива для использования в функции и выдает-
ся весь массив при выходе из  функции.  Для  указания  всего
массива в целом можно пользоваться только такими способами.


   1.6. Управляющие операторы


   Операторы "if", "while" и "for" могут использоваться  для
того, чтобы изменять порядок выполнения действий в программе
или вызвать повторение  выполнения  определенных  последова-
тельностей.  Тело  каждого из этих операторов - это оператор
или составной оператор, состоящий из нескольких  операторов,
заключенных  в  фигурные скобки. Они пишутся следующим обра-
зом:

  if(условие) оператор
  while(условие) оператор
  for(выраж1;условие;выраж2) оператор

или

  if(условие) {операторы}
  while(условие) {операторы}
  for(выраж1;условие;выраж2) {операторы}


   Условие в любом из управляющих операторов - это выражение
в форме

      m>n

где два выражения связаны одной из шести операций отношения:
<,  >,  <=,  >=,  ==  или !=. Отношение == означает "эквива-
лентно", а отношение != означает "не эквивалентно". Значение
остальных операций отношения ясно и так.

   Будьте внимательны при использовании операций "=" и "==",
так  как  некорректное  использование  одной операции вместо
другой не может быть выявлено компилятором, а при  использо-
вании  первой  произойдет  присваивание, а при использовании
второй - сравнение.

   Оператор "if" вызовет  выполнение  своего  тела  тогда  и
только  тогда, когда условие истинно. Затем управление пере-
дастся следующему оператору в последовательности.

   Оператор "while" вызовет многократное  выполнение  своего
тела  до  тех пор, пока условие истинно. Условие проверяется
перед каждым выполнением тела, и, если условие ложно, управ-
ление  передается  оператору,  следующему за телом оператора
while.

   Оператор "for" начинается с  выполнения  "выраж1".  Затем
проверяется условие, и, если оно истинно, выполняются опера-
торы в теле оператора  "for".  Затем  выполняется  "выраж2".
Проверяется условие и так далее. Типичное использование опе-


                                                           9

ратора "for" - это управляемое повторение, такое,  например,
как в операторе

      for(i=1;i<=20;i=i+2)i

который будет печатаь целые нечетные числа в интервале от  1
до  20.  Далее представлены несколько примеров использования
управляющих операторов.

   define f(n){
       auto i, p
       p=1
       for(i=1;i<=n;i=i+1) p=p*i
       return(p)
   }

Тогда, набрав строку

   f(h)

получим печать значения факториала числа h, если h целое по-
ложительное. А это определение функции, которая будет вычис-
лять значения  биномиальных  коэффициентов  (предполагается,
что s и t - целые положительные).

   define b(s,t){
       auto i, p
       p=1
       for(i=1;i<=t;i=i+1) p=p*(s-i+1)/i
       return(p)
   }

Следующая  функция   вычисляет   значение   экспоненциальной
функции  суммированием  соответствующего  ряда,  не учитывая
возможные ошибки отбрасывания:

   scale=25
   define e(z){
       auto a, b, c, d, n
       a=1
       b=1
       c=1
       d=0
       n=1
       while(1==1){
           a=a*z
           b=b*n
           c=c+a/b
           n=n+1
           if(c==d) return(c)
           d=c
       }
   }



   1.7. Некоторые детали


   Существуют некоторые языковые особенности, о которых зна-
ет каждый пользователь, даже, если он не пользовался ими.



10

   Обычно операторы набираются по одному на строке. Позволя-
ется также набирать несколько операторов на строке, разделяя
их точкой с запятой (;).

   Если оператор присваивания  заключен  в  круглые  скобки,
тогда его значение можно использовать, там же, где можно ис-
пользовать выражение. Например, если набрать следующую стро-
ку

      (y=y+123)

то произойдет не только указанное присваивание, но и напеча-
тается результирующее значение.

   А это пример использования значения оператора  присваива-
ния, когда он не заключен в круглые скобки:

      p=n[k=k*3]

В этом случае значение "n" будет присвоено переменной "p", а
также  "k"  будет  увеличено  в  три раза перед тем, как "k"
будет использовано как индекс.

   Следующие конструкции работают в BC так же, как  они  вы-
полняются  в языке Си. Подробнее указано в "Детальном описа-
нии" или в руководстве по языку Си.

      x=y=z   то же, что и  x=(y=z)
      x=+y                  x=x+y
      x=-y                  x=x-y
      x=*y                  x=x*y
      x=/y                  x=x/y
      x=%y                  x=x%y
      x=^y                  x=x^y
      x++                   (x=x+1)-1
      x--                   (x=x-1)-1
      ++x                   x=x+1
      --x                   x=x-1


   ПРЕДУПРЕЖДЕНИЕ!  В  некоторых  из  этих  конструкций  су-
щественно наличие или отсутствие пробелов. Существует разли-
чие между a=-b и a= -b. В первом случае переменной "a" будет
присвоено значение "a-b", а во втором "-b".


   1.8. Три важные вещи


1.  Чтобы выйти из программы BC наберите "quit".

2.  Имеется возможность вводить комментарий, так же, как и в
    языках  Си и ПЛ/1. Комментарий начинается с "/*" и окан-
    чивается "*/".

3.  Имеется библиотека функций, которая может быть использо-
    вана, если набрать при вызове команды BC

          bc -l

Эта команда вызовет загрузку небольшгого набора библиотечных
функций,  который  содержит:  синус (назвается "s"), косинус


                                                          11

("c"), арктангенс ("a"), натуральный логарифм ("l"),  экспо-
ненту  ("e")  и  функцию  Бесселя целого порядка ("j(n,x)").
Несомненно, что будут написаны и другие функции. Эта  библи-
отека  устанавливает  точность, равную 20 знакам после запя-
той. Вы можете переустановить ее, если вам надо.

   Bсли вы наберете

      bc файл ...

то BC прочитает и выполнит указанный файл  или  файлы  перед
тем, как передать управление на клавиатуру. Таким образом вы
можете  загрузить  свои  любимиые  программы  и  определения
функций. Использование личных файлов не исключает возможнос-
ти использования библиотечных функций.


   1.9. Детальное описание


1. Обозначения

   На следующих страницах синтаксические категории обознача-
ются  строчными русскими буквами в кавычках (например "выра-
жение"); ключевые слова  -  строчными  латинскими  (например
scale);  то, что находится в квадратных скобках является не-
обязательным.

2. Знаки

   Знаки  состоят   из   ключевых   слов,   идентификаторов,
констант,  операторов  и  разделителей.  Разделителем знаков
могут  быть  пробелы,  символы  табуляции  или  комментарии.
Символ  новой строки или точка с запятой разделяют предложе-
ния.

2.1. Комментарии

   Комментарии начинаются символами /* и кончаются символами
*/.

2.2. Идентификаторы

   Имеется три вида идентификаторов - обычные  идентификато-
ры,  идентификаторы  массивов  и идентификаторы функций. Все
три типа имеют имена, состоящие из единственной строчной ла-
тинской буквы. После идентификатора массива следуют квадрат-
ные скобки, возможно заключающие выражение, определяющее ин-
декс. Массивы одномерны и могут содержать до 2048 элементов.
Индексирование начинается с нуля, поэтому массив может иметь
индексы от 0 до 2047. Значения индексов усекаются до целого.
За идентификатором функции следуют круглые скобки,  возможно
содержащие  аргументы.  Имена  трех типов идентификаторов не
пересекаются: программа может иметь переменную z, массив z и
функцию z.

2.3. Ключевые слова

   Следующие  слова  являются  зарезервированными  ключевыми
словами

      ibase       if


12

      obase       break
      scale       define
      sqrt        auto
      length      return
      while       quit
      for


2.4. Константы

   Константы состоят из произвольной длины чисел с  необяза-
тельной десятичной точкой. Допускаются также шестнадцатирич-
ные цифры A-F, которые имеют значения 10-15, соответственно.

3. Выражения

   Значение выражения печатается, если основной оператор  не
оператор  присваивания. Старшинство операторов такое же, как
и порядок появления при описании далее в  документе,  с  на-
ивысшим приоритетом у того, кто появляется первым.

3.1. Простые выражения

3.1.1. Именованные выражения

   Именованные выражения -  это  выражения,  которые  хранят
какое-либо  значение.  Проще говоря, именованные выражения -
левая часть оператора  присваивания.  Значение  именованного
выражения - это значение, хранимое в именованном месте.

3.1.1.1. "идентификаторы"

   Простые идентификаторы - это именованные  выражения.  Они
имеют начальное нулевое значение.

3.1.1.2. "имя-массива"["выражение"]

   Элементы массива - это именованные выражения.  Они  имеют
начальное нулевое значение.

3.1.1.3. scale, ibase и obase

   Внутренние регистры scale, ibase и obase - это  именован-
ные выражения. scale  - это количество цифр после десятичной
точки,  которое  используется  в  арифметических  действиях.
scale  имеет начальное нулевое значение. ibase и obase - это
основания систем счисления вводимых и выводимых чисел, соот-
ветственно.  Как ibase, так и obase имеют начальное значение
10.

3.1.2. Вызовы функций

3.1.2.1. "имя-функ."(["выр."[,"выр."...]])

   Вызов функции состоит из имени функции, за которым следу-
ют  круглые  скобки,  содержащие разделенный запятыми список
выражений, которые являются аргументами функции. Допускается
использовать,  как аргумент, весь массив, если при его опре-
делении за именем следуют пустые квадратные скобки. Все  ар-
гументы  функции  передаются по значению, поэтому изменения,
производимые над формальными параметрами, не  имеют  воздей-
ствия  на  фактические. Если функция прерывается выполнением


                                                          13

оператора return, то значение функции - это значение выраже-
ния  в скобках оператора return или нуль, если выражение от-
сутствует или нет оператора return.

3.1.2.2. sqrt("выражение")

   Результатом  является  квадратный  корень  из  выражения.
Результат  усекается до последней значащей десятичной цифры.
Точностью результата является большая величина  из  точности
выражения или scale.

3.1.2.3. length("выражение")

   Результатом является общее число десятичных цифр в  выра-
жении. Точность результата - ноль знаков после запятой.

3.1.2.4. scale("выражение")

   Результатом является точность выражения. Точность резуль-
тата - ноль знаков после запятой.

3.1.3. Константы

   Констатнты - это простые выражения.

3.1.4. Круглые скобки

   Выражение, окруженное круглыми скобками  -  есть  простое
выражение.  Скобки  используются  для  того,  чтобы изменить
обычный порядок дествий.

3.2. Унарные операции

   Унарные операции выполняются справа налево.

3.2.1. -"выражение"

   Результатом является выражение с противоположным знаком

3.2.2. ++"именованное выражение"

   Именованное выражение увеличивается на единицу. Результа-
том  является значение именованного выражения после увеличе-
ния.

3.2.3. --"именованное выражение"

   Именованное выражение уменьшается на единицу. Результатом
является значение именованного выражения после уменьшения.

3.2.4. "именованное выражение"++

   Именованное выражение увеличивается на единицу. Результа-
том  является значение именованного выражения перед увеличе-
нием.

3.2.5. "именованное выражение"--

   Именованное выражение уменьшается на единицу. Результатом
является значение именованного выражения перед уменьшением.




14

3.3. Операция возведения в степень

   Операция возведения в степень выполняется справа налево.

3.3.1. "выражение"^"выражение"

   Результатом является первое выражение, возведенное в сте-
пень  второго выражения. Второе выражение должно быть целым.
Если "a" - это точность левого выражения, а "b" - абсолютное
значение правого выражения (показателя степени), то точность
результата вычисляется по формуле

      min(a*b,max(scale,a))


3.4. Операции группы умножения

   Операции *, /, % выолняются слева направо.

3.4.1. "выражение"*"выражение"

   Результатом является произведение  двух  выражений.  Если
"a" и "b" - точности обоих выражений, то точность результата
вычисляется по формуле

      min(a+b,max(scale,a,b))


3.4.2. "выражение"/"выражение"

   Результатом является частное от деления  двух  выражений.
Точность результата - значение scale.

3.4.3. "выражение"%"выражение"

   Операция % вырабатывает остаток от деления  двух  выраже-
ний.  Более  точно, a%b - это a-a/b*b. Точность результата -
это сумма точности делителя и значения scale.

3.5. Операции группы сложения

   Операции группы сложения выполняются слева направо.

3.5.1. "выражение"+"выражение"

   Результатом является сумма двух выражений.  Точность  ре-
зультата - это максимальная из точностей обоих выражений.

3.5.2. "выражение"-"выражение"

   Результатом является разность  двух  выражений.  Точность
результата - это максимальная из точностей обоих выражений.

3.6. Операторы присваивания

   Операторы присваивания выполняются справа налево.

3.6.1. "именованное выражение"="выражение"

   Это выражение присваивает значение выражения справа  име-
нованному выражению слева.



                                                          15

3.6.2. "именованное выражение"=+"выражение"

3.6.3. "именованное выражение"=-"выражение"

3.6.4. "именованное выражение"=*"выражение"

3.6.5. "именованное выражение"=/"выражение"

3.6.6. "именованное выражение"=%"выражение"

3.6.7. "именованное выражение"=^"выражение"

   Результат указанных выше выражений эквивалентен

  "именов. выр."="именов. выр."ОП"выр."

где ОП - знак операции после знака =.

4. Отношения

   В отличие от других операций, операции отношения допусти-
мы только, как об'екты операторов if, while или внутри  опе-
ратора for.

4.1. "выражение"<"выражение"

4.2. "выражение">"выражение"

4.3. "выражение"<="выражение"

4.4. "выражение">="выражение"

4.5. "выражение"=="выражение"

4.6. "выражение"!="выражение"


5. Классы памяти

   В BC имеется только два класса памяти - глобальный и  ав-
томатический  (локальный). Командой auto требуется описывать
только те идентификаторы, которые  являются  локальными  для
функций.  Аргументы функций являются для них локальными. Все
другие идентификаторы подразумеваются глобальными и доступны
для   всех   функций.   Все  идентификаторы -  глобальные  и
локальные - имеют нулевое начальное значение.  Идентификато-
ры,  описанные  как  auto,  размещаются в памяти при входе в
функцию и освобождаются при выходе из нее. Поэтому,  они  не
сохраняют  свое значение между двумя вызовами функции. Авто-
матические массивы определяются именем массива,  за  которым
следуют пустые квадратные скобки.

6. Операторы

   Операторы должны разделяться точкой с запятой или  симво-
лом  новой строки. Операторы выполняются последовательно, за
исключением тех случаев, где порядок указывается управляющи-
ми операторами.






16

6.1. Операторы выражений

   Когда оператор есть  выражение,  если  главный  (внешний)
оператор выражения не есть оператор присваивания, то печата-
ется значение выражения, а за ним символ новой строки.

6.2. Составные операторы

   Операторы могут быть об'единены вместе, когда они окруже-
ны фигурными скобками {}.

6.3. Строковые операторы, заключенные в кавычки

      "любая строка"

   Этот оператор печатает то, что заключено в кавычки.

6.4. Оператор if

if("условие")"оператор"

   Если условие верно, то выполняется оператор.

6.5. Оператор while

while("условие")"оператор"

   Оператор выполняется до тех пор,  пока  условие  истинно.
Проверка  условия  осуществляется  перед  каждым выполнением
оператора.

6.6. Оператор for

for("выраж.";"условие";"выраж.")"оператор"

   Оператор for выполняет те же действия, что  и  последова-
тельность

      "первое-выражение"
      while("условие"){
            "оператор"
            "последнее-выражение"
      }

   Все три выражения должны обязательно присутствовать.

6.7. Оператор break

break

   break вызвает прерывание выполнения операторов while  или
for

6.8. Оператор auto

auto "идентификатор"[,"идентификатор"]

   Оператор auto вызывает заведение значений идентификаторов
в стеке. Идентификаторы могут быть обычными идентификаторами
или идентификаторами массива. Идентификатор массива  опреде-
ляется  тем, что за именем массива следуют пустые квадратные
скобки. Оператор auto должен быть первым оператором в  опре-


                                                          17

делении функции.

6.9. Оператор define

define(["параметр"[,"параметр"...]]){
      "операторы"}

   Оператор define определяет функцию. Параметры могут  быть
простыми  идентификаторами  или именами массивов. За именами
массивов должны следовать пустые квадратные скобки.

6.10. Оператор return

return

return("выражение")

   Оператор return вызывает окончание работы функции, извле-
чение  из  стека  ее автоматических переменных и определение
результата функции.  Первая  форма  эквивалентна  return(0).
Результатом функции является результат выражения в скобках.

6.11. Окончание работы

   Оператор quit останавливает  выполнение  программы  BC  и
возвращает  управление  системе ДЕМОС в тот момент, когда он
появляется. Оператор quit не может использоваться в  опреде-
лениях функций или в операторах if, for или while.




































18

          2. ИНТЕРАКТИВНЫЙ СТЕКОВЫЙ КАЛЬКУЛЯТОР DC











   2.1. Описание синтаксиса


   В данной главе описываются команды DC, которые предназна-
чены для использования людьми. Дополнительные команды, кото-
рые предназначены для вызова компилятром, описаны в "Деталь-
ном описании".

   На строке допускается любое  количество  команд.  Символы
пробелов  и  новой строки игнорируются, исключая мест внутри
чисел и тех мест, где ожидается имя регистра.

   Воспринимаются следующие конструкции:

число

  Значение числа помещается в стек. Число -  это  непрерыва-
  емая  цепочка цифр 0-9 и больших латинских букв A-F, кото-
  рые  рассматриваются,  как  значения  цифр  10-15,   соот-
  ветственно. Для обозначения отрицательного числа использу-
  ется  знак  подчерк  (_),  который  должен  предшествовать
  числу. Числа могут содержать десятичную точку.

+ - * / % ^

  Верхние два значения стека  складываются  (+),  вычитаются
  (-),  умножаются (*), делятся (/), ищется остаток от деле-
  ния первого на второе (%) или возводятся  в  степень  (^).
  Два  элемента  извлекаются  из стека, результат помещается
  обратно в стек, в его верхушку. Результат деления усекает-
  ся до целого отбрасыванием дробной части. При возведении в
  степень показатель степени должен быть целым. В  детальном
  описании  описывается  как работать с числами с десятичной
  точкой.

sx

  Верхушка основного стека извлекается и запоминается в  ре-
  гистре с именем x, где x может быть любым символом. Если s
  - прописная буква, то x воспринимается, как стек, и значе-
  ние  помещается в него. В имени регистра допускаются любые
  символы, даже пробелы или символы новой строки.

lx

  Значение регистра x заносится в стек. Значение регистра не
  изменяется. Если l - прописная буква, то x воспринимается,
  как стек, и его верхнее значение извлекается и  помещается
  в основной стек.



                                                          19

   Все регистры имеют  начальное  пустое  значение,  которое
воспринимается, как нулевое командой l, и, как ошибочное ко-
мандой L.

d

  Дублируется значение верхушки стека.

p

  Печатается верхнее значение стека. Верхушка  остается  без
  изменений.

f

  Печатаются все значения в стеке и в регистрах.

х

  Верхний элемент стека рассматривается, как цепочка  симво-
  лов,  извлекается  из  стека  и выполняется, как командная
  строка DC.

[...]

  Помещает цепочку символов, заключенную в квадратные скобки
  в верхушку стека.

q

  Выход из программы. Если q встретилось при выполнении  це-
  почки,  то  уровень  рекурсии уменьшается на два. Если q -
  прописная буква, то уровень вложенности стека  уменьшается
  на величину верхушки стека.

<х >х =х !<х !>х !=х

  Извлекаются и сравниваются  два  верхних  элемента  стека.
  Если   установленное  отношение  справедливо,  выполняется
  регистр х, Восклицательный знак означает отрицание.

v

  Заменяется  верхнее  значение  стека  на  его   квадратный
  корень.  Квадратный корень целого числа усекается до цело-
  го. Обработка чисел с десятичной точкой описывается в  де-
  тальном описании.

!

  Оставшаяся часть строки интерпретирутеся, как  команда  ОС
  ДЕМОС.  Управление  возвращается в программу DC, когда ко-
  манда завершится.

c

  Извлекаются все значения стека; стек очищается.

i

  Извлекается верхнее знчение стека, которое  рассматривает-
  ся, как основание системы счисления для последующих вводи-


20

  мых чисел. Если i - прописная буква, то значение основания
  системы счисления вводимых чисел заносится в стек. Основа-
  ния систем счисления меньше единицы и больше 16 не поддер-
  живаются.

o

  Извлекается верхнее значение стека, которое рассматривает-
  ся,  как основание системы счисления для последующих выво-
  димых чисел. Если o - прописная буква, то значение основа-
  ния системы счисления выводимых чисел заносится в стек.

k

  Извлекается верхнее значение стека, и это значение исполь-
  зуется,  как  точность  вычислений, которая является коли-
  чеством цифр после запятой при выполнении умножения, деле-
  ния  и  возведения  в степень. Точность должна быть больше
  либо равна нулю и меньше 100. Если k - прописная буква, то
  значение точности заносится в стек.

z

  Значение глубины стека заносится в стек.

?

  Строка ввода берется из исходного ввода (обычно консоль) и
  выполняется.


   2.2. Детальное описание



   2.2.1. Внутреннее представление чисел


   Числа запоминаются внутри, используя динамический распре-
делитель  памяти. Числа хранятся в форме цепочек цифр в сис-
теме счисления с основанием 100 по одной цифре на байт (сто-
ричная  цифра).  Числа  хранятся в порядке от младших цифр к
старшим. Например, число 1234 имеет  представление  "34 12".
После  любой  арифметической  операции  над числом тщательно
проверяется, чтобы все цифры находились в интервале от 0  до
99  и  не  было  лидирующих нулей. Число ноль представляется
пустой цепочкой.

   Отрицательные числа представлены записью  сторичного  до-
полнения (цифры представлены, как разность между 100 и соот-
ветствующей цифрой), которое аналогично записи двоичного до-
полнения для двоичных чисел. Самая старшая цифра отрицатель-
ного числа всегда -1, а все другие цифры в  интервале  0-99.
Цифра,  предшествующая  самой  старшей  цифре -1, никогда не
может быть 99. Представление числа -157 во внутренней форме:
"43 98 -1".  Мы назовем эту форму канонической формой числа.
Преимуществом этого представления является легкость сложения
отрицательных  чисел.  Когда  сложение  выполняется цифра за
цифрой, результат формально корректен. Результат только тре-
бует модификации, если необходимо, для перевода в каноничес-
кую форму.



                                                          21

   Так как наибольшее допустимое число 99, а в  байте  можно
представлять  вдвое  большие числа, то сложение может выпол-
няться с переносом.

   За самой старшей цифрой хранится дополнительный байт, по-
казывающий  число  допустимых десятичных цифр после запятой.
Представление числа .001: 1,3; число после запятой,  показы-
вает,  что  это число не есть значащая цифра. Значение этого
дополнительного числа называется точностью числа.


   2.2.2. Распределитель памяти


   Длявнутреннего хранения чисел, команд и др. DC использует
динамический  распределитель памяти цепочек. Все считываемые
и записываемые числа  проходят  через  этот  распределитель.
Взаимодействие с каждой цепочкой в распределителе происходит
через четырехсловный заголовок, содержащий указатели на  на-
чало  цепочки, ее конец, следующее место для записи и следу-
ющее место для чтения. Связь между распределителем и DC осу-
ществляется через указатели к этим заголовкам.

   Распределитель первоначально имеет одну большую цепочку в
списке свободных цепочек. Все заголовки, исключая один, ука-
зывающий на эту цепочку, имеются в списке свободных заголов-
ков.  Запросы на цепочки выполняются по размеру. Размер фак-
тически выделяемой цепочки, есть ближайшая следующая степень
двойки.  Когда выполняется запрос на цепочку, распределитель
сперва проверяет свободный список, чтобы  увидеть,  есть  ли
там цепочка нужного размера. Если ничего не найдено, распре-
делитель ищет более длинную цепочку и расщепляет ее  до  тех
пор,  пока  не получится цепочка нужного размера. Оставшаяся
часть цепочки помещается в свободный список. Если не имеется
цепочек большего размера, распределитель пытается об'единить
свободные цепочки меньшего размера в одну большую.  Так  как
все  цепочки  являются результатом расщепления больших цепо-
чек, каждая цепочка имеет соседнюю с ней в  памяти  и,  если
соседняя  цепочка  свободна,  то,  чтобы  увеличить цепочку,
можно требуемую цепочку об'единить с соседней.

   При безуспешной попытке найти  цепочку  подходящей  длины
после об'единения, распределитель запрашивает у системы сво-
бодное  место.  Количество   памяти   в   системе   является
единственным  ограничением  на размер и количество цепочек в
DC.

   В распределителе имеются программы  для  чтения,  записи,
копирования цепочек, сдвига в начало, сдвига вперед на шаг и
сдвига назад на шаг по цепочкам. Все манипуляции с цепочками
выполняются, используя эти программы.

   Программы чтения и записи  увеличивают  указатель  чтения
или  указатель  записи так, что символы цепочки читаются или
пишутся подряд сериями вызовов чтения или записи.  Указатель
записи является, по существу, указателем на конец содержащей
информацию части цепочки и при попытке прочитать информацию,
находящуюся за этим указателем, чтение окажется безуспешным,
а программа чтения в качестве ответа  вернет  признак  конца
цепочки. Попытка записать за конец цепочки вынудит распреде-
литель запросить большее пространство  и  затем  скопировать
старую цепочку в больший блок.


22

   2.2.3. Внутренняя арифметика


   Все арифметические действия выполняются в  целых  числах.
Операнды  (или операнд), требующиеся для выполнения действия
извлекаются  из  главного  стека  и  у   них   отбрасывается
точность,  хранящаяся вместе с числом. Для того, чтобы полу-
чить результат выполнения программ внутренней  арифметики  с
подходящей  точностью,  к  операндам  добавляются  нули  или
отбрасываются лишние цифры. Например, если точность  операн-
дов  различна,  и требуется выравнивание, как это бывает при
сложении, к операнду с меньшей точностью  добавляются  нули.
После  выполнения  требуемой  арифметической  операции перед
тем, как занести результат в стек, в конец числа добавляется
значение его точности

   Регистр, называемый  scale,  используется  в  большинстве
арифметических  операций;  scale определяет количество деся-
тичных цифр в  арифметических  вычислениях.  Значение  scale
может  быть установлено в величину, расположенную в верхушке
стека, с помощью команды "k". Для того, чтобы занести значе-
ние  scale  в  стек,  используется команда "K". scale должно
быть не меньше нуля и меньше 100. При описании каждой  ариф-
метической  операции  будет показано точное влияние scale на
вычисления.


   2.2.4. Сложение и вычитание


   Точности представления двух чисел сравниваются, и к числу
с  меньшей  точностью добавляются последующие нули для того,
чтобы уравнять точости обоих чисел. Если  разница  точностей
нечетна,  то  число  с  меньшей  точностью умножается на 10.
Точность результата устанавливается затем в величину, равную
большей из двух точностей.

   Вычитание производится инвертированием  знака  числа  для
того, чтобы вычитание заменить на сложение.

   Сложение выполняется цифра за цифрой, начиная  с  младших
разрядов  к старшим. Перенос распространяется обычным спосо-
бом. Результирующее число берется в канонической форме,  при
которой  может потребоваться убрать лидирующие нули или, для
отрицательных чисел, заменить старшие цифры "99 -1" на "-1".
В  любом  случае цифры, которые не попадают в интервал 0-99,
должны быть приведены в этот интервал, путем распространения
переноса или заимствования из других разрядов.


   2.2.5. Умножение


   Точности двух операндов запоминаются и отбрасываются. Оба
операнда  делаются положительными. Затем выполняется умноже-
ние способом цифра за цифрой.  Первое  число  умножается  на
каждую цифру второго числа, начиная с младшего разряда. Про-
межуточные результаты накапливаются в частные суммы,  сумми-
рование  которых дает окончательный результат. Результат за-
носится в канонической форме, а  его  знак  определяется  из
знаков операндов.



                                                          23

   Точность результата устанавливается равной сумме  точнос-
тей  двух  операндов. Если эта точность больше, чем значение
внутреннего регистра scale, а  также  больше,  чем  точности
обоих  операндов,  то  точность результата устанавливается в
максимальное из этих трех значений.


   2.2.6. Деление


   Точности обоих операндов отбрасываются. У делимого отбра-
сываются лишние цифры или добавляются недостающие нули, что-
бы сделать точость результата целого деления равной значению
внутренней переменной scale. Знаки запоминаются и отбрасыва-
ются.

   Деление выполняется также, как если  бы  оно  выполнялось
вручную. Вычисляется разница длин обоих чисел. Если делитель
длиннее делимого, возвращается значение  ноль.  В  противном
случае  две  старшие цифры делимого делятся на старшую цифру
делителя. Результат этого действия используется, как  первая
(старшая)  цифра частного. Пробная цифра умножается на дели-
тель, и результат вычитается из делимого,  и  для  получения
очередной  цифры  частного  процесс  повторяется до тех пор,
пока остаток делимого не станет  меньше  делителя.  В  конце
процесса  цифры частного переводятся в каноническую форму и,
если это необходимо,  происходит  распространение  переноса.
Знак определяется из знаков обоих операндов.


   2.2.7. Нахождение остатка


   Для нахождения остатка вызывается  программа  деления,  и
выполняется  деление  так, как это было описано в предыдущем
разделе. Возвращаемый результат - есть  остаток  от  деления
после  завершения процесса деления. Знак остатка имеет такой
же знак, что и делимое. Точность остатка  устанавливается  в
максимальную из величин точности делимого и точности частно-
го плюс точность делителя.


   2.2.8. Вычисление квадратного корня


   Из операнда убирается точность. Если необходимо, дoбавля-
ются  нули  для  того, чтобы получить в результате требуемую
точность.

   Для вычисления используется метод Ньютона  с  последующей
апроксимацией по правилу:

   x[n+1] = 1/2 (x[n] + y / x[n])

Начальное предположение берется из расчета,  что  квадратный
корень равен старшим двум цифрам.








24

   2.2.9. Возведение в степень


   Разрешается возведение в степень только с целым показате-
лем  степени. Если показатель степени равен нулю, то резуль-
тат равен единице. Если показатель степени  отрицателен,  то
он  делается  положительным, а на основание делится единица.
Шкала результата отбрасывается.

   Целый показатель степени  рассматривается,  как  двоичное
число. Основание последовательно возводится в квадрат, а ре-
зультат получается, как произведение результатов этих возве-
дений  основания,  которые соответствуют позициям в двоичном
представлении показателя степени. Чтобы сделать точность ре-
зультата  такой  же,  как  и при умножении (которое на самом
деле и выполнялось),  отбрасывается  необходимое  количество
цифр.


   2.2.10. Перевод вводных чисел и входная система  счис-
           ления


   Числа преобразуются во внутреннее представление  по  мере
их  считывания.  Точность хранится с числом и является коли-
чеством десятичных цифр после запятой. Перед  отрицательными
числами ставится знак "_" (подчерк). Шестнадцатиричные цифры
A-F соответствуют числам 10-15, независимо от входного осно-
вания  системы  счисления.  Для  изменения основания системы
счисления вводимых чисел используется команда "i".  Эта  ко-
манда  извлекает  из  стека, усекает результирующее число до
целого и использует его, как основание системы счисления для
последующего  ввода  чисел.  Первоначально  входная  система
счисления - десятичная. Команда "I" заносит значение основа-
ния системы счисления вводных чисел в стек.


   2.2.11. Выводные команды


   Команда "p" вызывает печать верхушки стека. При этом вер-
хушка стека не извлекается. Для того, чтобы вывести содержи-
мое всех внутренних регистров и  всего  стека,  используется
команда  "f".  Для  того,  чтобы  изменить основание системы
счисления выводных чисел, используется команда "o". По  этой
команде  извлекается  верхушка  стека, усекается до целого и
это значение используется в дальнейшем, как основание систе-
мы  счисления  для выводных чисел. Система счисления для вы-
водных чисел первоначально установлена в десятичную. Команда
"О"  заносит значение основания системы счисления для вывод-
ных чисел в стек.


   2.2.12. Выходной формат и выходная система счисления


   Входная и выходная системы счислений влияют только на ин-
терпретацию  чисел при вводе и выводе, но не влияют на ариф-
метические вычисления. Большие числа выводятся по 70 цифр на
строке.  Если  строка имеет продолжение, то на это указывает
знак "\" (обратная косая черта) в конце строки. Можно  рабо-
тать  с  любыми  системами счисления, хотя не все достаточно


                                                          25

целесообразны. В частности, например, полезна система  счис-
ления с основанием 1000, при которой выводимые числа печата-
ются группами по три цифры. Восьмеричная и шестнадцатиричная
системы  счисления  используются  для  перевода  в и из этих
систем счисления.


   2.2.13. Внутренние регистры


   Числа или цепочки могут быть запомнены во внутренних  ре-
гистрах или загружены в стек из регистров, используя команды
"s" и "l". По команде  "sx"  происходит  извлечение  зачения
верхушки  стека  и запоминание его в регистре "x". "x" может
быть любым символом. По команде "lx" происходит запись  зна-
чения регистра "x" в верхушку стека. Команда "l" не изменяет
содержимое регистра, а команда "s" его изменяет.


   2.2.14. Стековые команды


   Команда "с" чистит стек. Команда "d"  дублирует  число  в
верхушке  стека.  Команда  "z"  заносит  в стек длину стека.
Команда "X" заменяет число в верхушке стека  его  точностью.
Команда "Z" заменяет верхушку стека его длиной.


   2.2.15. Описания и вызовы функций


   Строка из символов в коде КОИ-8, заключенная в квадратные
скобки, заносится в стек. Команда "q" прекращает работу или,
при выполнении по строке, уменьшает уровень  вложенности  на
два.


   2.2.16. Внутренние регистры - программирование на DC


   Для того, чтобы программировать, работая с программой DC,
можно  пользоваться  командами  загрузки и запоминания "l" и
"s", запоминания строк "[]", командой выполнения "х", коман-
дами  проверки  "<",  ">", "=", "!<", "!>", "!=" Команда "х"
рассматривает верхушку стека, как команду программы DC и вы-
полняет ее. Команды проверки сравнивают два верхних элемента
стека, и, если условие справедливо, то  выполняется  регистр
х,  который  следует  за  операцией отношения. Например, для
того, чтобы напечатать числа  0-9,  надо  набрать  следующую
программу:

   [lip1+ si li10>a]sa
   0si lax



   2.2.17. Стековые регистры и массивы


   Следующие команды были разработаны для  использования  не
людьми,  а  компилятором. Они охватывают стековые регистры и
массивы. Кроме стека, с которым работают команды,  DC  имеет


26

также  несколько индивидуальных стеков для каждого регистра.
Эти регистры оперируют с командами "S" и "L".  "Sx"  заносит
верхнее  значение  главного  стека  в стек для регистра "х".
"Lx" извлекает значение из стека регистра "х" и заносит  ре-
зультат  в основной стек. Команды "s" и "l" также работают с
регистрами, но не как со стеками. "l" не  изменяет  верхушку
регистрового  стека,  а "s" разрушает то, что там находилось
ранее.

   К командам для работы с массивами относятся  ":"  и  ";".
":х" извлекает значение стека и использует его, как индекс к
массиву "х". Следующий элемент стека запоминается в элементе
массива  "х" с этим индексом. Индекс должен быть больше нуля
и меньше 2047. ";" - это команда для загрузки основного сте-
ка  из  массива  "х". Значение верхушки стека - это индекс в
массиве "х", откуда должна произойти загрузка.


   2.2.18. Прочие команды


   Команда "!" интерпртирует остаток строки, как команду  ОС
ДЕМОС  и  передает ее системе для выполнения. Другая команда
компилятора - "Q". Эта команда  использует  верхушку  стека,
как число уровней рекурсии, которое надо пропустить.







































                                                          27



                         СОДЕРЖАНИЕ



ВВЕДЕНИЕ...............................................    3

1.  ИНТЕРАКТИВНЫЙ КАЛЬКУЛЯТОР BC.......................    4
    1.1. Простые действия с целыми числами.............    4
    1.2. Основания систем счисления....................    5
    1.3. Масштабирование...............................    6
    1.4. Функции.......................................    7
    1.5. Индексированные переменные....................    8
    1.6. Управляющие операторы.........................    9
    1.7. Некоторые детали..............................   10
    1.8. Три важные вещи...............................   11
    1.9. Детальное описание............................   12

2.  ИНТЕРАКТИВНЫЙ СТЕКОВЫЙ КАЛЬКУЛЯТОР DC..............   19
    2.1. Описание синтаксиса...........................   19
    2.2. Детальное описание............................   21
    2.2.1. Внутреннее представление чисел..............   21
    2.2.2. Распределитель памяти.......................   22
    2.2.3. Внутренняя арифметика.......................   23
    2.2.4. Сложение и вычитание........................   23
    2.2.5. Умножение...................................   23
    2.2.6. Деление.....................................   24
    2.2.7. Нахождение остатка..........................   24
    2.2.8. Вычисление квадратного корня................   24
    2.2.9. Возведение в степень........................   25
    2.2.10.Перевод  вводных  чисел  и  входная  система
           счисления...................................   25
    2.2.11.Выводные команды............................   25
    2.2.12.Выходной формат и выходная  система  счисле-
           ния.........................................   25
    2.2.13.Внутренние регистры.........................   26
    2.2.14.Стековые команды............................   26
    2.2.15.Описания и вызовы функций...................   26
    2.2.16.Внутренние регистры  -  программирование  на
           DC..........................................   26
    2.2.17.Стековые регистры и массивы.................   26
    2.2.18.Прочие команды..............................   27





















28

