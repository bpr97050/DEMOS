head     1.26;
access   ;
symbols  ;
locks    ;
comment  @ * @;


1.26
date     89.03.04.22.46.57;  author avg;  state Exp;
branches ;
next     1.25;

1.25
date     88.09.21.16.26.04;  author avg;  state Exp;
branches ;
next     1.24;

1.24
date     88.05.14.22.17.22;  author avg;  state Exp;
branches ;
next     1.23;

1.23
date     88.05.14.21.07.08;  author avg;  state Exp;
branches ;
next     1.22;

1.22
date     88.05.04.13.33.37;  author avg;  state Exp;
branches ;
next     1.21;

1.21
date     88.01.30.18.32.50;  author avg;  state Exp;
branches ;
next     1.20;

1.20
date     88.01.30.17.23.14;  author avg;  state Exp;
branches ;
next     1.19;

1.19
date     87.02.06.13.57.45;  author avg;  state Exp;
branches ;
next     1.18;

1.18
date     87.01.13.18.48.20;  author avg;  state Exp;
branches ;
next     1.17;

1.17
date     87.01.12.20.42.07;  author alex;  state Exp;
branches ;
next     1.16;

1.16
date     87.01.06.09.54.29;  author avg;  state Exp;
branches ;
next     1.15;

1.15
date     86.11.06.03.12.24;  author alex;  state Exp;
branches ;
next     1.14;

1.14
date     86.10.15.23.29.23;  author root;  state Exp;
branches ;
next     1.13;

1.13
date     86.09.30.04.48.25;  author avg;  state Exp;
branches ;
next     1.12;

1.12
date     86.09.22.21.28.26;  author avg;  state Exp;
branches ;
next     1.11;

1.11
date     86.09.22.21.02.01;  author avg;  state Exp;
branches ;
next     1.10;

1.10
date     86.09.19.20.01.21;  author avg;  state Exp;
branches ;
next     1.9;

1.9
date     86.07.16.20.54.11;  author avg;  state Exp;
branches ;
next     1.8;

1.8
date     86.06.14.21.35.30;  author avg;  state Exp;
branches ;
next     1.7;

1.7
date     86.05.30.17.36.34;  author avg;  state Exp;
branches ;
next     1.6;

1.6
date     86.05.30.13.23.53;  author avg;  state Exp;
branches ;
next     1.5;

1.5
date     86.05.19.15.45.47;  author avg;  state Exp;
branches ;
next     1.4;

1.4
date     86.05.19.15.27.27;  author avg;  state Exp;
branches ;
next     1.3;

1.3
date     86.05.18.21.04.31;  author avg;  state Exp;
branches ;
next     1.2;

1.2
date     86.05.17.22.08.23;  author avg;  state Exp;
branches ;
next     1.1;

1.1
date     86.05.14.22.30.19;  author avg;  state Exp;
branches ;
next     ;


desc
@
Форматирование листа для печати.
@


1.26
log
@Добавлена обработка параметров opt и noopt из lptab-а.
@
text
@/*
 * МНОС РЛ 1.2
 * pr, print    - форматирование файлов для печати
 *
 *      Авторы: Антонов В.Г., Антонова П.Г. (ИПК Минавтопрома, ВМК МГУ)
 *      Последнее изменение: 21.02.86
 *  Версия для ДЕМОС + МНОС 2 : 14.05.86 @@VG
 *  Next changes - see RCS log messages.
 *
 * $Log:        pr.c,v $
 * Revision 1.25  88/09/21  16:26:04  avg
 * Теперь print, pr и т.п. правильно обрабатывают выделения после nroff-а.
 *
 * Revision 1.24  88/05/14  22:17:22  avg
 * Исправлена ошибка в флаге -T.
 *
 * Revision 1.23  88/05/14  21:07:08  avg
 * Исправлена ошибка в -i и
 * добавлен ключ -T (2 строки сверху/2 строки снизу);
 * имя печати теперь будет выбираться также и по environ PRINTER.
 *
 * Revision 1.22  88/05/04  13:33:37  avg
 * Добавлен ключ -i (установка отступа).
 *
 * Revision 1.21  88/01/30  18:32:50  avg
 * Был пропущен endif ONLINE
 *
 * Revision 1.20  88/01/30  17:23:14  avg
 * Сделан режим on-line print (без копирования файла в спулинг).
 *
 * Revision 1.19  87/02/06  13:57:45  avg
 * Исправлена ошибка в -b в КОИ-8.
 *
 * Revision 1.18  87/01/13  18:48:20  avg
 * При пропуске страниц добавлялись лишние строки внизу.
 *
 * Revision 1.17  87/01/12  20:42:07  alex
 * Исправили ширину по умолчанию на 160.
 *
 * Revision 1.16  87/01/06  09:54:29  avg
 * Выделение теперь производится не 4X, а 2Х-кратным выделением.
 *
 * Revision 1.15  86/11/06  03:12:24  alex
 * Ширина по умолчанию сделана 132. Руднев.
 *
 * Revision 1.14  86/10/15  23:29:23  root
 * Изменены умолчания для "print" на -1 +t.
 *
 * Revision 1.13  86/09/30  04:48:25  avg
 * pr зацикливался на DEL (0177).
 * Теперь DEL интерпретируется как обычный символ.
 *
 * Revision 1.12  86/09/22  21:28:26  avg
 * Небольшая правка - тип uname (char) -> (char *).
 *
 * Revision 1.11  86/09/22  21:02:01  avg
 * Добавлена печать имени пользователя в заголовке листа.
 * Кроме того, print теперь работает не под daemon, а под root.
 * В связи с этим добавлена доп> проверка доступа к файлу.
 *
 * Revision 1.10  86/09/19  20:01:21  avg
 * По просьбе DV заменено слово string на line.
 *
 * Revision 1.9  86/07/16  20:54:11  avg
 * Входной файл print (без -m) закрывался даже в том случае,
 * когда он == stdin.
 *
 * Revision 1.8  86/06/14  21:35:30  avg
 * Еще одна правка - ошибка при выдаче номера строки.
 *
 * Revision 1.7  86/05/30  17:36:34  avg
 * Исправлен счет строк в заголовках.
 *
 * Revision 1.6  86/05/30  13:23:53  avg
 * Исправлена ошибка в обработке ключа -c.
 *
 * Revision 1.5  86/05/19  15:45:47  avg
 * Поправлена ошибка и добавлен include <sgtty.h>.
 *
 * Revision 1.4  86/05/19  15:27:27  avg
 * Язык строки в заголовке теперь всегда будет английский,
 * если АЦПУ / линия не имеют флага CYRILL.
 *
 * Revision 1.3  86/05/18  21:04:31  avg
 * Сделаны доделки для работы в print-е.
 *
 * Revision 1.2  86/05/17  22:08:23  avg
 * Сделана работающая версия pr для ДЕМОС+МНОС.
 * Части для print еще не написаны by @@VG.
 *
 * Revision 1.1  86/05/14  22:30:19  avg
 * Initial revision
 *
 */

#ifndef lint
static char rcsid[] = "$Header: pr.c,v 1.25 88/09/21 16:26:04 avg Exp $";
#endif

#include <stdio.h>
#include <ediag.h>
#include <stat.h>
#include <ctype.h>

#define MOVER   8
#define MAXLINE 512
#define MCOLS   8
#define MAXLS   128

/*
 * Внутреннее представление упакованных строк
 *      код
 *      000                     - конец строки
 *      041-0177 и 0300-0377    - печатаемые символы
 *      0200-0277               - упакованные пробелы ( c-0177 пробелов )
 *      001-007                 - пред. символ накладывается на себя c раз
 *      010                     - след. символ - символ наложения
 *      040                     - символ-заполнитель /пусто/
 */

int     ccol;   /* текущая позиция печати */
int     csps;   /* число пробелов - для преобразования в табуляции */

#undef  putchar

#ifdef PRINT
   FILE *OutF;
#  define OOO OutF
#else
#  define OOO stdout
#endif

#define putchar(c) { if(c==' ') csps++;\
		     else { if(csps) outsp(); putc(c,OOO); } }

int     Indent = 0;     /* сдвиг правого края (не входит в width) */

#ifdef PRINT
int     Doopt = 0;      /* оптимизировать свертку строк для АЦПУ */
#endif

/*
 * Вывести пробелы (возм. в виде табуляций)
 */
outsp()
{
	register i = ccol - csps, j;

	while( i < ccol ) {
		if( (j = ((i+8+Indent) & ~07)) <= ccol+Indent &&
		    i+Indent < j-1 ) {
			putc('\t', OOO);
			i = j-Indent;
		} else {
			putc(' ', OOO);
			i++;
		}
	}
	csps = 0;
}

/*
 * Вывод упакованной строки без перевода каретки.
 *  Возвращает 0, если больше нечего печатать
 */
xouts( s )
register char *s;
{
	register       c;
	register char *ss = s;

	while( c = (unsigned)*s ) {
		if( c == 040 ) {
			s++;
			continue;
		}
		if( (041<=c && c <= 0177) || (0300<=c && c<=0377)) {
			putchar( c );
			ccol++;

#ifdef PRINT
			if( Doopt ) {
			    if( s[1] == 040 ) {
				if( s[2] == 010 ) {
					*s++ = 040;
					s++;
					*s++ = 040;
					goto SKIP;
				}
				*s++ = 0200;
				continue;
			    }

			    /* Если был повторитель */
			    if( s[1] >= 001 && s[1] <= 007 ) {
				s++;
				if( --*s == 0 )
					*s = 040;
				s++;
				if( *s != 010 )
					continue;
				s++;
		    SKIP:
				c = *s & 0377;
				if((041<= c && c<=0177) ||
				   (0300<=c && c<=0377)) {
					s++;
					if( *s>=001 && *s<=007 )
						s++;
					if( *s == 010 ) {
						s++;
						goto SKIP;
					}
				}
			    } else if( s[1] == 010 ) {
				*s++ = 040;
				*s++ = 040;
				goto SKIP;
			    } else
				*s++ = 0200;
		    } else {
#endif PRINT
		again:
			    /* Если был повторитель */
			    if( s[1] >= 001 && s[1] <= 007 ) {
				while( s[1] ) {
					s[1]--;
					putc('\b', OOO);
					putc(*s, OOO);
				}
				*s++ = 040;     /* затереть символ */
				goto again;
			    } else if( s[1] == 010 ) {
				putc('\b', OOO);
				putc(s[2], OOO);
				*s++ = 040;     /* затереть символ */
				*s++ = 040;     /* затереть BS */
				goto again;
			    } else
				*s++ = 0200;    /* на месте посл. символа */
#ifdef PRINT
		    }
#endif PRINT
		} else if( 0200 <= c && c <= 0277 ) {
			c = c - 0177;
			while( c-- ) {
				csps++;
				ccol++;
			}
			s++;
		}
	}
	while( --s >= ss && ( (c = (unsigned)*s) == 040 ||
		( 0200 <= c && c <= 0277 ) ) )
			*s = 0;
	return( s >= ss );
}

char   *himem;          /* Верхний адрес памяти */
char   *pf;             /* Начало памяти страницы */
char   *phigh;          /* Верхний адрес заказанной памяти */

#define B       *((himem<phigh)?himem++:(by(),himem++))

/*
 * Выделить область для байтов в буфере страницы
 */
by()
{
	if( sbrk( 512 ) == -1 )
		error( "not enough core", "не хватает памяти ", NULL );
	phigh += 512;
}

/*
 * Выделить заданное число байтов памяти
 *     ( с выравниванием по границе целого )
 */
char *myalloc( n )
register unsigned n;
{
	register char *r;

	if( n & 01 )
		n++;
	if( himem & 01 )
		himem++;
	r = himem;
	while( himem+n >= phigh ) {
		if( sbrk( 512 ) == -1 )
			error( "not enough core", "не хватает памяти ", NULL );
		phigh += 512;
	}
	himem += n;
	return( r );
}

int     ncont = 0;      /* Номер текущей строки продолжения */
int     Mncont= 0;      /* Всего наложений */
int     mflag = 0;      /* Флаг -m */
int     fflag = 0;      /* Флаг -f */
FILE   *ifiles[MCOLS+1]; /* Входные файлы */
int     cwidth = 132;   /* Ширина колонки */
int     FFflag = 0;     /* Был FORM FEED */
int     FFflag1 = 0;
#ifdef ONLINE
int     PagFlag = 0;    /* Останавливаться перед выводом каждой страницы */
int     NonFirstPage = 0;   /* флажок - "это не первая страница" */
int     ttyfd;
#endif

char    ibuf[MOVER][MAXLINE];   /* Входной буфер */

/*
 * Ввод строки с упаковкой
 *  Возвращает EOF для конца файла
 *  и NULL для пустой строки
 *      Аргумент - номер колонки файла ( для работы с -m )
 */
char *xgets( column )
{
	FILE   *iff;
	register sp, i, j;
	char   *r = himem;
	int     c, ctr, c1;

	iff = ifiles[ c = (mflag? column : 0) ];
	if( ncont >= Mncont )
		if( fill( iff, c ) == 0 )
			return( EOF );
	if( ncont == Mncont-1 && FFflag ) {
		FFflag1++;
		FFflag = 0;
	}

	sp = 0;     /* Счетчик пробелов */

	for( i = (ncont++)*cwidth ; i < (ncont*cwidth) && i < MAXLINE ; i++ ) {

		if( ibuf[0][i] ) {  /* не пустое место */

		/* Выдать пробелы */
			while( sp > 0 ) {
				c = (sp > 077)? 077 : sp;
				B = c+0177;
				sp -= c;
			}

#ifdef PRINT
			if( Doopt ) {
		/* Сортировать столбик в порядке убывания */
			    do {
				c = 0;
				for( j = 0; (j < MOVER-1) && ibuf[j+1][i] ; j++ )
					if( ibuf[j][i] > ibuf[j+1][i] ) {
						c            = ibuf[j][i];
						ibuf[j][i]   = ibuf[j+1][i];
						ibuf[j+1][i] = c;
					}
			    } while( c );
			}
#endif PRINT

		/* Выдача байтов строки */

			c1 = 0;
			ctr = 0;
			for( j = 0; (j < MOVER) && (c = ibuf[j][i]) ; j++ ) {
				if( c == c1 ) {
					ctr++;
				} else {
					if( ctr > 0 )
						B = ctr;
					ctr = 0;
					if( c1 )
						B = 010;
					B = c;
				}
				c1 = c;
			}
			if( ctr > 0 )
				B = ctr;

		} else  /* пусто */
			sp++;
	}

	/* Все, строка просмотрена */

	if( himem == r )
		return( NULL );
	B = 0;
	return( r );
}

int     nflag = 0;      /* нумерация строк */
int     xflag = 0;      /* заменить подчеркивания выделением (флаг -x) */
int     bflag = 0;      /* Выделять большие буквы, заменять {}~`| на
			   соотв. ()^'! с наложенным - */
#ifdef PRINT
int     Bflag = 0;      /* ФЕНЯ ДЛЯ print: если у-во LOCAL && !CAP, то
			   как при bflag, но не трогать большие буквы */
int     Bar   = 0;      /* У-во может печатать | */
#endif

unsigned lineno = 1;    /* Номер текущ. строки */

#define U(x) ((x)&0377)

/*
 * Заполнение буфера строки
 *  Если аргумент col = 0 и nflag != 0, то добавлять номер
 *      текущей строки
 *  Возвращает 0 в конце файла
 */
fill( iff, col )
FILE   *iff;
{
	register c, i;
	register unsigned j;
	int      stl, maxi, c1;

	if( feof( iff ) )
		return( 0 );
	for( i = 0; i < MAXLINE ; i++ )
		ibuf[0][i] = 0;

	stl = 0;
	maxi = 0;
	if( nflag && col == 0 ) {
		j = lineno;
		for( i = 4 ; j != 0 ; i-- ) {
			ibuf[0][i] = (j%10)+'0';
			j /= 10;
		}
		stl = 6;
		maxi = 4;
	}
	lineno++;

	i = stl-1;
	while( (c = getc( iff )) != EOF && c != '\n' && c != '\f' ) {
		switch( c ) {

		    case '\r':
			i = stl-1;
			continue;

		    case '\b':
			if( i >= stl )
				i--;
			continue;

		    case '\t':
			i += 8 - ((i-stl+1)%8);
			continue;

		    case ' ':
			i++;
			continue;
		}
		i++;
		if( i >= (fflag? MAXLINE: cwidth) )
			continue;

		c = U(c);
		if( (c < 041 || c > 0177) && (c < 0300) )
			continue;       /* Control char */

		if( i > maxi )
			maxi = i;

		j = 0;
		while( j < MOVER && ibuf[j][i] )
			j++;
		if( j >= MOVER )        /* слишком много наложений */
			continue;
		if( xflag && c == '_' ) {
			ibuf[j][i] = ibuf[0][i];
			ibuf[0][i] = '_';
			if( j < MOVER-1 )
				ibuf[j+1][i] = 0;
			continue;
		}
		if( bflag
#ifdef PRINT
			  || Bflag
#endif PRINT
			  ) {
#ifdef PRINT
			if( Bflag )
				goto SkipB;
#endif PRINT
			if( isalpha(c) && isupper(c) ) {
				c = tolower(c);
				ibuf[j++][i] = c;
				if( j >= MOVER )
					continue;

			/* только двукратное наложение
				ibuf[j++][i] = c;
				if( j >= MOVER )
					continue;
				ibuf[j++][i] = c;
				if( j >= MOVER )
					continue;
			 */

			} else
#ifdef PRINT
			       { SkipB:
#endif
			       switch( c ) {
			    case '{':
				c = '(';
				goto esc;
			    case '}':
				c = ')';
				goto esc;
			    case '`':
				c = '\'';
				goto esc;
			    case '~':
				c = '^';
				goto esc;
			    case '|':
#ifdef PRINT
				if( Bar )
					break;
#endif
				c = '!';
			    esc:
				ibuf[j++][i] = c;
				if( j >= MOVER )
					continue;
				c = '-';
			}
#ifdef PRINT
		   }
#endif

		}
		ibuf[j++][i] = c;
		if( j < MOVER )
			ibuf[j][i] = 0;

	} /* Конец цикла ввода строки */

	if( c == '\f' )
		FFflag++;

	if( c == EOF )
		return(0);

	if( maxi == 0 )
		maxi++;
	Mncont = maxi/cwidth + 1;
	ncont = 0;

	if( xflag ) {
		for( i = stl ; i <= maxi ; i++ ) {
			if( ibuf[0][i] == '_' ) {
				j = 1;
				c1 = 0;
				while( j < MOVER && (c = (unsigned)(ibuf[j][i])) ) {
					if( c != '_' ) {
						c1 = c;
						break;
					}
					j++;
				}
				if( c1 == 0 )
					continue;
				while( j < MOVER && ibuf[j][i] )
					j++;
				ibuf[0][i] = ibuf[--j][i];
				ibuf[j++][i] = c1;
				if( j >= MOVER )
					continue;
				ibuf[j++][i] = c1;
				if( j >= MOVER )
					continue;
				ibuf[j++][i] = c1;
				if( j < MOVER )
					ibuf[j][i] = 0;
			}
		}
	}
	return( 1 );
}

char   *lp[MCOLS][MAXLS];   /* Массив массивов указателей на строки */
int     npage = 0;      /* Номер текущей страницы */
int     tflag = 0;      /* Файл без заголовка */
int     Tflag = 0;      /* Пропуск 2х строк сверху и снизу -- для листованной бумаги */
long    Ftime;          /* Время - для заголовков */
char   *fnames[MCOLS+1]; /* Имена файлов */
int     Nlines = 66;    /* Число строк */
int     Ncols  = 1;     /* Число колонок выдачи */
int     Nolin  = 0;     /* Число строк на следующую страницу */
int     Clin = 0;       /* Номер текущей строки буфера (для -m) */
char    cont[MCOLS];    /* Признаки продолжения файлов  */
int     cont0;          /*   (заполнены 0-ями)          */
char    Schar = ' ';    /* Символ-разделитель           */
int     sflag = 0;      /* Флаг s - без выравнивания колонок */
int     FF[MCOLS+1];    /* Признаки прогонов формата по колонкам при -m */
char   *h = NULL;       /* Заголовок для файла */
char   *uname = NULL;   /* Имя пользователя */
int     Skippag = 0;    /* Номер первой страницы */

int     _Ediag = 0;     /* Флаг - АЦПУ имеет только латинский регистр */

/*
 * Печать заголовка страницы
 */
prhead()
{
	char    *p, *ctime(), *bl;
	register unsigned i;
	int     sediag;
	char    c;

	if( Skippag != 0 )
		return;
#ifdef ONLINE
	/*
	 * Ждать нажатия ВК для печати очередного листа
	 */
	if(PagFlag) {
		if(!NonFirstPage)
			NonFirstPage++;
		else if(ttyfd > 0) {
			fflush(OOO);
			write(ttyfd, ediag( "Next page: ",
					    "След.лист: "), 11);
			do{ read(ttyfd, &c, 1); } while(c != '\n');
		}
	}
#endif ONLINE
	if( !tflag ) {
		char    bs[11];
		int     icol = Indent;

		fputs( "\n\n", OOO );
		if( !Tflag ) {
			sediag = _ediag;
			_ediag = _Ediag || _ediag;
			p = ctime( &Ftime );
			p[24] = 0; /* убрать \n в конце */
			while( icol > 0 ) {
				if( icol >= 8 ) {
					putc('\t', OOO);
					icol -= 8;
				} else {
					putc(' ', OOO);
					icol--;
				}
			}
			fputs( &p[4], OOO );
			fputs( "   ", OOO );
			if( h != NULL )
				fputs( h, OOO );
			else {
				if( mflag ) {
					for( i = 0; i < Ncols; i++ ) {
						fputs( fnames[i], OOO );
						if( i != Ncols-1 ) {
							putc( ',', OOO );
							putc( ' ', OOO );
						}
					}
				} else
					fputs( fnames[0], OOO );
			}
			fputs( ediag( "   page ", "   лист " ), OOO );
			p = &bs[10];
			*p = '\0';
			i = npage;
			while( i > 0 ) {
				*--p = (i%10)+'0';
				i /= 10;
			}
			fputs( p, OOO );
			fputs( ediag( ", line ", ", строка " ), OOO );
			i = lineno-1;
			if( i == 0 ) {
				p = "0";
			} else {
				p = &bs[10];
				*p = '\0';
				while( i > 0 ) {
					*--p = (i%10)+'0';
					i /= 10;
				}
			}
			fputs( p, OOO );
			if( uname != NULL ) {
				fputs( " (", OOO );
				fputs( uname, OOO );
				fputs( ")", OOO );
			}
			fputs( "\n\n\n", OOO );
			_ediag = sediag;
		}
		ccol = 0;
		csps = Indent;
	}
}

/*
 * Заполнение и печать страницы файла
 */
page()
{
	int     ncol, nlin;
	int     i, Enlines, jj, j;
	int     nln;            /* осталось строк */
	int     mr, mr1;
	int     lastj;
	char    SSC;

	Enlines = Nlines;
	npage++;
	csps = Indent;

	if( Skippag > 0 )
		Skippag--;
	if( !tflag )
		Enlines -= Tflag?4:7;

	if(!mflag) {

		/* Чтение листа */

		lastj = Enlines;
		for( i = 0; i < Ncols; i++) {
			for( j = 0 ; j < Enlines ; j++ ) {
				if( cont0 )
					lp[i][j] = NULL;
				else if( (lp[i][j] = xgets(0)) == EOF ) {
					lp[i][j] = NULL;
					cont0 = 1;
				} else if( FFflag1 ) {
					FFflag1 = 0;
					while( ++j < Enlines )
						lp[i][j] = NULL;
					break;
				}

				/* Печать заголовка */

				if( !(i || j) ) {
					if( cont0 )
						return(0);
					prhead();
				}
			}
		}

		/* Печать листа */

		if( Skippag > 0 )
			goto ALLOK;
		for( j = 0; j < lastj ; j++ ) {

			mr1 = 0;

			SSC = Schar;
	overlay:        for( mr = Ncols-1 ; mr>=0 && lp[mr][j]==NULL ; mr-- );
			mr++;
			if( mr == 0 && (SSC == ' ' || mr1) ) {
				putc( '\n', OOO );
				csps = Indent;
				ccol = 0;
				continue;
			}
			if( Schar != ' ' )
				mr = Ncols;
			if( mr1 ) {
				putc( '\r', OOO );
				SSC = ' ';
				csps = Indent;
				ccol = 0;
			}
			for( i = 0 ; i < mr ; i++ ) {
				if( lp[i][j] == NULL ) {
					jj = cwidth+1;
				} else {
					if( !xouts( lp[i][j] ) )
						lp[i][j] = NULL;
					jj = (cwidth+1)*(i+1) - ccol;
				}
				if( i != mr-1 && jj > 0 ) {
					if( !sflag ) {
						while( --jj > 0 ) {
							csps++;
							ccol++;
						}
					}
					putchar( SSC );
					ccol++;
				}
			}
			mr1++;
			goto overlay;
		}

		/* Все, страница напечатана, теперь надо
		   освободить память страницы */

ALLOK:
		himem = pf;

	} else {  /***** С флагом -m *****/

		for( j = 0 ; j < Enlines ; j++ ) {

			/* Если строки для печати нет, то заполнить ее */

			if( Nolin <= 0 ) {

				himem = pf;  /* освоб. память */
				jj = 0;      /* макс. номер строки */

				/* Цикл по файлам */
				for( i = 0 ; i < Ncols ; i++ ) {
					Clin = 0;
					if( cont[i] || FF[i] )
						lp[i][0] = NULL;
					else {
						for(;;) {
							if( (lp[i][Clin] = xgets(i)) == EOF ) {
								cont[i] = 1;

								/* Проверить, все ли файлы кончились */
								cont0 = 1;
								for( lastj = 0 ; lastj < Ncols ; lastj++ )
									if( cont[lastj] == 0 ) {
										cont0 = 0;
										break;
									}
								lp[i][Clin] = NULL;
								break;
							}
							Clin++;
							if( FFflag1 ) {
								FF[i]++;
								FFflag1 = 0;
							}
							if( ncont >= Mncont ) {
								lp[i][Clin] = NULL;
								break;
							}
						}
					}
					if( Clin > jj )
						jj = Clin;
				}
				Nolin = jj;
				Clin  = 0;

				/* Дополнить NULLами */
				for( i = 0 ; i < Ncols ; i++ ) {
					jj = 0;
					while( jj <= Nolin && lp[i][jj] != NULL )
						jj++;
					while( jj <= Nolin )
						lp[i][jj++] = NULL;
				}
			}

			/* Печать заголовка */

			if( !j ) {
				if( Nolin == 0 && cont0 )
					return(0);
				prhead();
			}

			lastj = Enlines;
			if( cont0 && tflag && sflag ) {
				lastj = 0;
				break;
			}

			if( Skippag > 0 ) {
				if( Nolin > 0 )
					Nolin--;
				continue;
			}

			/* Печать ОДНОЙ строки */
			if( Nolin == 0 ) {
				/** -S ??? **/
				csps = Indent;
				putc( '\n', OOO );
				ccol = 0;
				continue;
			}
			Nolin--;

			mr1 = 0;

			SSC = Schar;
	Overlay:        for( mr = Ncols-1 ; mr>=0 && lp[mr][Clin]==NULL ; mr-- );
			mr++;
			if( mr == 0 && (SSC == ' ' || mr1) ) {
				putc( '\n', OOO );
				csps = Indent;
				ccol = 0;
				Clin++;
				continue;
			}
			if( SSC != ' ' )
				mr = Ncols;
			if( mr1 ) {
				putc( '\r', OOO );
				SSC = ' ';
				csps = Indent;
				ccol = 0;
			}
			for( i = 0 ; i < mr ; i++ ) {
				if( lp[i][Clin] == NULL )
					jj = cwidth+1;
				else {
					if( !xouts( lp[i][Clin] ) )
						lp[i][Clin] = NULL;
					jj = (cwidth+1)*(i+1) - ccol;
				}
				if( i != mr-1 && jj > 0 ) {
					if( !sflag ) {
						while( --jj > 0 ) {
							csps++;
							ccol++;
						}
					}
					putchar( SSC );
					ccol++;
				}
			}
			mr1++;
			goto Overlay;
		}

		for( i = 0 ; i < Ncols ; i++ )
			FF[i] = 0;
	}

	if( !tflag && Skippag == 0 ) {
		putc( '\n', OOO );
		putc( '\n', OOO );
		ccol = 0;
		csps = Indent;
	}
	return( lastj != Enlines );
}

char   *ARGV0;

#ifdef PRINT
# include <sys/ioctl.h>
# include <sgtty.h>
# include "getlp.h"
# include "lpspool.h"
  extern struct getlp *LP_PARMS;
#endif PRINT

/*
 * Главная программа
 *      распознает ключи и открывает файлы
 */
main( argc, argv )
char      **argv;
{
	char  **ap = &argv[1];
	int     nsflag = 0;
	int     nfiles = 0;
	register i;
	struct stat stbuf;
	extern char _sobuf[BUFSIZ];
	int     Iflag = 0;
#ifdef PRINT
	char   *Nlp;
	int     Nc  = 1;
	int     f   = 0;
#endif PRINT
	char   *q, *r;
	int     Mwidth = 160;
	int     eopflag;

#ifdef PRINT
	/* Параметры по умолчанию для print */
	Ncols  = -1;
	Mwidth = -1;
	Nlines = -1;
	Nlp    = getenv("PRINTER");
#endif PRINT

	uname = getenv( "USER" );
	fnames[0] = "";
	ifiles[0] = stdin;
	pf = phigh = sbrk(1024);
	phigh += 1024;
	ARGV0 = argv[0];
	time( &Ftime );
	--argc;
#ifndef PRINT
	setbuf( stdout, _sobuf );
#endif PRINT

NEXTARG:
	npage = 0;
	FFflag = FFflag1 = 0;
	Nolin = 0;
	himem = pf;
	ncont = 0;
	Mncont= 0;
	ccol  = 0;
	csps  = 0;
	lineno = 1;
	nfiles = 0;
	cont0  = 0;

	while( argc > 0 ) {
		if( **ap == '+' ) {
			if( (*ap)[1] == 't' ) {
				tflag = 0;
				Tflag = 0;
			} else {
				Skippag = atoi( &((*ap)[1]) );
				if(Skippag <= 0)
					goto BadNum;
			}
		} else if( **ap == '-' ) {
			switch( (*ap)[1] ) {

#ifdef PRINT
			    case 'L':
				Nlp = &(*ap)[2];
				break;

#ifndef ONLINE
			    case 'W':
				f |= XF_WRITE;
				break;

			    case 'M':
				f |= XF_MAIL;
				break;

			    case 'c':
				if( (Nc = atoi( &(*ap)[2] )) < 0 )
					goto BadNum;
				break;
#else
			    case 'M':
			    case 'W':
			    case 'c':
				error( "Keys -MWc not allowed for online print",
				       "Ключи -MWc работают только со спулингом", NULL );
			    case 'P':
				PagFlag++;
				break;
#endif ONLINE
#endif PRINT

			    case 'i':
				if( (*ap)[2] == '\0' ) {
					Indent = 8;
					break;
				}
				if( (Indent = atoi( &(*ap)[2] )) < 0 )
					goto BadNum;
				break;

			    case 'm':
				mflag++;
				break;

			    case 't':
				tflag++;
				break;

			    case 'T':
				Tflag++;
				tflag = 0;
				break;

			    case 's':
				sflag++;
				goto Sc;

			    case 'S':
				sflag = 0;
			    Sc:
				Schar = (*ap)[2];
				if( Schar == '\t' )
					Schar = ' ';
				break;

			    case '0':
			    case '1':
			    case '2':
			    case '3':
			    case '4':
			    case '5':
			    case '6':
			    case '7':
			    case '8':
			    case '9':
				Ncols = atoi( &((*ap)[1]) );
				if(Ncols < 0)
					goto BadNum;
				nsflag++;
				break;

			    case 'w':
				Mwidth = atoi( &((*ap)[2]) );
				if( Mwidth < 0 )
					goto BadNum;
				break;

			    case 'l':
				Nlines = atoi( &((*ap)[2]) );
				if(Nlines < 0)
					goto BadNum;
				break;

			    case 'f':
				fflag++;
				break;

			    case 'b':
				bflag++;
				break;

			    case 'x':
				xflag++;
				break;

			    case 'n':
				nflag++;
				break;

			    case 'h':
				argc--, ap++;
				h = *ap;
				break;

			    case '\0':
				fnames[nfiles  ] = "";
				ifiles[nfiles++] = stdin;
				break;

			    case '*':
				Iflag++;
				break;

			    default:
				if( !Iflag )
					goto USAGE;
			}
		} else {
			if( nfiles >= MCOLS )
				goto Bcols;
			fnames[nfiles++] = *ap;
			if( !mflag ) {
				ap++, argc--;
				break;
			}
		}
		ap++, argc--;
	}

	/* Проверка корректности ключей */

	if( nsflag && mflag )
		error( "can't use -m and -Num simultaneously.",
		       "нельзя использовать -m и -Число одновременно.", NULL );

	if( mflag && nfiles < 2 )
		error( "if -m used note up more than one input file.",
		       "с ключем -m надо указать несколько входных файлов", NULL );
#ifdef ONLINE
	if( PagFlag )
		ttyfd = open("/dev/tty", 2);
#endif ONLINE
#ifdef PRINT
	OutF = tospool( (*fnames[0]=='\0')? "<<pipe>>": fnames[0], f, Nc, Nlp );
	setbuf( OutF, _sobuf );
	if( Nlines < 0 )
		Nlines = LP_PARMS->lp_length;
	if( Mwidth < 0 )
		Mwidth = LP_PARMS->lp_width;
	if( Ncols < 0 )
		Ncols = (Mwidth >= 170) ? 2 : 1;
	Bar   = 0;
	Bflag = 0;
	if( LP_PARMS->lp_class == LPC_LOCAL ) { /* Not with REMOTE ???? */
		if( (LP_PARMS->lp_flags & LPCAP) == 0 && !bflag )
			Bflag++;
		if( LP_PARMS->lp_flags & LPBAR )
			Bar++;
	}
	if( LP_PARMS->lp_class == LPC_LOCAL )
		_Ediag = !(LP_PARMS->lp_flags & LPCYRILL);
	else
		_Ediag = !(LP_PARMS->lp_flags & CYRILL);
	Doopt = (LP_PARMS->lp_filter == NULL) || bflag;
	if( LP_PARMS->lp_xflags & LP_XOPT )
		Doopt = 1;
	else if( LP_PARMS->lp_xflags & LP_XNOOPT )
		Doopt = 0;
#endif PRINT

	if( (Nlines < 10 && !tflag) || Nlines > MAXLS)
		error( "bad number of lines",
		       "плохое число строк", NULL );
	if( mflag )
		Ncols = nfiles;

	if( Ncols < 1 || Ncols > MCOLS )
	   Bcols:
		error( "bad number of columns (max 8)",
		       "плохое число колонок (макс. 8)", NULL );

	if( cwidth < Ncols * 3 || cwidth > MAXLINE)
		error( "bad width for page",
		       "плохая ширина страницы", NULL );

	cwidth = Mwidth;
	if( Ncols > 1 ) {
		cwidth++;
		cwidth /= Ncols;
		cwidth--;
	}

	if( mflag ) {
		for( i = 0 ; i < nfiles ; i++ )
			if( *fnames[i] ) {
#ifdef PRINT
				if( chacc( fnames[i] ) ||
#else
				if(
#endif PRINT
				    (ifiles[i] = fopen( fnames[i], "r" )) == NULL ) {
			    CANTOPEN:
					error( "can't open file ",
					       "не могу открыть файл ", fnames[i] );
				}
				setbuf( ifiles[i], (char *)myalloc( 512 ) );
			}
		pf = himem;
		time( &Ftime );
		do {
			eopflag = page();
		} while( !cont0 );
	} else {
		i = 0;
		if( *fnames[0] ) {
			extern  char    _sibuf[BUFSIZ];

#ifdef PRINT
			if( chacc( fnames[0] ) ||
#else
			if(
#endif PRINT
			    (ifiles[0] = fopen( fnames[0], "r" )) == NULL )
				goto CANTOPEN;
			setbuf( ifiles[0], _sibuf );
			fstat( fileno(ifiles[0]), &stbuf );
			Ftime = stbuf.st_mtime;
		}
		do {
			eopflag = page();
		} while( !cont0 );
		if( *fnames[0] )
			fclose( ifiles[0] );
		if( argc > 0 ) {
#ifdef PRINT
			spclose( npage );
#endif PRINT
			goto NEXTARG;
		}
	}
#ifdef PRINT
	spclose( npage );
#endif PRINT
	exit(0);
USAGE:
	fputs( ediag( "Usage: ", "Вызов: " ), stderr );
	fputs( ARGV0, stderr );
#ifdef PRINT
#ifdef ONLINE
	fputs( " [-P] [-LNN]", stderr );
#else
	fputs( " [-cNN] [-LNN] [-W] [-M]", stderr );
#endif ONLINE
#endif PRINT
	fputs( ediag( " [-m] [-t] [+t] [-NN] [+NN] [-wNN] [-lNN]\n\
	  [-b] [-x] [-n] [-f] [-sc] [-Sc] [-h title] [-iNN] [file...] \n",
		      " [-m] [-t] [+t] [-NN] [+NN] [-wNN] [-lNN]\n\
	  [-b] [-x] [-n] [-f] [-sc] [-Sc] [-h загол.] [-iNN] [файл...]\n" ), stderr  );
	exit(2);

BadNum:
	error( "bad number in key ", "плохое число в ключе ", *ap );
}

/*
 * Печать сообщения об ошибке
 */
error( e, r, a )
char *e, *r, *a;
{
	fputs( ARGV0,      stderr );
	fputs( ": ",       stderr );
	fputs( ediag(e,r), stderr );
	if( a != NULL )
		fputs( a,  stderr );
	fputs( "\n",       stderr );
	exit(1);
}

/*
 * Затычки для стандартных memory allocator-ов
 */
malloc() {return(NULL);}
calloc() {return(NULL);}
free()   {}
realloc(){}
isatty() {return(0);}
fseek()  {}

/*
 * Преобразование строки в целое
 * Возвращает -1 при ошибке
 */
atoi( s )
register char *s;
{
	register i = 0;

	while( *s ) {
		if( *s < '0' || *s > '9' )
			return( -1 );
		i = i*10 + (*s++ - '0');
	}
	return( i );
}
@


1.25
log
@Теперь print, pr и т.п. правильно обрабатывают выделения после nroff-а.
@
text
@d11 3
d97 1
a97 1
static char rcsid[] = "$Header: pr.c,v 1.24 88/05/14 22:17:22 avg Exp $";
d1210 4
@


1.24
log
@Исправлена ошибка в флаге -T.
@
text
@d10 4
a13 1
 * $Log:	pr.c,v $
d18 1
a18 1
 * 
d21 1
a21 1
 * 
d94 1
a94 1
static char rcsid[] = "$Header: pr.c,v 1.23 88/05/14 21:07:08 avg Exp $";
d135 4
d178 3
a180 1
			if( s[1] == 040 ) {
d189 1
d191 2
a192 3
			/* Если был повторитель */

			} else if( s[1] >= 001 && s[1] <= 007 ) {
d201 1
a201 1
				c = (unsigned)*s;
d212 1
a212 1
			} else if( s[1] == 010 ) {
d216 1
a216 1
			} else
d218 23
d346 2
d349 1
a349 1
			do {
d357 3
a359 1
			} while( c );
d1206 1
@


1.23
log
@Исправлена ошибка в -i и
добавлен ключ -T (2 строки сверху/2 строки снизу);
имя печати теперь будет выбираться также и по environ PRINTER.
@
text
@d11 5
d91 1
a91 1
static char rcsid[] = "$Header: pr.c,v 1.22 88/05/04 13:33:37 avg Exp $";
d606 1
a606 1
		if( Tflag ) {
@


1.22
log
@Добавлен ключ -i (установка отступа).
@
text
@d10 4
a13 1
 * $Log:        pr.c,v $
d86 1
a86 1
static char rcsid[] = "$Header: pr.c,v 1.21 88/01/30 18:32:50 avg Exp $";
d551 1
d601 13
a613 11
		sediag = _ediag;
		_ediag = _Ediag || _ediag;
		p = ctime( &Ftime );
		p[24] = 0; /* убрать \n в конце */
		while( icol > 0 ) {
			if( icol >= 8 ) {
				putc('\t', OOO);
				icol -= 8;
			} else {
				putc(' ', OOO);
				icol--;
d615 12
a626 12
		}
		fputs( &p[4], OOO );
		fputs( "   ", OOO );
		if( h != NULL )
			fputs( h, OOO );
		else {
			if( mflag ) {
				for( i = 0; i < Ncols; i++ ) {
					fputs( fnames[i], OOO );
					if( i != Ncols-1 ) {
						putc( ',', OOO );
						putc( ' ', OOO );
d628 4
a631 18
				}
			} else
				fputs( fnames[0], OOO );
		}
		fputs( ediag( "   page ", "   лист " ), OOO );
		p = &bs[10];
		*p = '\0';
		i = npage;
		while( i > 0 ) {
			*--p = (i%10)+'0';
			i /= 10;
		}
		fputs( p, OOO );
		fputs( ediag( ", line ", ", строка " ), OOO );
		i = lineno-1;
		if( i == 0 ) {
			p = "0";
		} else {
d634 1
d639 21
a660 7
		fputs( p, OOO );
		if( uname != NULL ) {
			fputs( " (", OOO );
			fputs( uname, OOO );
			fputs( ")", OOO );
		}
		fputs( "\n\n\n", OOO );
a662 1
		_ediag = sediag;
d680 1
d685 1
a685 1
		Enlines -= 7;
d939 1
a939 1
	char   *Nlp = NULL;
d948 1
a948 1
	tflag  = 0;     /* Параметры по умолчанию для print */
d952 1
d982 1
a982 1
			if( (*ap)[1] == 't' )
d984 2
a985 1
			else {
d1038 5
@


1.21
log
@Был пропущен endif ONLINE
@
text
@d11 3
d83 1
a83 1
static char rcsid[] = "$Header: pr.c,v 1.20 88/01/30 17:23:14 avg Exp $";
d122 2
d132 4
a135 3
		if( (j = ((i+8) & ~07)) <= ccol && i < j-1 ) {
			putc( '\t', OOO );
			i = j;
d137 1
a137 1
			putc( ' ', OOO );
d265 1
d581 9
a589 5
	if(PagFlag && ttyfd > 0 && npage > 1) {
		fflush(OOO);
		write(ttyfd, ediag( "Next page: ",
				     "След.лист: "), 11);
		do{ read(ttyfd, &c, 1); } while(c != '\n');
d594 1
d601 9
d655 1
a655 1
		csps = 0;
d722 1
a722 1
				csps = 0;
d731 1
a731 1
				csps = 0;
d844 1
a844 1
				csps = 0;
d858 1
a858 1
				csps = 0;
d868 1
a868 1
				csps = 0;
d902 1
a902 1
		csps = 0;
d1014 9
d1231 3
d1235 1
a1236 1

d1238 1
a1238 1
	  [-b] [-x] [-n] [-f] [-sc] [-Sc] [-h title] [file...] \n",
d1240 1
a1240 1
	  [-b] [-x] [-n] [-f] [-sc] [-Sc] [-h загол.] [файл...]\n" ), stderr  );
@


1.20
log
@Сделан режим on-line print (без копирования файла в спулинг).
@
text
@d11 3
d80 1
a80 1
static char rcsid[] = "$Header: pr.c,v 1.19 87/02/06 13:57:45 avg Exp $";
d990 1
@


1.19
log
@Исправлена ошибка в -b в КОИ-8.
@
text
@d11 3
d77 1
a77 1
static char rcsid[] = "$Header: pr.c,v 1.18 87/01/13 18:48:20 avg Exp $";
d254 4
d563 1
d565 14
a578 1
	if( !tflag && Skippag == 0 ) {
d965 1
d978 9
d1092 4
@


1.18
log
@При пропуске страниц добавлялись лишние строки внизу.
@
text
@d11 3
d74 1
a74 1
static char rcsid[] = "$Header: pr.c,v 1.17 87/01/12 20:42:07 alex Exp $";
d80 1
d430 2
a431 3
			if( (  'A'  <= c && c <=   'Z') ||
			    (U('А') <= c && c <= U('Я')) ) {
				c += 040;       /* make it lower */
d718 1
a718 1
	} else {  /***** С флагом ,m *****/
d1062 1
a1062 1
	OutF = tospool( (fnames[0]=='\0') ? "<<pipe>>": fnames[0], f, Nc, Nlp );
d1069 1
a1069 1
		Ncols = (Mwidth >= 200) ? 2 : 1;
@


1.17
log
@Исправили ширину по умолчанию на 160.
@
text
@d10 4
a13 1
 * $Log:	pr.c,v $
d16 1
a16 1
 * 
d71 1
a71 1
static char rcsid[] = "$Header: pr.c,v 1.16 87/01/06 09:54:29 avg Exp $";
d850 1
a850 1
	if( !tflag && npage >= Skippag) {
@


1.16
log
@Выделение теперь производится не 4X, а 2Х-кратным выделением.
@
text
@d10 4
a13 1
 * $Log:        pr.c,v $
d68 1
a68 1
static char rcsid[] = "$Header: pr.c,v 1.15 86/11/06 03:12:24 alex Exp $";
d886 1
a886 1
	int     Mwidth = 72;
d1063 1
a1063 1
		Ncols = (Mwidth >= 159) ? 2 : 1;
@


1.15
log
@Ширина по умолчанию сделана 132. Руднев.
@
text
@d10 4
a13 1
 * $Log:	pr.c,v $
d16 1
a16 1
 * 
d20 1
a20 1
 * 
d65 1
a65 1
static char rcsid[] = "$Header: pr.c,v 1.14 86/10/15 23:29:23 root Exp $";
d426 2
d434 2
@


1.14
log
@Изменены умолчания для "print" на -1 +t.
@
text
@d11 3
d62 1
a62 1
static char rcsid[] = "$Header: pr.c,v 1.13 86/09/30 04:48:25 avg Exp $";
d235 1
a235 1
int     cwidth = 72;    /* Ширина колонки */
@


1.13
log
@pr зацикливался на DEL (0177).
Теперь DEL интерпретируется как обычный символ.
@
text
@d10 5
a14 1
 * $Log:        pr.c,v $
d59 1
a59 1
static char rcsid[] = "$Header: pr.c,v 1.12 86/09/22 21:28:26 avg Exp $";
d877 1
a877 1
	tflag  = 1;     /* Параметры по умолчанию для print */
d1050 1
a1050 1
		Ncols = (Mwidth >= 132) ? 2 : 1;
@


1.12
log
@Небольшая правка - тип uname (char) -> (char *).
@
text
@d11 3
d55 1
a55 1
static char rcsid[] = "$Header: pr.c,v 1.11 86/09/22 21:02:01 avg Exp $";
d71 1
a71 1
 *      041-0176 и 0300-0377    - печатаемые символы
d127 1
a127 1
		if( (041<=c && c <= 0176) || (0300<=c && c<=0377)) {
d153 1
a153 1
				if((041<= c && c<=0176) ||
@


1.11
log
@Добавлена печать имени пользователя в заголовке листа.
Кроме того, print теперь работает не под daemon, а под root.
В связи с этим добавлена доп> проверка доступа к файлу.
@
text
@d11 5
d52 1
a52 1
static char rcsid[] = "$Header: pr.c,v 1.10 86/09/19 20:01:21 avg Exp $";
d517 1
a517 1
char    uname = NULL;   /* Имя пользователя */
d578 1
a578 1
			fputs( "  --- ", OOO );
d580 1
a580 1
			fputs( " ---", OOO );
@


1.10
log
@По просьбе DV заменено слово string на line.
@
text
@d8 1
d11 3
d47 1
a47 1
static char rcsid[] = "$Header: pr.c,v 1.9 86/07/16 20:54:11 avg Exp $";
d512 1
d572 5
a868 1
	setuid(1);      /* The devil himself */
d871 1
d1078 6
a1083 1
				if( (ifiles[i] = fopen( fnames[i], "r" )) == NULL ) {
d1100 6
a1105 1
			if( (ifiles[0] = fopen( fnames[0], "r" )) == NULL )
@


1.9
log
@Входной файл print (без -m) закрывался даже в том случае,
когда он == stdin.
@
text
@d10 4
d43 1
a43 1
static char rcsid[] = "$Header: pr.c,v 1.8 86/06/14 21:35:30 avg Exp $";
d554 1
a554 1
		fputs( ediag( ", string ", ", строка " ), OOO );
@


1.8
log
@Еще одна правка - ошибка при выдаче номера строки.
@
text
@d10 3
d39 1
a39 1
static char rcsid[] = "$Header: pr.c,v 1.7 86/05/30 17:36:34 avg Exp $";
d1090 2
a1091 1
		fclose( ifiles[0] );
@


1.7
log
@Исправлен счет строк в заголовках.
@
text
@d10 3
d36 1
a36 1
static char rcsid[] = "$Header: pr.c,v 1.6 86/05/30 13:23:53 avg Exp $";
d328 1
a328 1
		j = lineno++;
d336 1
d538 1
a538 1
		fputs( ediag( "   Page ", "   Лист " ), OOO );
d549 9
a557 5
		p = &bs[10];
		*p = '\0';
		while( i > 0 ) {
			*--p = (i%10)+'0';
			i /= 10;
@


1.6
log
@Исправлена ошибка в обработке ключа -c.
@
text
@d10 3
d33 1
a33 1
static char rcsid[] = "$Header: pr.c,v 1.5 86/05/19 15:45:47 avg Exp $";
d544 1
a544 1
		i = (npage-1)*Nlines +1;
@


1.5
log
@Поправлена ошибка и добавлен include <sgtty.h>.
@
text
@d10 3
d30 1
a30 1
static char rcsid[] = "$Header: pr.c,v 1.4 86/05/19 15:27:27 avg Exp $";
d894 1
a894 1
				if( atoi( Nc =  &(*ap)[2] ) < 0 )
@


1.4
log
@Язык строки в заголовке теперь всегда будет английский,
если АЦПУ / линия не имеют флага CYRILL.
@
text
@d10 4
d27 1
a27 1
static char rcsid[] = "$Header: pr.c,v 1.3 86/05/18 21:04:31 avg Exp $";
d804 1
d1017 1
a1017 1
		_Ediag = !(LP_PARMS->lp_flags & LPCYRILL)
@


1.3
log
@Сделаны доделки для работы в print-е.
@
text
@d10 3
d23 1
a23 1
static char rcsid[] = "$Header: pr.c,v 1.2 86/05/17 22:08:23 avg Exp $";
d489 1
d497 2
a498 1
	register i;
d501 1
a501 1
		char    bs[6];
d504 2
d525 2
a526 2
		bs[5] = 0;
		p = &bs[5];
d533 9
d545 1
d1011 4
@


1.2
log
@Сделана работающая версия pr для ДЕМОС+МНОС.
Части для print еще не написаны by @@VG.
@
text
@d10 4
d20 1
a20 1
static char rcsid[] = "$Header$";
d47 8
d56 1
a56 1
		     else { if(csps) outsp(); putc(c,stdout); } }
d67 1
a67 1
			putc( '\t', stdout );
d70 1
a70 1
			putc( ' ', stdout );
d281 6
d365 9
a373 1
		if( bflag ) {
d386 5
a390 1
			} else switch( c ) {
d404 4
d415 4
d498 1
a498 1
		fputs( "\n\n", stdout );
d501 2
a502 2
		fputs( &p[4], stdout );
		fputs( "   ", stdout );
d504 1
a504 1
			fputs( h, stdout );
d508 1
a508 1
					fputs( fnames[i], stdout );
d510 2
a511 2
						putc( ',', stdout );
						putc( ' ', stdout );
d515 1
a515 1
				fputs( fnames[0], stdout );
d517 1
a517 1
		fputs( ediag( "   Page ", "   Лист " ), stdout );
d525 2
a526 2
		fputs( p, stdout );
		fputs( "\n\n\n", stdout );
d542 1
d589 1
d592 2
a593 2
			if( mr == 0 && (Schar == ' ' || mr1) ) {
				putc( '\n', stdout );
d601 2
a602 1
				putc( '\r', stdout );
d621 1
a621 1
					putchar( Schar );
d717 1
a717 1
				putc( '\n', stdout );
d725 1
d728 2
a729 2
			if( mr == 0 && (Schar == ' ' || mr1) ) {
				putc( '\n', stdout );
d735 1
a735 1
			if( Schar != ' ' )
d738 2
a739 1
				putc( '\r', stdout );
d758 1
a758 1
					putchar( Schar );
d771 2
a772 2
		putc( '\n', stdout );
		putc( '\n', stdout );
d781 7
d803 3
a805 1
	char   *Nlp = "-", *Nc = "1";
a810 1

d812 5
a816 3
		tflag  = 1;     /* Параметры по умолчанию для print */
		Ncols  = 2;
		Mwidth = 153;
d826 1
d828 1
a857 3
				if( *Nlp != '-' &&
				   (*Nlp < '0' || *Nlp > '9') )
					goto BadNum;
d860 8
d977 18
a1017 24
#ifdef PRINT
	/* Запуск OPR */
	if( OPRf && !OPRready ) {
		int     ch[2];

		pipe( ch );
		if( fork() == 0 ) {
			if( *fnames[0] == '\0' )
				fnames[0] = "$$PIPE$$";
			dup2( ch[0], 0 );
			close( ch[0] );
			close( ch[1] );
			execl( OPR, "opr", "-c", Nc,
				    "-l", Nlp, "-n", fnames[0], 0 );
			error( "cannot execute ",
			       "не могу запустить ", OPR );
		}
		dup2( ch[1], 1 );
		close( ch[0] );
		close( ch[1] );
		OPRready = 1;
	}
#endif PRINT

d1048 4
a1051 1
		if( argc > 0 )
d1053 1
d1055 3
d1063 1
a1063 1
	fputs( " [-cNN] [-LNN]", stderr );
@


1.1
log
@Initial revision
@
text
@d9 4
a12 1
 * $Log$
d15 4
a22 1
#define OPR     "/bin/opr"
d405 1
a405 4
					if( '0'     <= c && c <= '9' ||
					    'a'     <= c && c <= 'z' ||
					    'A'     <= c && c <= 'Z' ||
					     U('А') <= c && c <= U('я') ) {
d434 1
a434 1
long    ftime;          /* Время - для заголовков */
d461 1
a461 1
		p = ctime( &ftime );
a524 2
					if( i == 0 && tflag )
						lastj = j;
d545 1
a545 1
			goto Все;
d550 1
a550 1
	наложение:      for( mr = Ncols-1 ; mr>=0 && lp[mr][j]==NULL ; mr-- );
d585 1
a585 1
			goto наложение;
d591 1
a591 1
Все:
d594 1
a594 1
	} else {  /***** С флагом -m *****/
d661 1
a661 1
			if( cont0 && tflag ) {
d684 1
a684 1
	Наложение:      for( mr = Ncols-1 ; mr>=0 && lp[mr][Clin]==NULL ; mr-- );
d720 1
a720 1
			goto Наложение;
d750 3
a752 2
	extern char     _sobuf[512];
	int     Iflag = 0, OPRf, OPRready = 0;
d754 1
d760 1
a760 14
	/* Проверка имени : если print, то поставить OPRf */

	q = r = argv[0];
	while( *q )
		q++;
	while( *q != '/' && q >= r )
		q--;
	q++;
	r = "print";
	OPRf = 1;
	while( *r && *q++ == *r++ );
	if( *q || *r )
		OPRf = 0;
	if( OPRf ) {
d764 1
a764 1
	}
d771 1
a771 1
	time( &ftime );
d800 1
a801 3
				if( !OPRf )
					error( "lp number must be noted only with print command",
					       "номер АЦПУ может указываться только в команде print", NULL );
a808 3
				if( !OPRf )
					error( "number of copies must be noted only with print command",
					       "число копий может указываться только в команде print", NULL );
d812 1
d940 1
d961 2
a962 2
	} else if( !tflag && OPRf && OPRready && eopflag )
		putc( '\f', stdout );
d972 1
a972 1
				setbuf( ifiles[i], myalloc( 512 ) );
d975 1
a975 1
		time( &ftime );
d982 1
a982 1
			extern  char    _sibuf[512];
d988 1
a988 1
			ftime = stbuf.st_mtime;
d1001 3
a1003 2
	if( OPRf )
		fputs( " [-cNN] [-LNN]", stderr );
@
